// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"coresamples/ent/accountsubscription"
	"coresamples/ent/address"
	"coresamples/ent/betaprogram"
	"coresamples/ent/betaprogramparticipation"
	"coresamples/ent/clinic"
	"coresamples/ent/contact"
	"coresamples/ent/countrylist"
	"coresamples/ent/customer"
	"coresamples/ent/customeraddressonclinics"
	"coresamples/ent/customercontactonclinics"
	"coresamples/ent/customersettingonclinics"
	"coresamples/ent/internaluser"
	"coresamples/ent/labordersendhistory"
	"coresamples/ent/loginhistory"
	"coresamples/ent/orderflag"
	"coresamples/ent/orderinfo"
	"coresamples/ent/patient"
	"coresamples/ent/patientflag"
	"coresamples/ent/patientweightheight"
	"coresamples/ent/pendingordercredits"
	"coresamples/ent/predicate"
	"coresamples/ent/rbacactions"
	"coresamples/ent/rbacresources"
	"coresamples/ent/rbacroles"
	"coresamples/ent/salesteam"
	"coresamples/ent/salesterritory"
	"coresamples/ent/salestitle"
	"coresamples/ent/sample"
	"coresamples/ent/sampleidgenerate"
	"coresamples/ent/sampletype"
	"coresamples/ent/serviceship"
	"coresamples/ent/serviceshipbillingplan"
	"coresamples/ent/setting"
	"coresamples/ent/test"
	"coresamples/ent/testdetail"
	"coresamples/ent/testlist"
	"coresamples/ent/tube"
	"coresamples/ent/tubeinstructions"
	"coresamples/ent/tubereceive"
	"coresamples/ent/tuberequirement"
	"coresamples/ent/tubetype"
	"coresamples/ent/user"
	"coresamples/ent/userinvitationrecord"
	"coresamples/ent/zipcode"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountSubscription      = "AccountSubscription"
	TypeAddress                  = "Address"
	TypeBetaProgram              = "BetaProgram"
	TypeBetaProgramParticipation = "BetaProgramParticipation"
	TypeClinic                   = "Clinic"
	TypeContact                  = "Contact"
	TypeCountryList              = "CountryList"
	TypeCustomer                 = "Customer"
	TypeCustomerAddressOnClinics = "CustomerAddressOnClinics"
	TypeCustomerContactOnClinics = "CustomerContactOnClinics"
	TypeCustomerSettingOnClinics = "CustomerSettingOnClinics"
	TypeInternalUser             = "InternalUser"
	TypeLabOrderSendHistory      = "LabOrderSendHistory"
	TypeLoginHistory             = "LoginHistory"
	TypeOrderFlag                = "OrderFlag"
	TypeOrderInfo                = "OrderInfo"
	TypePatient                  = "Patient"
	TypePatientFlag              = "PatientFlag"
	TypePatientWeightHeight      = "PatientWeightHeight"
	TypePendingOrderCredits      = "PendingOrderCredits"
	TypeRBACActions              = "RBACActions"
	TypeRBACResources            = "RBACResources"
	TypeRBACRoles                = "RBACRoles"
	TypeSalesTeam                = "SalesTeam"
	TypeSalesTerritory           = "SalesTerritory"
	TypeSalesTitle               = "SalesTitle"
	TypeSample                   = "Sample"
	TypeSampleIDGenerate         = "SampleIDGenerate"
	TypeSampleType               = "SampleType"
	TypeServiceship              = "Serviceship"
	TypeServiceshipBillingPlan   = "ServiceshipBillingPlan"
	TypeSetting                  = "Setting"
	TypeTest                     = "Test"
	TypeTestDetail               = "TestDetail"
	TypeTestList                 = "TestList"
	TypeTube                     = "Tube"
	TypeTubeInstructions         = "TubeInstructions"
	TypeTubeReceive              = "TubeReceive"
	TypeTubeRequirement          = "TubeRequirement"
	TypeTubeType                 = "TubeType"
	TypeUser                     = "User"
	TypeUserInvitationRecord     = "UserInvitationRecord"
	TypeZipcode                  = "Zipcode"
)

// AccountSubscriptionMutation represents an operation that mutates the AccountSubscription nodes in the graph.
type AccountSubscriptionMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	account_id                      *int64
	addaccount_id                   *int64
	account_type                    *accountsubscription.AccountType
	subscriber_name                 *string
	email                           *string
	start_time                      *time.Time
	end_time                        *time.Time
	clearedFields                   map[string]struct{}
	serviceship_billing_plan        *int
	clearedserviceship_billing_plan bool
	serviceship                     *int
	clearedserviceship              bool
	done                            bool
	oldValue                        func(context.Context) (*AccountSubscription, error)
	predicates                      []predicate.AccountSubscription
}

var _ ent.Mutation = (*AccountSubscriptionMutation)(nil)

// accountsubscriptionOption allows management of the mutation configuration using functional options.
type accountsubscriptionOption func(*AccountSubscriptionMutation)

// newAccountSubscriptionMutation creates new mutation for the AccountSubscription entity.
func newAccountSubscriptionMutation(c config, op Op, opts ...accountsubscriptionOption) *AccountSubscriptionMutation {
	m := &AccountSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountSubscriptionID sets the ID field of the mutation.
func withAccountSubscriptionID(id int) accountsubscriptionOption {
	return func(m *AccountSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountSubscription
		)
		m.oldValue = func(ctx context.Context) (*AccountSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountSubscription sets the old AccountSubscription of the mutation.
func withAccountSubscription(node *AccountSubscription) accountsubscriptionOption {
	return func(m *AccountSubscriptionMutation) {
		m.oldValue = func(context.Context) (*AccountSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountSubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountSubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *AccountSubscriptionMutation) SetAccountID(i int64) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountSubscriptionMutation) AccountID() (r int64, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *AccountSubscriptionMutation) AddAccountID(i int64) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *AccountSubscriptionMutation) AddedAccountID() (r int64, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountSubscriptionMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetAccountType sets the "account_type" field.
func (m *AccountSubscriptionMutation) SetAccountType(at accountsubscription.AccountType) {
	m.account_type = &at
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *AccountSubscriptionMutation) AccountType() (r accountsubscription.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldAccountType(ctx context.Context) (v accountsubscription.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *AccountSubscriptionMutation) ResetAccountType() {
	m.account_type = nil
}

// SetSubscriberName sets the "subscriber_name" field.
func (m *AccountSubscriptionMutation) SetSubscriberName(s string) {
	m.subscriber_name = &s
}

// SubscriberName returns the value of the "subscriber_name" field in the mutation.
func (m *AccountSubscriptionMutation) SubscriberName() (r string, exists bool) {
	v := m.subscriber_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriberName returns the old "subscriber_name" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldSubscriberName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriberName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriberName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriberName: %w", err)
	}
	return oldValue.SubscriberName, nil
}

// ResetSubscriberName resets all changes to the "subscriber_name" field.
func (m *AccountSubscriptionMutation) ResetSubscriberName() {
	m.subscriber_name = nil
}

// SetEmail sets the "email" field.
func (m *AccountSubscriptionMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountSubscriptionMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountSubscriptionMutation) ResetEmail() {
	m.email = nil
}

// SetStartTime sets the "start_time" field.
func (m *AccountSubscriptionMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *AccountSubscriptionMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *AccountSubscriptionMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *AccountSubscriptionMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *AccountSubscriptionMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the AccountSubscription entity.
// If the AccountSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSubscriptionMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *AccountSubscriptionMutation) ResetEndTime() {
	m.end_time = nil
}

// SetServiceshipBillingPlanID sets the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity by id.
func (m *AccountSubscriptionMutation) SetServiceshipBillingPlanID(id int) {
	m.serviceship_billing_plan = &id
}

// ClearServiceshipBillingPlan clears the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity.
func (m *AccountSubscriptionMutation) ClearServiceshipBillingPlan() {
	m.clearedserviceship_billing_plan = true
}

// ServiceshipBillingPlanCleared reports if the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity was cleared.
func (m *AccountSubscriptionMutation) ServiceshipBillingPlanCleared() bool {
	return m.clearedserviceship_billing_plan
}

// ServiceshipBillingPlanID returns the "serviceship_billing_plan" edge ID in the mutation.
func (m *AccountSubscriptionMutation) ServiceshipBillingPlanID() (id int, exists bool) {
	if m.serviceship_billing_plan != nil {
		return *m.serviceship_billing_plan, true
	}
	return
}

// ServiceshipBillingPlanIDs returns the "serviceship_billing_plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceshipBillingPlanID instead. It exists only for internal usage by the builders.
func (m *AccountSubscriptionMutation) ServiceshipBillingPlanIDs() (ids []int) {
	if id := m.serviceship_billing_plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceshipBillingPlan resets all changes to the "serviceship_billing_plan" edge.
func (m *AccountSubscriptionMutation) ResetServiceshipBillingPlan() {
	m.serviceship_billing_plan = nil
	m.clearedserviceship_billing_plan = false
}

// SetServiceshipID sets the "serviceship" edge to the Serviceship entity by id.
func (m *AccountSubscriptionMutation) SetServiceshipID(id int) {
	m.serviceship = &id
}

// ClearServiceship clears the "serviceship" edge to the Serviceship entity.
func (m *AccountSubscriptionMutation) ClearServiceship() {
	m.clearedserviceship = true
}

// ServiceshipCleared reports if the "serviceship" edge to the Serviceship entity was cleared.
func (m *AccountSubscriptionMutation) ServiceshipCleared() bool {
	return m.clearedserviceship
}

// ServiceshipID returns the "serviceship" edge ID in the mutation.
func (m *AccountSubscriptionMutation) ServiceshipID() (id int, exists bool) {
	if m.serviceship != nil {
		return *m.serviceship, true
	}
	return
}

// ServiceshipIDs returns the "serviceship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceshipID instead. It exists only for internal usage by the builders.
func (m *AccountSubscriptionMutation) ServiceshipIDs() (ids []int) {
	if id := m.serviceship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceship resets all changes to the "serviceship" edge.
func (m *AccountSubscriptionMutation) ResetServiceship() {
	m.serviceship = nil
	m.clearedserviceship = false
}

// Where appends a list predicates to the AccountSubscriptionMutation builder.
func (m *AccountSubscriptionMutation) Where(ps ...predicate.AccountSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountSubscription).
func (m *AccountSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.account_id != nil {
		fields = append(fields, accountsubscription.FieldAccountID)
	}
	if m.account_type != nil {
		fields = append(fields, accountsubscription.FieldAccountType)
	}
	if m.subscriber_name != nil {
		fields = append(fields, accountsubscription.FieldSubscriberName)
	}
	if m.email != nil {
		fields = append(fields, accountsubscription.FieldEmail)
	}
	if m.start_time != nil {
		fields = append(fields, accountsubscription.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, accountsubscription.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountsubscription.FieldAccountID:
		return m.AccountID()
	case accountsubscription.FieldAccountType:
		return m.AccountType()
	case accountsubscription.FieldSubscriberName:
		return m.SubscriberName()
	case accountsubscription.FieldEmail:
		return m.Email()
	case accountsubscription.FieldStartTime:
		return m.StartTime()
	case accountsubscription.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountsubscription.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountsubscription.FieldAccountType:
		return m.OldAccountType(ctx)
	case accountsubscription.FieldSubscriberName:
		return m.OldSubscriberName(ctx)
	case accountsubscription.FieldEmail:
		return m.OldEmail(ctx)
	case accountsubscription.FieldStartTime:
		return m.OldStartTime(ctx)
	case accountsubscription.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown AccountSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountsubscription.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountsubscription.FieldAccountType:
		v, ok := value.(accountsubscription.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case accountsubscription.FieldSubscriberName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriberName(v)
		return nil
	case accountsubscription.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case accountsubscription.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case accountsubscription.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addaccount_id != nil {
		fields = append(fields, accountsubscription.FieldAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountsubscription.FieldAccountID:
		return m.AddedAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountsubscription.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountSubscriptionMutation) ResetField(name string) error {
	switch name {
	case accountsubscription.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountsubscription.FieldAccountType:
		m.ResetAccountType()
		return nil
	case accountsubscription.FieldSubscriberName:
		m.ResetSubscriberName()
		return nil
	case accountsubscription.FieldEmail:
		m.ResetEmail()
		return nil
	case accountsubscription.FieldStartTime:
		m.ResetStartTime()
		return nil
	case accountsubscription.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown AccountSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.serviceship_billing_plan != nil {
		edges = append(edges, accountsubscription.EdgeServiceshipBillingPlan)
	}
	if m.serviceship != nil {
		edges = append(edges, accountsubscription.EdgeServiceship)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountsubscription.EdgeServiceshipBillingPlan:
		if id := m.serviceship_billing_plan; id != nil {
			return []ent.Value{*id}
		}
	case accountsubscription.EdgeServiceship:
		if id := m.serviceship; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserviceship_billing_plan {
		edges = append(edges, accountsubscription.EdgeServiceshipBillingPlan)
	}
	if m.clearedserviceship {
		edges = append(edges, accountsubscription.EdgeServiceship)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case accountsubscription.EdgeServiceshipBillingPlan:
		return m.clearedserviceship_billing_plan
	case accountsubscription.EdgeServiceship:
		return m.clearedserviceship
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case accountsubscription.EdgeServiceshipBillingPlan:
		m.ClearServiceshipBillingPlan()
		return nil
	case accountsubscription.EdgeServiceship:
		m.ClearServiceship()
		return nil
	}
	return fmt.Errorf("unknown AccountSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case accountsubscription.EdgeServiceshipBillingPlan:
		m.ResetServiceshipBillingPlan()
		return nil
	case accountsubscription.EdgeServiceship:
		m.ResetServiceship()
		return nil
	}
	return fmt.Errorf("unknown AccountSubscription edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	address_type                    *string
	street_address                  *string
	apt_po                          *string
	city                            *string
	state                           *string
	zipcode                         *string
	country                         *string
	address_confirmed               *bool
	is_primary_address              *bool
	address_level                   *int
	addaddress_level                *int
	address_level_name              *string
	apply_to_all_group_member       *bool
	is_group_address                *bool
	use_as_default_create_address   *bool
	use_group_address               *bool
	clearedFields                   map[string]struct{}
	clinic                          *int
	clearedclinic                   bool
	customer                        *int
	clearedcustomer                 bool
	customer_clinic_mappings        map[int]struct{}
	removedcustomer_clinic_mappings map[int]struct{}
	clearedcustomer_clinic_mappings bool
	member_addresses                map[int]struct{}
	removedmember_addresses         map[int]struct{}
	clearedmember_addresses         bool
	group_address                   *int
	clearedgroup_address            bool
	internal_user                   *int
	clearedinternal_user            bool
	patient                         *int
	clearedpatient                  bool
	orders                          map[int]struct{}
	removedorders                   map[int]struct{}
	clearedorders                   bool
	done                            bool
	oldValue                        func(context.Context) (*Address, error)
	predicates                      []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddressType sets the "address_type" field.
func (m *AddressMutation) SetAddressType(s string) {
	m.address_type = &s
}

// AddressType returns the value of the "address_type" field in the mutation.
func (m *AddressMutation) AddressType() (r string, exists bool) {
	v := m.address_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressType returns the old "address_type" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressType: %w", err)
	}
	return oldValue.AddressType, nil
}

// ClearAddressType clears the value of the "address_type" field.
func (m *AddressMutation) ClearAddressType() {
	m.address_type = nil
	m.clearedFields[address.FieldAddressType] = struct{}{}
}

// AddressTypeCleared returns if the "address_type" field was cleared in this mutation.
func (m *AddressMutation) AddressTypeCleared() bool {
	_, ok := m.clearedFields[address.FieldAddressType]
	return ok
}

// ResetAddressType resets all changes to the "address_type" field.
func (m *AddressMutation) ResetAddressType() {
	m.address_type = nil
	delete(m.clearedFields, address.FieldAddressType)
}

// SetStreetAddress sets the "street_address" field.
func (m *AddressMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *AddressMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreetAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ClearStreetAddress clears the value of the "street_address" field.
func (m *AddressMutation) ClearStreetAddress() {
	m.street_address = nil
	m.clearedFields[address.FieldStreetAddress] = struct{}{}
}

// StreetAddressCleared returns if the "street_address" field was cleared in this mutation.
func (m *AddressMutation) StreetAddressCleared() bool {
	_, ok := m.clearedFields[address.FieldStreetAddress]
	return ok
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *AddressMutation) ResetStreetAddress() {
	m.street_address = nil
	delete(m.clearedFields, address.FieldStreetAddress)
}

// SetAptPo sets the "apt_po" field.
func (m *AddressMutation) SetAptPo(s string) {
	m.apt_po = &s
}

// AptPo returns the value of the "apt_po" field in the mutation.
func (m *AddressMutation) AptPo() (r string, exists bool) {
	v := m.apt_po
	if v == nil {
		return
	}
	return *v, true
}

// OldAptPo returns the old "apt_po" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAptPo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptPo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptPo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptPo: %w", err)
	}
	return oldValue.AptPo, nil
}

// ClearAptPo clears the value of the "apt_po" field.
func (m *AddressMutation) ClearAptPo() {
	m.apt_po = nil
	m.clearedFields[address.FieldAptPo] = struct{}{}
}

// AptPoCleared returns if the "apt_po" field was cleared in this mutation.
func (m *AddressMutation) AptPoCleared() bool {
	_, ok := m.clearedFields[address.FieldAptPo]
	return ok
}

// ResetAptPo resets all changes to the "apt_po" field.
func (m *AddressMutation) ResetAptPo() {
	m.apt_po = nil
	delete(m.clearedFields, address.FieldAptPo)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AddressMutation) ClearCity() {
	m.city = nil
	m.clearedFields[address.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AddressMutation) CityCleared() bool {
	_, ok := m.clearedFields[address.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, address.FieldCity)
}

// SetState sets the "state" field.
func (m *AddressMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *AddressMutation) ClearState() {
	m.state = nil
	m.clearedFields[address.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *AddressMutation) StateCleared() bool {
	_, ok := m.clearedFields[address.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *AddressMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, address.FieldState)
}

// SetZipcode sets the "zipcode" field.
func (m *AddressMutation) SetZipcode(s string) {
	m.zipcode = &s
}

// Zipcode returns the value of the "zipcode" field in the mutation.
func (m *AddressMutation) Zipcode() (r string, exists bool) {
	v := m.zipcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipcode returns the old "zipcode" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZipcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipcode: %w", err)
	}
	return oldValue.Zipcode, nil
}

// ClearZipcode clears the value of the "zipcode" field.
func (m *AddressMutation) ClearZipcode() {
	m.zipcode = nil
	m.clearedFields[address.FieldZipcode] = struct{}{}
}

// ZipcodeCleared returns if the "zipcode" field was cleared in this mutation.
func (m *AddressMutation) ZipcodeCleared() bool {
	_, ok := m.clearedFields[address.FieldZipcode]
	return ok
}

// ResetZipcode resets all changes to the "zipcode" field.
func (m *AddressMutation) ResetZipcode() {
	m.zipcode = nil
	delete(m.clearedFields, address.FieldZipcode)
}

// SetCountry sets the "country" field.
func (m *AddressMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *AddressMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[address.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *AddressMutation) CountryCleared() bool {
	_, ok := m.clearedFields[address.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *AddressMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, address.FieldCountry)
}

// SetAddressConfirmed sets the "address_confirmed" field.
func (m *AddressMutation) SetAddressConfirmed(b bool) {
	m.address_confirmed = &b
}

// AddressConfirmed returns the value of the "address_confirmed" field in the mutation.
func (m *AddressMutation) AddressConfirmed() (r bool, exists bool) {
	v := m.address_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressConfirmed returns the old "address_confirmed" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressConfirmed: %w", err)
	}
	return oldValue.AddressConfirmed, nil
}

// ResetAddressConfirmed resets all changes to the "address_confirmed" field.
func (m *AddressMutation) ResetAddressConfirmed() {
	m.address_confirmed = nil
}

// SetIsPrimaryAddress sets the "is_primary_address" field.
func (m *AddressMutation) SetIsPrimaryAddress(b bool) {
	m.is_primary_address = &b
}

// IsPrimaryAddress returns the value of the "is_primary_address" field in the mutation.
func (m *AddressMutation) IsPrimaryAddress() (r bool, exists bool) {
	v := m.is_primary_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimaryAddress returns the old "is_primary_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldIsPrimaryAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimaryAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimaryAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimaryAddress: %w", err)
	}
	return oldValue.IsPrimaryAddress, nil
}

// ResetIsPrimaryAddress resets all changes to the "is_primary_address" field.
func (m *AddressMutation) ResetIsPrimaryAddress() {
	m.is_primary_address = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AddressMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AddressMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *AddressMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[address.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *AddressMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[address.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AddressMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, address.FieldCustomerID)
}

// SetPatientID sets the "patient_id" field.
func (m *AddressMutation) SetPatientID(i int) {
	m.patient = &i
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *AddressMutation) PatientID() (r int, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPatientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ClearPatientID clears the value of the "patient_id" field.
func (m *AddressMutation) ClearPatientID() {
	m.patient = nil
	m.clearedFields[address.FieldPatientID] = struct{}{}
}

// PatientIDCleared returns if the "patient_id" field was cleared in this mutation.
func (m *AddressMutation) PatientIDCleared() bool {
	_, ok := m.clearedFields[address.FieldPatientID]
	return ok
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *AddressMutation) ResetPatientID() {
	m.patient = nil
	delete(m.clearedFields, address.FieldPatientID)
}

// SetClinicID sets the "clinic_id" field.
func (m *AddressMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *AddressMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ClearClinicID clears the value of the "clinic_id" field.
func (m *AddressMutation) ClearClinicID() {
	m.clinic = nil
	m.clearedFields[address.FieldClinicID] = struct{}{}
}

// ClinicIDCleared returns if the "clinic_id" field was cleared in this mutation.
func (m *AddressMutation) ClinicIDCleared() bool {
	_, ok := m.clearedFields[address.FieldClinicID]
	return ok
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *AddressMutation) ResetClinicID() {
	m.clinic = nil
	delete(m.clearedFields, address.FieldClinicID)
}

// SetInternalUserID sets the "internal_user_id" field.
func (m *AddressMutation) SetInternalUserID(i int) {
	m.internal_user = &i
}

// InternalUserID returns the value of the "internal_user_id" field in the mutation.
func (m *AddressMutation) InternalUserID() (r int, exists bool) {
	v := m.internal_user
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserID returns the old "internal_user_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldInternalUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserID: %w", err)
	}
	return oldValue.InternalUserID, nil
}

// ClearInternalUserID clears the value of the "internal_user_id" field.
func (m *AddressMutation) ClearInternalUserID() {
	m.internal_user = nil
	m.clearedFields[address.FieldInternalUserID] = struct{}{}
}

// InternalUserIDCleared returns if the "internal_user_id" field was cleared in this mutation.
func (m *AddressMutation) InternalUserIDCleared() bool {
	_, ok := m.clearedFields[address.FieldInternalUserID]
	return ok
}

// ResetInternalUserID resets all changes to the "internal_user_id" field.
func (m *AddressMutation) ResetInternalUserID() {
	m.internal_user = nil
	delete(m.clearedFields, address.FieldInternalUserID)
}

// SetAddressLevel sets the "address_level" field.
func (m *AddressMutation) SetAddressLevel(i int) {
	m.address_level = &i
	m.addaddress_level = nil
}

// AddressLevel returns the value of the "address_level" field in the mutation.
func (m *AddressMutation) AddressLevel() (r int, exists bool) {
	v := m.address_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLevel returns the old "address_level" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLevel: %w", err)
	}
	return oldValue.AddressLevel, nil
}

// AddAddressLevel adds i to the "address_level" field.
func (m *AddressMutation) AddAddressLevel(i int) {
	if m.addaddress_level != nil {
		*m.addaddress_level += i
	} else {
		m.addaddress_level = &i
	}
}

// AddedAddressLevel returns the value that was added to the "address_level" field in this mutation.
func (m *AddressMutation) AddedAddressLevel() (r int, exists bool) {
	v := m.addaddress_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetAddressLevel resets all changes to the "address_level" field.
func (m *AddressMutation) ResetAddressLevel() {
	m.address_level = nil
	m.addaddress_level = nil
}

// SetAddressLevelName sets the "address_level_name" field.
func (m *AddressMutation) SetAddressLevelName(s string) {
	m.address_level_name = &s
}

// AddressLevelName returns the value of the "address_level_name" field in the mutation.
func (m *AddressMutation) AddressLevelName() (r string, exists bool) {
	v := m.address_level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLevelName returns the old "address_level_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLevelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLevelName: %w", err)
	}
	return oldValue.AddressLevelName, nil
}

// ResetAddressLevelName resets all changes to the "address_level_name" field.
func (m *AddressMutation) ResetAddressLevelName() {
	m.address_level_name = nil
}

// SetApplyToAllGroupMember sets the "apply_to_all_group_member" field.
func (m *AddressMutation) SetApplyToAllGroupMember(b bool) {
	m.apply_to_all_group_member = &b
}

// ApplyToAllGroupMember returns the value of the "apply_to_all_group_member" field in the mutation.
func (m *AddressMutation) ApplyToAllGroupMember() (r bool, exists bool) {
	v := m.apply_to_all_group_member
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyToAllGroupMember returns the old "apply_to_all_group_member" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldApplyToAllGroupMember(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyToAllGroupMember is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyToAllGroupMember requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyToAllGroupMember: %w", err)
	}
	return oldValue.ApplyToAllGroupMember, nil
}

// ResetApplyToAllGroupMember resets all changes to the "apply_to_all_group_member" field.
func (m *AddressMutation) ResetApplyToAllGroupMember() {
	m.apply_to_all_group_member = nil
}

// SetGroupAddressID sets the "group_address_id" field.
func (m *AddressMutation) SetGroupAddressID(i int) {
	m.group_address = &i
}

// GroupAddressID returns the value of the "group_address_id" field in the mutation.
func (m *AddressMutation) GroupAddressID() (r int, exists bool) {
	v := m.group_address
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupAddressID returns the old "group_address_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldGroupAddressID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupAddressID: %w", err)
	}
	return oldValue.GroupAddressID, nil
}

// ClearGroupAddressID clears the value of the "group_address_id" field.
func (m *AddressMutation) ClearGroupAddressID() {
	m.group_address = nil
	m.clearedFields[address.FieldGroupAddressID] = struct{}{}
}

// GroupAddressIDCleared returns if the "group_address_id" field was cleared in this mutation.
func (m *AddressMutation) GroupAddressIDCleared() bool {
	_, ok := m.clearedFields[address.FieldGroupAddressID]
	return ok
}

// ResetGroupAddressID resets all changes to the "group_address_id" field.
func (m *AddressMutation) ResetGroupAddressID() {
	m.group_address = nil
	delete(m.clearedFields, address.FieldGroupAddressID)
}

// SetIsGroupAddress sets the "is_group_address" field.
func (m *AddressMutation) SetIsGroupAddress(b bool) {
	m.is_group_address = &b
}

// IsGroupAddress returns the value of the "is_group_address" field in the mutation.
func (m *AddressMutation) IsGroupAddress() (r bool, exists bool) {
	v := m.is_group_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGroupAddress returns the old "is_group_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldIsGroupAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGroupAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGroupAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGroupAddress: %w", err)
	}
	return oldValue.IsGroupAddress, nil
}

// ResetIsGroupAddress resets all changes to the "is_group_address" field.
func (m *AddressMutation) ResetIsGroupAddress() {
	m.is_group_address = nil
}

// SetUseAsDefaultCreateAddress sets the "use_as_default_create_address" field.
func (m *AddressMutation) SetUseAsDefaultCreateAddress(b bool) {
	m.use_as_default_create_address = &b
}

// UseAsDefaultCreateAddress returns the value of the "use_as_default_create_address" field in the mutation.
func (m *AddressMutation) UseAsDefaultCreateAddress() (r bool, exists bool) {
	v := m.use_as_default_create_address
	if v == nil {
		return
	}
	return *v, true
}

// OldUseAsDefaultCreateAddress returns the old "use_as_default_create_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUseAsDefaultCreateAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseAsDefaultCreateAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseAsDefaultCreateAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseAsDefaultCreateAddress: %w", err)
	}
	return oldValue.UseAsDefaultCreateAddress, nil
}

// ResetUseAsDefaultCreateAddress resets all changes to the "use_as_default_create_address" field.
func (m *AddressMutation) ResetUseAsDefaultCreateAddress() {
	m.use_as_default_create_address = nil
}

// SetUseGroupAddress sets the "use_group_address" field.
func (m *AddressMutation) SetUseGroupAddress(b bool) {
	m.use_group_address = &b
}

// UseGroupAddress returns the value of the "use_group_address" field in the mutation.
func (m *AddressMutation) UseGroupAddress() (r bool, exists bool) {
	v := m.use_group_address
	if v == nil {
		return
	}
	return *v, true
}

// OldUseGroupAddress returns the old "use_group_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUseGroupAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseGroupAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseGroupAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseGroupAddress: %w", err)
	}
	return oldValue.UseGroupAddress, nil
}

// ResetUseGroupAddress resets all changes to the "use_group_address" field.
func (m *AddressMutation) ResetUseGroupAddress() {
	m.use_group_address = nil
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *AddressMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[address.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *AddressMutation) ClinicCleared() bool {
	return m.ClinicIDCleared() || m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *AddressMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AddressMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[address.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AddressMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AddressMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddCustomerClinicMappingIDs adds the "customer_clinic_mappings" edge to the CustomerAddressOnClinics entity by ids.
func (m *AddressMutation) AddCustomerClinicMappingIDs(ids ...int) {
	if m.customer_clinic_mappings == nil {
		m.customer_clinic_mappings = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_clinic_mappings[ids[i]] = struct{}{}
	}
}

// ClearCustomerClinicMappings clears the "customer_clinic_mappings" edge to the CustomerAddressOnClinics entity.
func (m *AddressMutation) ClearCustomerClinicMappings() {
	m.clearedcustomer_clinic_mappings = true
}

// CustomerClinicMappingsCleared reports if the "customer_clinic_mappings" edge to the CustomerAddressOnClinics entity was cleared.
func (m *AddressMutation) CustomerClinicMappingsCleared() bool {
	return m.clearedcustomer_clinic_mappings
}

// RemoveCustomerClinicMappingIDs removes the "customer_clinic_mappings" edge to the CustomerAddressOnClinics entity by IDs.
func (m *AddressMutation) RemoveCustomerClinicMappingIDs(ids ...int) {
	if m.removedcustomer_clinic_mappings == nil {
		m.removedcustomer_clinic_mappings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_clinic_mappings, ids[i])
		m.removedcustomer_clinic_mappings[ids[i]] = struct{}{}
	}
}

// RemovedCustomerClinicMappings returns the removed IDs of the "customer_clinic_mappings" edge to the CustomerAddressOnClinics entity.
func (m *AddressMutation) RemovedCustomerClinicMappingsIDs() (ids []int) {
	for id := range m.removedcustomer_clinic_mappings {
		ids = append(ids, id)
	}
	return
}

// CustomerClinicMappingsIDs returns the "customer_clinic_mappings" edge IDs in the mutation.
func (m *AddressMutation) CustomerClinicMappingsIDs() (ids []int) {
	for id := range m.customer_clinic_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerClinicMappings resets all changes to the "customer_clinic_mappings" edge.
func (m *AddressMutation) ResetCustomerClinicMappings() {
	m.customer_clinic_mappings = nil
	m.clearedcustomer_clinic_mappings = false
	m.removedcustomer_clinic_mappings = nil
}

// AddMemberAddressIDs adds the "member_addresses" edge to the Address entity by ids.
func (m *AddressMutation) AddMemberAddressIDs(ids ...int) {
	if m.member_addresses == nil {
		m.member_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.member_addresses[ids[i]] = struct{}{}
	}
}

// ClearMemberAddresses clears the "member_addresses" edge to the Address entity.
func (m *AddressMutation) ClearMemberAddresses() {
	m.clearedmember_addresses = true
}

// MemberAddressesCleared reports if the "member_addresses" edge to the Address entity was cleared.
func (m *AddressMutation) MemberAddressesCleared() bool {
	return m.clearedmember_addresses
}

// RemoveMemberAddressIDs removes the "member_addresses" edge to the Address entity by IDs.
func (m *AddressMutation) RemoveMemberAddressIDs(ids ...int) {
	if m.removedmember_addresses == nil {
		m.removedmember_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.member_addresses, ids[i])
		m.removedmember_addresses[ids[i]] = struct{}{}
	}
}

// RemovedMemberAddresses returns the removed IDs of the "member_addresses" edge to the Address entity.
func (m *AddressMutation) RemovedMemberAddressesIDs() (ids []int) {
	for id := range m.removedmember_addresses {
		ids = append(ids, id)
	}
	return
}

// MemberAddressesIDs returns the "member_addresses" edge IDs in the mutation.
func (m *AddressMutation) MemberAddressesIDs() (ids []int) {
	for id := range m.member_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetMemberAddresses resets all changes to the "member_addresses" edge.
func (m *AddressMutation) ResetMemberAddresses() {
	m.member_addresses = nil
	m.clearedmember_addresses = false
	m.removedmember_addresses = nil
}

// ClearGroupAddress clears the "group_address" edge to the Address entity.
func (m *AddressMutation) ClearGroupAddress() {
	m.clearedgroup_address = true
	m.clearedFields[address.FieldGroupAddressID] = struct{}{}
}

// GroupAddressCleared reports if the "group_address" edge to the Address entity was cleared.
func (m *AddressMutation) GroupAddressCleared() bool {
	return m.GroupAddressIDCleared() || m.clearedgroup_address
}

// GroupAddressIDs returns the "group_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupAddressID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) GroupAddressIDs() (ids []int) {
	if id := m.group_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupAddress resets all changes to the "group_address" edge.
func (m *AddressMutation) ResetGroupAddress() {
	m.group_address = nil
	m.clearedgroup_address = false
}

// ClearInternalUser clears the "internal_user" edge to the InternalUser entity.
func (m *AddressMutation) ClearInternalUser() {
	m.clearedinternal_user = true
	m.clearedFields[address.FieldInternalUserID] = struct{}{}
}

// InternalUserCleared reports if the "internal_user" edge to the InternalUser entity was cleared.
func (m *AddressMutation) InternalUserCleared() bool {
	return m.InternalUserIDCleared() || m.clearedinternal_user
}

// InternalUserIDs returns the "internal_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InternalUserID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) InternalUserIDs() (ids []int) {
	if id := m.internal_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInternalUser resets all changes to the "internal_user" edge.
func (m *AddressMutation) ResetInternalUser() {
	m.internal_user = nil
	m.clearedinternal_user = false
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *AddressMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[address.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *AddressMutation) PatientCleared() bool {
	return m.PatientIDCleared() || m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *AddressMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// AddOrderIDs adds the "orders" edge to the OrderInfo entity by ids.
func (m *AddressMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the OrderInfo entity.
func (m *AddressMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the OrderInfo entity was cleared.
func (m *AddressMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the OrderInfo entity by IDs.
func (m *AddressMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the OrderInfo entity.
func (m *AddressMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AddressMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AddressMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.address_type != nil {
		fields = append(fields, address.FieldAddressType)
	}
	if m.street_address != nil {
		fields = append(fields, address.FieldStreetAddress)
	}
	if m.apt_po != nil {
		fields = append(fields, address.FieldAptPo)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, address.FieldState)
	}
	if m.zipcode != nil {
		fields = append(fields, address.FieldZipcode)
	}
	if m.country != nil {
		fields = append(fields, address.FieldCountry)
	}
	if m.address_confirmed != nil {
		fields = append(fields, address.FieldAddressConfirmed)
	}
	if m.is_primary_address != nil {
		fields = append(fields, address.FieldIsPrimaryAddress)
	}
	if m.customer != nil {
		fields = append(fields, address.FieldCustomerID)
	}
	if m.patient != nil {
		fields = append(fields, address.FieldPatientID)
	}
	if m.clinic != nil {
		fields = append(fields, address.FieldClinicID)
	}
	if m.internal_user != nil {
		fields = append(fields, address.FieldInternalUserID)
	}
	if m.address_level != nil {
		fields = append(fields, address.FieldAddressLevel)
	}
	if m.address_level_name != nil {
		fields = append(fields, address.FieldAddressLevelName)
	}
	if m.apply_to_all_group_member != nil {
		fields = append(fields, address.FieldApplyToAllGroupMember)
	}
	if m.group_address != nil {
		fields = append(fields, address.FieldGroupAddressID)
	}
	if m.is_group_address != nil {
		fields = append(fields, address.FieldIsGroupAddress)
	}
	if m.use_as_default_create_address != nil {
		fields = append(fields, address.FieldUseAsDefaultCreateAddress)
	}
	if m.use_group_address != nil {
		fields = append(fields, address.FieldUseGroupAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldAddressType:
		return m.AddressType()
	case address.FieldStreetAddress:
		return m.StreetAddress()
	case address.FieldAptPo:
		return m.AptPo()
	case address.FieldCity:
		return m.City()
	case address.FieldState:
		return m.State()
	case address.FieldZipcode:
		return m.Zipcode()
	case address.FieldCountry:
		return m.Country()
	case address.FieldAddressConfirmed:
		return m.AddressConfirmed()
	case address.FieldIsPrimaryAddress:
		return m.IsPrimaryAddress()
	case address.FieldCustomerID:
		return m.CustomerID()
	case address.FieldPatientID:
		return m.PatientID()
	case address.FieldClinicID:
		return m.ClinicID()
	case address.FieldInternalUserID:
		return m.InternalUserID()
	case address.FieldAddressLevel:
		return m.AddressLevel()
	case address.FieldAddressLevelName:
		return m.AddressLevelName()
	case address.FieldApplyToAllGroupMember:
		return m.ApplyToAllGroupMember()
	case address.FieldGroupAddressID:
		return m.GroupAddressID()
	case address.FieldIsGroupAddress:
		return m.IsGroupAddress()
	case address.FieldUseAsDefaultCreateAddress:
		return m.UseAsDefaultCreateAddress()
	case address.FieldUseGroupAddress:
		return m.UseGroupAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldAddressType:
		return m.OldAddressType(ctx)
	case address.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case address.FieldAptPo:
		return m.OldAptPo(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldZipcode:
		return m.OldZipcode(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	case address.FieldAddressConfirmed:
		return m.OldAddressConfirmed(ctx)
	case address.FieldIsPrimaryAddress:
		return m.OldIsPrimaryAddress(ctx)
	case address.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case address.FieldPatientID:
		return m.OldPatientID(ctx)
	case address.FieldClinicID:
		return m.OldClinicID(ctx)
	case address.FieldInternalUserID:
		return m.OldInternalUserID(ctx)
	case address.FieldAddressLevel:
		return m.OldAddressLevel(ctx)
	case address.FieldAddressLevelName:
		return m.OldAddressLevelName(ctx)
	case address.FieldApplyToAllGroupMember:
		return m.OldApplyToAllGroupMember(ctx)
	case address.FieldGroupAddressID:
		return m.OldGroupAddressID(ctx)
	case address.FieldIsGroupAddress:
		return m.OldIsGroupAddress(ctx)
	case address.FieldUseAsDefaultCreateAddress:
		return m.OldUseAsDefaultCreateAddress(ctx)
	case address.FieldUseGroupAddress:
		return m.OldUseGroupAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldAddressType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressType(v)
		return nil
	case address.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case address.FieldAptPo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptPo(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldZipcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipcode(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case address.FieldAddressConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressConfirmed(v)
		return nil
	case address.FieldIsPrimaryAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimaryAddress(v)
		return nil
	case address.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case address.FieldPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case address.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case address.FieldInternalUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserID(v)
		return nil
	case address.FieldAddressLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLevel(v)
		return nil
	case address.FieldAddressLevelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLevelName(v)
		return nil
	case address.FieldApplyToAllGroupMember:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyToAllGroupMember(v)
		return nil
	case address.FieldGroupAddressID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupAddressID(v)
		return nil
	case address.FieldIsGroupAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGroupAddress(v)
		return nil
	case address.FieldUseAsDefaultCreateAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseAsDefaultCreateAddress(v)
		return nil
	case address.FieldUseGroupAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseGroupAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	var fields []string
	if m.addaddress_level != nil {
		fields = append(fields, address.FieldAddressLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case address.FieldAddressLevel:
		return m.AddedAddressLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case address.FieldAddressLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddressLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldAddressType) {
		fields = append(fields, address.FieldAddressType)
	}
	if m.FieldCleared(address.FieldStreetAddress) {
		fields = append(fields, address.FieldStreetAddress)
	}
	if m.FieldCleared(address.FieldAptPo) {
		fields = append(fields, address.FieldAptPo)
	}
	if m.FieldCleared(address.FieldCity) {
		fields = append(fields, address.FieldCity)
	}
	if m.FieldCleared(address.FieldState) {
		fields = append(fields, address.FieldState)
	}
	if m.FieldCleared(address.FieldZipcode) {
		fields = append(fields, address.FieldZipcode)
	}
	if m.FieldCleared(address.FieldCountry) {
		fields = append(fields, address.FieldCountry)
	}
	if m.FieldCleared(address.FieldCustomerID) {
		fields = append(fields, address.FieldCustomerID)
	}
	if m.FieldCleared(address.FieldPatientID) {
		fields = append(fields, address.FieldPatientID)
	}
	if m.FieldCleared(address.FieldClinicID) {
		fields = append(fields, address.FieldClinicID)
	}
	if m.FieldCleared(address.FieldInternalUserID) {
		fields = append(fields, address.FieldInternalUserID)
	}
	if m.FieldCleared(address.FieldGroupAddressID) {
		fields = append(fields, address.FieldGroupAddressID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldAddressType:
		m.ClearAddressType()
		return nil
	case address.FieldStreetAddress:
		m.ClearStreetAddress()
		return nil
	case address.FieldAptPo:
		m.ClearAptPo()
		return nil
	case address.FieldCity:
		m.ClearCity()
		return nil
	case address.FieldState:
		m.ClearState()
		return nil
	case address.FieldZipcode:
		m.ClearZipcode()
		return nil
	case address.FieldCountry:
		m.ClearCountry()
		return nil
	case address.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case address.FieldPatientID:
		m.ClearPatientID()
		return nil
	case address.FieldClinicID:
		m.ClearClinicID()
		return nil
	case address.FieldInternalUserID:
		m.ClearInternalUserID()
		return nil
	case address.FieldGroupAddressID:
		m.ClearGroupAddressID()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldAddressType:
		m.ResetAddressType()
		return nil
	case address.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case address.FieldAptPo:
		m.ResetAptPo()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldZipcode:
		m.ResetZipcode()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	case address.FieldAddressConfirmed:
		m.ResetAddressConfirmed()
		return nil
	case address.FieldIsPrimaryAddress:
		m.ResetIsPrimaryAddress()
		return nil
	case address.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case address.FieldPatientID:
		m.ResetPatientID()
		return nil
	case address.FieldClinicID:
		m.ResetClinicID()
		return nil
	case address.FieldInternalUserID:
		m.ResetInternalUserID()
		return nil
	case address.FieldAddressLevel:
		m.ResetAddressLevel()
		return nil
	case address.FieldAddressLevelName:
		m.ResetAddressLevelName()
		return nil
	case address.FieldApplyToAllGroupMember:
		m.ResetApplyToAllGroupMember()
		return nil
	case address.FieldGroupAddressID:
		m.ResetGroupAddressID()
		return nil
	case address.FieldIsGroupAddress:
		m.ResetIsGroupAddress()
		return nil
	case address.FieldUseAsDefaultCreateAddress:
		m.ResetUseAsDefaultCreateAddress()
		return nil
	case address.FieldUseGroupAddress:
		m.ResetUseGroupAddress()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clinic != nil {
		edges = append(edges, address.EdgeClinic)
	}
	if m.customer != nil {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.customer_clinic_mappings != nil {
		edges = append(edges, address.EdgeCustomerClinicMappings)
	}
	if m.member_addresses != nil {
		edges = append(edges, address.EdgeMemberAddresses)
	}
	if m.group_address != nil {
		edges = append(edges, address.EdgeGroupAddress)
	}
	if m.internal_user != nil {
		edges = append(edges, address.EdgeInternalUser)
	}
	if m.patient != nil {
		edges = append(edges, address.EdgePatient)
	}
	if m.orders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeCustomerClinicMappings:
		ids := make([]ent.Value, 0, len(m.customer_clinic_mappings))
		for id := range m.customer_clinic_mappings {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeMemberAddresses:
		ids := make([]ent.Value, 0, len(m.member_addresses))
		for id := range m.member_addresses {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeGroupAddress:
		if id := m.group_address; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeInternalUser:
		if id := m.internal_user; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcustomer_clinic_mappings != nil {
		edges = append(edges, address.EdgeCustomerClinicMappings)
	}
	if m.removedmember_addresses != nil {
		edges = append(edges, address.EdgeMemberAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeCustomerClinicMappings:
		ids := make([]ent.Value, 0, len(m.removedcustomer_clinic_mappings))
		for id := range m.removedcustomer_clinic_mappings {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeMemberAddresses:
		ids := make([]ent.Value, 0, len(m.removedmember_addresses))
		for id := range m.removedmember_addresses {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedclinic {
		edges = append(edges, address.EdgeClinic)
	}
	if m.clearedcustomer {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.clearedcustomer_clinic_mappings {
		edges = append(edges, address.EdgeCustomerClinicMappings)
	}
	if m.clearedmember_addresses {
		edges = append(edges, address.EdgeMemberAddresses)
	}
	if m.clearedgroup_address {
		edges = append(edges, address.EdgeGroupAddress)
	}
	if m.clearedinternal_user {
		edges = append(edges, address.EdgeInternalUser)
	}
	if m.clearedpatient {
		edges = append(edges, address.EdgePatient)
	}
	if m.clearedorders {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeClinic:
		return m.clearedclinic
	case address.EdgeCustomer:
		return m.clearedcustomer
	case address.EdgeCustomerClinicMappings:
		return m.clearedcustomer_clinic_mappings
	case address.EdgeMemberAddresses:
		return m.clearedmember_addresses
	case address.EdgeGroupAddress:
		return m.clearedgroup_address
	case address.EdgeInternalUser:
		return m.clearedinternal_user
	case address.EdgePatient:
		return m.clearedpatient
	case address.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeClinic:
		m.ClearClinic()
		return nil
	case address.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case address.EdgeGroupAddress:
		m.ClearGroupAddress()
		return nil
	case address.EdgeInternalUser:
		m.ClearInternalUser()
		return nil
	case address.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeClinic:
		m.ResetClinic()
		return nil
	case address.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case address.EdgeCustomerClinicMappings:
		m.ResetCustomerClinicMappings()
		return nil
	case address.EdgeMemberAddresses:
		m.ResetMemberAddresses()
		return nil
	case address.EdgeGroupAddress:
		m.ResetGroupAddress()
		return nil
	case address.EdgeInternalUser:
		m.ResetInternalUser()
		return nil
	case address.EdgePatient:
		m.ResetPatient()
		return nil
	case address.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// BetaProgramMutation represents an operation that mutates the BetaProgram nodes in the graph.
type BetaProgramMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	beta_program_name        *string
	beta_program_description *string
	is_active                *bool
	beta_program_start_time  *time.Time
	beta_program_end_time    *time.Time
	updated_time             *time.Time
	beta_program_added_on    *time.Time
	allow_self_signup        *bool
	clearedFields            map[string]struct{}
	participations           map[int]struct{}
	removedparticipations    map[int]struct{}
	clearedparticipations    bool
	done                     bool
	oldValue                 func(context.Context) (*BetaProgram, error)
	predicates               []predicate.BetaProgram
}

var _ ent.Mutation = (*BetaProgramMutation)(nil)

// betaprogramOption allows management of the mutation configuration using functional options.
type betaprogramOption func(*BetaProgramMutation)

// newBetaProgramMutation creates new mutation for the BetaProgram entity.
func newBetaProgramMutation(c config, op Op, opts ...betaprogramOption) *BetaProgramMutation {
	m := &BetaProgramMutation{
		config:        c,
		op:            op,
		typ:           TypeBetaProgram,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBetaProgramID sets the ID field of the mutation.
func withBetaProgramID(id int) betaprogramOption {
	return func(m *BetaProgramMutation) {
		var (
			err   error
			once  sync.Once
			value *BetaProgram
		)
		m.oldValue = func(ctx context.Context) (*BetaProgram, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BetaProgram.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBetaProgram sets the old BetaProgram of the mutation.
func withBetaProgram(node *BetaProgram) betaprogramOption {
	return func(m *BetaProgramMutation) {
		m.oldValue = func(context.Context) (*BetaProgram, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BetaProgramMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BetaProgramMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BetaProgram entities.
func (m *BetaProgramMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BetaProgramMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BetaProgramMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BetaProgram.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBetaProgramName sets the "beta_program_name" field.
func (m *BetaProgramMutation) SetBetaProgramName(s string) {
	m.beta_program_name = &s
}

// BetaProgramName returns the value of the "beta_program_name" field in the mutation.
func (m *BetaProgramMutation) BetaProgramName() (r string, exists bool) {
	v := m.beta_program_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramName returns the old "beta_program_name" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldBetaProgramName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramName: %w", err)
	}
	return oldValue.BetaProgramName, nil
}

// ResetBetaProgramName resets all changes to the "beta_program_name" field.
func (m *BetaProgramMutation) ResetBetaProgramName() {
	m.beta_program_name = nil
}

// SetBetaProgramDescription sets the "beta_program_description" field.
func (m *BetaProgramMutation) SetBetaProgramDescription(s string) {
	m.beta_program_description = &s
}

// BetaProgramDescription returns the value of the "beta_program_description" field in the mutation.
func (m *BetaProgramMutation) BetaProgramDescription() (r string, exists bool) {
	v := m.beta_program_description
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramDescription returns the old "beta_program_description" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldBetaProgramDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramDescription: %w", err)
	}
	return oldValue.BetaProgramDescription, nil
}

// ResetBetaProgramDescription resets all changes to the "beta_program_description" field.
func (m *BetaProgramMutation) ResetBetaProgramDescription() {
	m.beta_program_description = nil
}

// SetIsActive sets the "is_active" field.
func (m *BetaProgramMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *BetaProgramMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *BetaProgramMutation) ResetIsActive() {
	m.is_active = nil
}

// SetBetaProgramStartTime sets the "beta_program_start_time" field.
func (m *BetaProgramMutation) SetBetaProgramStartTime(t time.Time) {
	m.beta_program_start_time = &t
}

// BetaProgramStartTime returns the value of the "beta_program_start_time" field in the mutation.
func (m *BetaProgramMutation) BetaProgramStartTime() (r time.Time, exists bool) {
	v := m.beta_program_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramStartTime returns the old "beta_program_start_time" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldBetaProgramStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramStartTime: %w", err)
	}
	return oldValue.BetaProgramStartTime, nil
}

// ResetBetaProgramStartTime resets all changes to the "beta_program_start_time" field.
func (m *BetaProgramMutation) ResetBetaProgramStartTime() {
	m.beta_program_start_time = nil
}

// SetBetaProgramEndTime sets the "beta_program_end_time" field.
func (m *BetaProgramMutation) SetBetaProgramEndTime(t time.Time) {
	m.beta_program_end_time = &t
}

// BetaProgramEndTime returns the value of the "beta_program_end_time" field in the mutation.
func (m *BetaProgramMutation) BetaProgramEndTime() (r time.Time, exists bool) {
	v := m.beta_program_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramEndTime returns the old "beta_program_end_time" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldBetaProgramEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramEndTime: %w", err)
	}
	return oldValue.BetaProgramEndTime, nil
}

// ClearBetaProgramEndTime clears the value of the "beta_program_end_time" field.
func (m *BetaProgramMutation) ClearBetaProgramEndTime() {
	m.beta_program_end_time = nil
	m.clearedFields[betaprogram.FieldBetaProgramEndTime] = struct{}{}
}

// BetaProgramEndTimeCleared returns if the "beta_program_end_time" field was cleared in this mutation.
func (m *BetaProgramMutation) BetaProgramEndTimeCleared() bool {
	_, ok := m.clearedFields[betaprogram.FieldBetaProgramEndTime]
	return ok
}

// ResetBetaProgramEndTime resets all changes to the "beta_program_end_time" field.
func (m *BetaProgramMutation) ResetBetaProgramEndTime() {
	m.beta_program_end_time = nil
	delete(m.clearedFields, betaprogram.FieldBetaProgramEndTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *BetaProgramMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *BetaProgramMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *BetaProgramMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetBetaProgramAddedOn sets the "beta_program_added_on" field.
func (m *BetaProgramMutation) SetBetaProgramAddedOn(t time.Time) {
	m.beta_program_added_on = &t
}

// BetaProgramAddedOn returns the value of the "beta_program_added_on" field in the mutation.
func (m *BetaProgramMutation) BetaProgramAddedOn() (r time.Time, exists bool) {
	v := m.beta_program_added_on
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramAddedOn returns the old "beta_program_added_on" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldBetaProgramAddedOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramAddedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramAddedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramAddedOn: %w", err)
	}
	return oldValue.BetaProgramAddedOn, nil
}

// ClearBetaProgramAddedOn clears the value of the "beta_program_added_on" field.
func (m *BetaProgramMutation) ClearBetaProgramAddedOn() {
	m.beta_program_added_on = nil
	m.clearedFields[betaprogram.FieldBetaProgramAddedOn] = struct{}{}
}

// BetaProgramAddedOnCleared returns if the "beta_program_added_on" field was cleared in this mutation.
func (m *BetaProgramMutation) BetaProgramAddedOnCleared() bool {
	_, ok := m.clearedFields[betaprogram.FieldBetaProgramAddedOn]
	return ok
}

// ResetBetaProgramAddedOn resets all changes to the "beta_program_added_on" field.
func (m *BetaProgramMutation) ResetBetaProgramAddedOn() {
	m.beta_program_added_on = nil
	delete(m.clearedFields, betaprogram.FieldBetaProgramAddedOn)
}

// SetAllowSelfSignup sets the "allow_self_signup" field.
func (m *BetaProgramMutation) SetAllowSelfSignup(b bool) {
	m.allow_self_signup = &b
}

// AllowSelfSignup returns the value of the "allow_self_signup" field in the mutation.
func (m *BetaProgramMutation) AllowSelfSignup() (r bool, exists bool) {
	v := m.allow_self_signup
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowSelfSignup returns the old "allow_self_signup" field's value of the BetaProgram entity.
// If the BetaProgram object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramMutation) OldAllowSelfSignup(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowSelfSignup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowSelfSignup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowSelfSignup: %w", err)
	}
	return oldValue.AllowSelfSignup, nil
}

// ClearAllowSelfSignup clears the value of the "allow_self_signup" field.
func (m *BetaProgramMutation) ClearAllowSelfSignup() {
	m.allow_self_signup = nil
	m.clearedFields[betaprogram.FieldAllowSelfSignup] = struct{}{}
}

// AllowSelfSignupCleared returns if the "allow_self_signup" field was cleared in this mutation.
func (m *BetaProgramMutation) AllowSelfSignupCleared() bool {
	_, ok := m.clearedFields[betaprogram.FieldAllowSelfSignup]
	return ok
}

// ResetAllowSelfSignup resets all changes to the "allow_self_signup" field.
func (m *BetaProgramMutation) ResetAllowSelfSignup() {
	m.allow_self_signup = nil
	delete(m.clearedFields, betaprogram.FieldAllowSelfSignup)
}

// AddParticipationIDs adds the "participations" edge to the BetaProgramParticipation entity by ids.
func (m *BetaProgramMutation) AddParticipationIDs(ids ...int) {
	if m.participations == nil {
		m.participations = make(map[int]struct{})
	}
	for i := range ids {
		m.participations[ids[i]] = struct{}{}
	}
}

// ClearParticipations clears the "participations" edge to the BetaProgramParticipation entity.
func (m *BetaProgramMutation) ClearParticipations() {
	m.clearedparticipations = true
}

// ParticipationsCleared reports if the "participations" edge to the BetaProgramParticipation entity was cleared.
func (m *BetaProgramMutation) ParticipationsCleared() bool {
	return m.clearedparticipations
}

// RemoveParticipationIDs removes the "participations" edge to the BetaProgramParticipation entity by IDs.
func (m *BetaProgramMutation) RemoveParticipationIDs(ids ...int) {
	if m.removedparticipations == nil {
		m.removedparticipations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participations, ids[i])
		m.removedparticipations[ids[i]] = struct{}{}
	}
}

// RemovedParticipations returns the removed IDs of the "participations" edge to the BetaProgramParticipation entity.
func (m *BetaProgramMutation) RemovedParticipationsIDs() (ids []int) {
	for id := range m.removedparticipations {
		ids = append(ids, id)
	}
	return
}

// ParticipationsIDs returns the "participations" edge IDs in the mutation.
func (m *BetaProgramMutation) ParticipationsIDs() (ids []int) {
	for id := range m.participations {
		ids = append(ids, id)
	}
	return
}

// ResetParticipations resets all changes to the "participations" edge.
func (m *BetaProgramMutation) ResetParticipations() {
	m.participations = nil
	m.clearedparticipations = false
	m.removedparticipations = nil
}

// Where appends a list predicates to the BetaProgramMutation builder.
func (m *BetaProgramMutation) Where(ps ...predicate.BetaProgram) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BetaProgramMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BetaProgramMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BetaProgram, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BetaProgramMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BetaProgramMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BetaProgram).
func (m *BetaProgramMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BetaProgramMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.beta_program_name != nil {
		fields = append(fields, betaprogram.FieldBetaProgramName)
	}
	if m.beta_program_description != nil {
		fields = append(fields, betaprogram.FieldBetaProgramDescription)
	}
	if m.is_active != nil {
		fields = append(fields, betaprogram.FieldIsActive)
	}
	if m.beta_program_start_time != nil {
		fields = append(fields, betaprogram.FieldBetaProgramStartTime)
	}
	if m.beta_program_end_time != nil {
		fields = append(fields, betaprogram.FieldBetaProgramEndTime)
	}
	if m.updated_time != nil {
		fields = append(fields, betaprogram.FieldUpdatedTime)
	}
	if m.beta_program_added_on != nil {
		fields = append(fields, betaprogram.FieldBetaProgramAddedOn)
	}
	if m.allow_self_signup != nil {
		fields = append(fields, betaprogram.FieldAllowSelfSignup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BetaProgramMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case betaprogram.FieldBetaProgramName:
		return m.BetaProgramName()
	case betaprogram.FieldBetaProgramDescription:
		return m.BetaProgramDescription()
	case betaprogram.FieldIsActive:
		return m.IsActive()
	case betaprogram.FieldBetaProgramStartTime:
		return m.BetaProgramStartTime()
	case betaprogram.FieldBetaProgramEndTime:
		return m.BetaProgramEndTime()
	case betaprogram.FieldUpdatedTime:
		return m.UpdatedTime()
	case betaprogram.FieldBetaProgramAddedOn:
		return m.BetaProgramAddedOn()
	case betaprogram.FieldAllowSelfSignup:
		return m.AllowSelfSignup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BetaProgramMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case betaprogram.FieldBetaProgramName:
		return m.OldBetaProgramName(ctx)
	case betaprogram.FieldBetaProgramDescription:
		return m.OldBetaProgramDescription(ctx)
	case betaprogram.FieldIsActive:
		return m.OldIsActive(ctx)
	case betaprogram.FieldBetaProgramStartTime:
		return m.OldBetaProgramStartTime(ctx)
	case betaprogram.FieldBetaProgramEndTime:
		return m.OldBetaProgramEndTime(ctx)
	case betaprogram.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case betaprogram.FieldBetaProgramAddedOn:
		return m.OldBetaProgramAddedOn(ctx)
	case betaprogram.FieldAllowSelfSignup:
		return m.OldAllowSelfSignup(ctx)
	}
	return nil, fmt.Errorf("unknown BetaProgram field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetaProgramMutation) SetField(name string, value ent.Value) error {
	switch name {
	case betaprogram.FieldBetaProgramName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramName(v)
		return nil
	case betaprogram.FieldBetaProgramDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramDescription(v)
		return nil
	case betaprogram.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case betaprogram.FieldBetaProgramStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramStartTime(v)
		return nil
	case betaprogram.FieldBetaProgramEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramEndTime(v)
		return nil
	case betaprogram.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case betaprogram.FieldBetaProgramAddedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramAddedOn(v)
		return nil
	case betaprogram.FieldAllowSelfSignup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowSelfSignup(v)
		return nil
	}
	return fmt.Errorf("unknown BetaProgram field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BetaProgramMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BetaProgramMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetaProgramMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BetaProgram numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BetaProgramMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(betaprogram.FieldBetaProgramEndTime) {
		fields = append(fields, betaprogram.FieldBetaProgramEndTime)
	}
	if m.FieldCleared(betaprogram.FieldBetaProgramAddedOn) {
		fields = append(fields, betaprogram.FieldBetaProgramAddedOn)
	}
	if m.FieldCleared(betaprogram.FieldAllowSelfSignup) {
		fields = append(fields, betaprogram.FieldAllowSelfSignup)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BetaProgramMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BetaProgramMutation) ClearField(name string) error {
	switch name {
	case betaprogram.FieldBetaProgramEndTime:
		m.ClearBetaProgramEndTime()
		return nil
	case betaprogram.FieldBetaProgramAddedOn:
		m.ClearBetaProgramAddedOn()
		return nil
	case betaprogram.FieldAllowSelfSignup:
		m.ClearAllowSelfSignup()
		return nil
	}
	return fmt.Errorf("unknown BetaProgram nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BetaProgramMutation) ResetField(name string) error {
	switch name {
	case betaprogram.FieldBetaProgramName:
		m.ResetBetaProgramName()
		return nil
	case betaprogram.FieldBetaProgramDescription:
		m.ResetBetaProgramDescription()
		return nil
	case betaprogram.FieldIsActive:
		m.ResetIsActive()
		return nil
	case betaprogram.FieldBetaProgramStartTime:
		m.ResetBetaProgramStartTime()
		return nil
	case betaprogram.FieldBetaProgramEndTime:
		m.ResetBetaProgramEndTime()
		return nil
	case betaprogram.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case betaprogram.FieldBetaProgramAddedOn:
		m.ResetBetaProgramAddedOn()
		return nil
	case betaprogram.FieldAllowSelfSignup:
		m.ResetAllowSelfSignup()
		return nil
	}
	return fmt.Errorf("unknown BetaProgram field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BetaProgramMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.participations != nil {
		edges = append(edges, betaprogram.EdgeParticipations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BetaProgramMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case betaprogram.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.participations))
		for id := range m.participations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BetaProgramMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedparticipations != nil {
		edges = append(edges, betaprogram.EdgeParticipations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BetaProgramMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case betaprogram.EdgeParticipations:
		ids := make([]ent.Value, 0, len(m.removedparticipations))
		for id := range m.removedparticipations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BetaProgramMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparticipations {
		edges = append(edges, betaprogram.EdgeParticipations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BetaProgramMutation) EdgeCleared(name string) bool {
	switch name {
	case betaprogram.EdgeParticipations:
		return m.clearedparticipations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BetaProgramMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BetaProgram unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BetaProgramMutation) ResetEdge(name string) error {
	switch name {
	case betaprogram.EdgeParticipations:
		m.ResetParticipations()
		return nil
	}
	return fmt.Errorf("unknown BetaProgram edge %s", name)
}

// BetaProgramParticipationMutation represents an operation that mutates the BetaProgramParticipation nodes in the graph.
type BetaProgramParticipationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	is_active               *bool
	has_modified_start_time *bool
	modified_start_time     *time.Time
	modified_end_time       *time.Time
	clearedFields           map[string]struct{}
	beta_program            *int
	clearedbeta_program     bool
	customer                *int
	clearedcustomer         bool
	clinic                  *int
	clearedclinic           bool
	done                    bool
	oldValue                func(context.Context) (*BetaProgramParticipation, error)
	predicates              []predicate.BetaProgramParticipation
}

var _ ent.Mutation = (*BetaProgramParticipationMutation)(nil)

// betaprogramparticipationOption allows management of the mutation configuration using functional options.
type betaprogramparticipationOption func(*BetaProgramParticipationMutation)

// newBetaProgramParticipationMutation creates new mutation for the BetaProgramParticipation entity.
func newBetaProgramParticipationMutation(c config, op Op, opts ...betaprogramparticipationOption) *BetaProgramParticipationMutation {
	m := &BetaProgramParticipationMutation{
		config:        c,
		op:            op,
		typ:           TypeBetaProgramParticipation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBetaProgramParticipationID sets the ID field of the mutation.
func withBetaProgramParticipationID(id int) betaprogramparticipationOption {
	return func(m *BetaProgramParticipationMutation) {
		var (
			err   error
			once  sync.Once
			value *BetaProgramParticipation
		)
		m.oldValue = func(ctx context.Context) (*BetaProgramParticipation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BetaProgramParticipation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBetaProgramParticipation sets the old BetaProgramParticipation of the mutation.
func withBetaProgramParticipation(node *BetaProgramParticipation) betaprogramparticipationOption {
	return func(m *BetaProgramParticipationMutation) {
		m.oldValue = func(context.Context) (*BetaProgramParticipation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BetaProgramParticipationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BetaProgramParticipationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BetaProgramParticipation entities.
func (m *BetaProgramParticipationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BetaProgramParticipationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BetaProgramParticipationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BetaProgramParticipation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBetaProgramID sets the "beta_program_id" field.
func (m *BetaProgramParticipationMutation) SetBetaProgramID(i int) {
	m.beta_program = &i
}

// BetaProgramID returns the value of the "beta_program_id" field in the mutation.
func (m *BetaProgramParticipationMutation) BetaProgramID() (r int, exists bool) {
	v := m.beta_program
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramID returns the old "beta_program_id" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldBetaProgramID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramID: %w", err)
	}
	return oldValue.BetaProgramID, nil
}

// ResetBetaProgramID resets all changes to the "beta_program_id" field.
func (m *BetaProgramParticipationMutation) ResetBetaProgramID() {
	m.beta_program = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *BetaProgramParticipationMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BetaProgramParticipationMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BetaProgramParticipationMutation) ResetCustomerID() {
	m.customer = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *BetaProgramParticipationMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *BetaProgramParticipationMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *BetaProgramParticipationMutation) ResetClinicID() {
	m.clinic = nil
}

// SetIsActive sets the "is_active" field.
func (m *BetaProgramParticipationMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *BetaProgramParticipationMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *BetaProgramParticipationMutation) ResetIsActive() {
	m.is_active = nil
}

// SetHasModifiedStartTime sets the "has_modified_start_time" field.
func (m *BetaProgramParticipationMutation) SetHasModifiedStartTime(b bool) {
	m.has_modified_start_time = &b
}

// HasModifiedStartTime returns the value of the "has_modified_start_time" field in the mutation.
func (m *BetaProgramParticipationMutation) HasModifiedStartTime() (r bool, exists bool) {
	v := m.has_modified_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHasModifiedStartTime returns the old "has_modified_start_time" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldHasModifiedStartTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasModifiedStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasModifiedStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasModifiedStartTime: %w", err)
	}
	return oldValue.HasModifiedStartTime, nil
}

// ResetHasModifiedStartTime resets all changes to the "has_modified_start_time" field.
func (m *BetaProgramParticipationMutation) ResetHasModifiedStartTime() {
	m.has_modified_start_time = nil
}

// SetModifiedStartTime sets the "modified_start_time" field.
func (m *BetaProgramParticipationMutation) SetModifiedStartTime(t time.Time) {
	m.modified_start_time = &t
}

// ModifiedStartTime returns the value of the "modified_start_time" field in the mutation.
func (m *BetaProgramParticipationMutation) ModifiedStartTime() (r time.Time, exists bool) {
	v := m.modified_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedStartTime returns the old "modified_start_time" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldModifiedStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedStartTime: %w", err)
	}
	return oldValue.ModifiedStartTime, nil
}

// ClearModifiedStartTime clears the value of the "modified_start_time" field.
func (m *BetaProgramParticipationMutation) ClearModifiedStartTime() {
	m.modified_start_time = nil
	m.clearedFields[betaprogramparticipation.FieldModifiedStartTime] = struct{}{}
}

// ModifiedStartTimeCleared returns if the "modified_start_time" field was cleared in this mutation.
func (m *BetaProgramParticipationMutation) ModifiedStartTimeCleared() bool {
	_, ok := m.clearedFields[betaprogramparticipation.FieldModifiedStartTime]
	return ok
}

// ResetModifiedStartTime resets all changes to the "modified_start_time" field.
func (m *BetaProgramParticipationMutation) ResetModifiedStartTime() {
	m.modified_start_time = nil
	delete(m.clearedFields, betaprogramparticipation.FieldModifiedStartTime)
}

// SetModifiedEndTime sets the "modified_end_time" field.
func (m *BetaProgramParticipationMutation) SetModifiedEndTime(t time.Time) {
	m.modified_end_time = &t
}

// ModifiedEndTime returns the value of the "modified_end_time" field in the mutation.
func (m *BetaProgramParticipationMutation) ModifiedEndTime() (r time.Time, exists bool) {
	v := m.modified_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedEndTime returns the old "modified_end_time" field's value of the BetaProgramParticipation entity.
// If the BetaProgramParticipation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetaProgramParticipationMutation) OldModifiedEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedEndTime: %w", err)
	}
	return oldValue.ModifiedEndTime, nil
}

// ClearModifiedEndTime clears the value of the "modified_end_time" field.
func (m *BetaProgramParticipationMutation) ClearModifiedEndTime() {
	m.modified_end_time = nil
	m.clearedFields[betaprogramparticipation.FieldModifiedEndTime] = struct{}{}
}

// ModifiedEndTimeCleared returns if the "modified_end_time" field was cleared in this mutation.
func (m *BetaProgramParticipationMutation) ModifiedEndTimeCleared() bool {
	_, ok := m.clearedFields[betaprogramparticipation.FieldModifiedEndTime]
	return ok
}

// ResetModifiedEndTime resets all changes to the "modified_end_time" field.
func (m *BetaProgramParticipationMutation) ResetModifiedEndTime() {
	m.modified_end_time = nil
	delete(m.clearedFields, betaprogramparticipation.FieldModifiedEndTime)
}

// ClearBetaProgram clears the "beta_program" edge to the BetaProgram entity.
func (m *BetaProgramParticipationMutation) ClearBetaProgram() {
	m.clearedbeta_program = true
	m.clearedFields[betaprogramparticipation.FieldBetaProgramID] = struct{}{}
}

// BetaProgramCleared reports if the "beta_program" edge to the BetaProgram entity was cleared.
func (m *BetaProgramParticipationMutation) BetaProgramCleared() bool {
	return m.clearedbeta_program
}

// BetaProgramIDs returns the "beta_program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BetaProgramID instead. It exists only for internal usage by the builders.
func (m *BetaProgramParticipationMutation) BetaProgramIDs() (ids []int) {
	if id := m.beta_program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBetaProgram resets all changes to the "beta_program" edge.
func (m *BetaProgramParticipationMutation) ResetBetaProgram() {
	m.beta_program = nil
	m.clearedbeta_program = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BetaProgramParticipationMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[betaprogramparticipation.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BetaProgramParticipationMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BetaProgramParticipationMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BetaProgramParticipationMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *BetaProgramParticipationMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[betaprogramparticipation.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *BetaProgramParticipationMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *BetaProgramParticipationMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *BetaProgramParticipationMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// Where appends a list predicates to the BetaProgramParticipationMutation builder.
func (m *BetaProgramParticipationMutation) Where(ps ...predicate.BetaProgramParticipation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BetaProgramParticipationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BetaProgramParticipationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BetaProgramParticipation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BetaProgramParticipationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BetaProgramParticipationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BetaProgramParticipation).
func (m *BetaProgramParticipationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BetaProgramParticipationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.beta_program != nil {
		fields = append(fields, betaprogramparticipation.FieldBetaProgramID)
	}
	if m.customer != nil {
		fields = append(fields, betaprogramparticipation.FieldCustomerID)
	}
	if m.clinic != nil {
		fields = append(fields, betaprogramparticipation.FieldClinicID)
	}
	if m.is_active != nil {
		fields = append(fields, betaprogramparticipation.FieldIsActive)
	}
	if m.has_modified_start_time != nil {
		fields = append(fields, betaprogramparticipation.FieldHasModifiedStartTime)
	}
	if m.modified_start_time != nil {
		fields = append(fields, betaprogramparticipation.FieldModifiedStartTime)
	}
	if m.modified_end_time != nil {
		fields = append(fields, betaprogramparticipation.FieldModifiedEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BetaProgramParticipationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case betaprogramparticipation.FieldBetaProgramID:
		return m.BetaProgramID()
	case betaprogramparticipation.FieldCustomerID:
		return m.CustomerID()
	case betaprogramparticipation.FieldClinicID:
		return m.ClinicID()
	case betaprogramparticipation.FieldIsActive:
		return m.IsActive()
	case betaprogramparticipation.FieldHasModifiedStartTime:
		return m.HasModifiedStartTime()
	case betaprogramparticipation.FieldModifiedStartTime:
		return m.ModifiedStartTime()
	case betaprogramparticipation.FieldModifiedEndTime:
		return m.ModifiedEndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BetaProgramParticipationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case betaprogramparticipation.FieldBetaProgramID:
		return m.OldBetaProgramID(ctx)
	case betaprogramparticipation.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case betaprogramparticipation.FieldClinicID:
		return m.OldClinicID(ctx)
	case betaprogramparticipation.FieldIsActive:
		return m.OldIsActive(ctx)
	case betaprogramparticipation.FieldHasModifiedStartTime:
		return m.OldHasModifiedStartTime(ctx)
	case betaprogramparticipation.FieldModifiedStartTime:
		return m.OldModifiedStartTime(ctx)
	case betaprogramparticipation.FieldModifiedEndTime:
		return m.OldModifiedEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown BetaProgramParticipation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetaProgramParticipationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case betaprogramparticipation.FieldBetaProgramID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramID(v)
		return nil
	case betaprogramparticipation.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case betaprogramparticipation.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case betaprogramparticipation.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case betaprogramparticipation.FieldHasModifiedStartTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasModifiedStartTime(v)
		return nil
	case betaprogramparticipation.FieldModifiedStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedStartTime(v)
		return nil
	case betaprogramparticipation.FieldModifiedEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown BetaProgramParticipation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BetaProgramParticipationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BetaProgramParticipationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetaProgramParticipationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BetaProgramParticipation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BetaProgramParticipationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(betaprogramparticipation.FieldModifiedStartTime) {
		fields = append(fields, betaprogramparticipation.FieldModifiedStartTime)
	}
	if m.FieldCleared(betaprogramparticipation.FieldModifiedEndTime) {
		fields = append(fields, betaprogramparticipation.FieldModifiedEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BetaProgramParticipationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BetaProgramParticipationMutation) ClearField(name string) error {
	switch name {
	case betaprogramparticipation.FieldModifiedStartTime:
		m.ClearModifiedStartTime()
		return nil
	case betaprogramparticipation.FieldModifiedEndTime:
		m.ClearModifiedEndTime()
		return nil
	}
	return fmt.Errorf("unknown BetaProgramParticipation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BetaProgramParticipationMutation) ResetField(name string) error {
	switch name {
	case betaprogramparticipation.FieldBetaProgramID:
		m.ResetBetaProgramID()
		return nil
	case betaprogramparticipation.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case betaprogramparticipation.FieldClinicID:
		m.ResetClinicID()
		return nil
	case betaprogramparticipation.FieldIsActive:
		m.ResetIsActive()
		return nil
	case betaprogramparticipation.FieldHasModifiedStartTime:
		m.ResetHasModifiedStartTime()
		return nil
	case betaprogramparticipation.FieldModifiedStartTime:
		m.ResetModifiedStartTime()
		return nil
	case betaprogramparticipation.FieldModifiedEndTime:
		m.ResetModifiedEndTime()
		return nil
	}
	return fmt.Errorf("unknown BetaProgramParticipation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BetaProgramParticipationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.beta_program != nil {
		edges = append(edges, betaprogramparticipation.EdgeBetaProgram)
	}
	if m.customer != nil {
		edges = append(edges, betaprogramparticipation.EdgeCustomer)
	}
	if m.clinic != nil {
		edges = append(edges, betaprogramparticipation.EdgeClinic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BetaProgramParticipationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case betaprogramparticipation.EdgeBetaProgram:
		if id := m.beta_program; id != nil {
			return []ent.Value{*id}
		}
	case betaprogramparticipation.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case betaprogramparticipation.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BetaProgramParticipationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BetaProgramParticipationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BetaProgramParticipationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbeta_program {
		edges = append(edges, betaprogramparticipation.EdgeBetaProgram)
	}
	if m.clearedcustomer {
		edges = append(edges, betaprogramparticipation.EdgeCustomer)
	}
	if m.clearedclinic {
		edges = append(edges, betaprogramparticipation.EdgeClinic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BetaProgramParticipationMutation) EdgeCleared(name string) bool {
	switch name {
	case betaprogramparticipation.EdgeBetaProgram:
		return m.clearedbeta_program
	case betaprogramparticipation.EdgeCustomer:
		return m.clearedcustomer
	case betaprogramparticipation.EdgeClinic:
		return m.clearedclinic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BetaProgramParticipationMutation) ClearEdge(name string) error {
	switch name {
	case betaprogramparticipation.EdgeBetaProgram:
		m.ClearBetaProgram()
		return nil
	case betaprogramparticipation.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case betaprogramparticipation.EdgeClinic:
		m.ClearClinic()
		return nil
	}
	return fmt.Errorf("unknown BetaProgramParticipation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BetaProgramParticipationMutation) ResetEdge(name string) error {
	switch name {
	case betaprogramparticipation.EdgeBetaProgram:
		m.ResetBetaProgram()
		return nil
	case betaprogramparticipation.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case betaprogramparticipation.EdgeClinic:
		m.ResetClinic()
		return nil
	}
	return fmt.Errorf("unknown BetaProgramParticipation edge %s", name)
}

// ClinicMutation represents an operation that mutates the Clinic nodes in the graph.
type ClinicMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	clinic_name                               *string
	is_active                                 *bool
	clinic_account_id                         *int
	addclinic_account_id                      *int
	clinic_name_old_system                    *string
	clinic_signup_time                        *time.Time
	clinic_updated_time                       *time.Time
	clearedFields                             map[string]struct{}
	user                                      *int
	cleareduser                               bool
	clinic_contacts                           map[int]struct{}
	removedclinic_contacts                    map[int]struct{}
	clearedclinic_contacts                    bool
	clinic_addresses                          map[int]struct{}
	removedclinic_addresses                   map[int]struct{}
	clearedclinic_addresses                   bool
	customers                                 map[int]struct{}
	removedcustomers                          map[int]struct{}
	clearedcustomers                          bool
	clinic_settings                           map[int]struct{}
	removedclinic_settings                    map[int]struct{}
	clearedclinic_settings                    bool
	clinic_orders                             map[int]struct{}
	removedclinic_orders                      map[int]struct{}
	clearedclinic_orders                      bool
	clinic_patients                           map[int]struct{}
	removedclinic_patients                    map[int]struct{}
	clearedclinic_patients                    bool
	clinic_beta_program_participations        map[int]struct{}
	removedclinic_beta_program_participations map[int]struct{}
	clearedclinic_beta_program_participations bool
	clinic_customer_settings                  map[int]struct{}
	removedclinic_customer_settings           map[int]struct{}
	clearedclinic_customer_settings           bool
	clinic_customer_addresses                 map[int]struct{}
	removedclinic_customer_addresses          map[int]struct{}
	clearedclinic_customer_addresses          bool
	clinic_customer_contacts                  map[int]struct{}
	removedclinic_customer_contacts           map[int]struct{}
	clearedclinic_customer_contacts           bool
	done                                      bool
	oldValue                                  func(context.Context) (*Clinic, error)
	predicates                                []predicate.Clinic
}

var _ ent.Mutation = (*ClinicMutation)(nil)

// clinicOption allows management of the mutation configuration using functional options.
type clinicOption func(*ClinicMutation)

// newClinicMutation creates new mutation for the Clinic entity.
func newClinicMutation(c config, op Op, opts ...clinicOption) *ClinicMutation {
	m := &ClinicMutation{
		config:        c,
		op:            op,
		typ:           TypeClinic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicID sets the ID field of the mutation.
func withClinicID(id int) clinicOption {
	return func(m *ClinicMutation) {
		var (
			err   error
			once  sync.Once
			value *Clinic
		)
		m.oldValue = func(ctx context.Context) (*Clinic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clinic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinic sets the old Clinic of the mutation.
func withClinic(node *Clinic) clinicOption {
	return func(m *ClinicMutation) {
		m.oldValue = func(context.Context) (*Clinic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Clinic entities.
func (m *ClinicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Clinic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClinicName sets the "clinic_name" field.
func (m *ClinicMutation) SetClinicName(s string) {
	m.clinic_name = &s
}

// ClinicName returns the value of the "clinic_name" field in the mutation.
func (m *ClinicMutation) ClinicName() (r string, exists bool) {
	v := m.clinic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicName returns the old "clinic_name" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldClinicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicName: %w", err)
	}
	return oldValue.ClinicName, nil
}

// ResetClinicName resets all changes to the "clinic_name" field.
func (m *ClinicMutation) ResetClinicName() {
	m.clinic_name = nil
}

// SetUserID sets the "user_id" field.
func (m *ClinicMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ClinicMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ClinicMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[clinic.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ClinicMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[clinic.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ClinicMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, clinic.FieldUserID)
}

// SetIsActive sets the "is_active" field.
func (m *ClinicMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ClinicMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ClinicMutation) ResetIsActive() {
	m.is_active = nil
}

// SetClinicAccountID sets the "clinic_account_id" field.
func (m *ClinicMutation) SetClinicAccountID(i int) {
	m.clinic_account_id = &i
	m.addclinic_account_id = nil
}

// ClinicAccountID returns the value of the "clinic_account_id" field in the mutation.
func (m *ClinicMutation) ClinicAccountID() (r int, exists bool) {
	v := m.clinic_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicAccountID returns the old "clinic_account_id" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldClinicAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicAccountID: %w", err)
	}
	return oldValue.ClinicAccountID, nil
}

// AddClinicAccountID adds i to the "clinic_account_id" field.
func (m *ClinicMutation) AddClinicAccountID(i int) {
	if m.addclinic_account_id != nil {
		*m.addclinic_account_id += i
	} else {
		m.addclinic_account_id = &i
	}
}

// AddedClinicAccountID returns the value that was added to the "clinic_account_id" field in this mutation.
func (m *ClinicMutation) AddedClinicAccountID() (r int, exists bool) {
	v := m.addclinic_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearClinicAccountID clears the value of the "clinic_account_id" field.
func (m *ClinicMutation) ClearClinicAccountID() {
	m.clinic_account_id = nil
	m.addclinic_account_id = nil
	m.clearedFields[clinic.FieldClinicAccountID] = struct{}{}
}

// ClinicAccountIDCleared returns if the "clinic_account_id" field was cleared in this mutation.
func (m *ClinicMutation) ClinicAccountIDCleared() bool {
	_, ok := m.clearedFields[clinic.FieldClinicAccountID]
	return ok
}

// ResetClinicAccountID resets all changes to the "clinic_account_id" field.
func (m *ClinicMutation) ResetClinicAccountID() {
	m.clinic_account_id = nil
	m.addclinic_account_id = nil
	delete(m.clearedFields, clinic.FieldClinicAccountID)
}

// SetClinicNameOldSystem sets the "clinic_name_old_system" field.
func (m *ClinicMutation) SetClinicNameOldSystem(s string) {
	m.clinic_name_old_system = &s
}

// ClinicNameOldSystem returns the value of the "clinic_name_old_system" field in the mutation.
func (m *ClinicMutation) ClinicNameOldSystem() (r string, exists bool) {
	v := m.clinic_name_old_system
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicNameOldSystem returns the old "clinic_name_old_system" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldClinicNameOldSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicNameOldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicNameOldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicNameOldSystem: %w", err)
	}
	return oldValue.ClinicNameOldSystem, nil
}

// ClearClinicNameOldSystem clears the value of the "clinic_name_old_system" field.
func (m *ClinicMutation) ClearClinicNameOldSystem() {
	m.clinic_name_old_system = nil
	m.clearedFields[clinic.FieldClinicNameOldSystem] = struct{}{}
}

// ClinicNameOldSystemCleared returns if the "clinic_name_old_system" field was cleared in this mutation.
func (m *ClinicMutation) ClinicNameOldSystemCleared() bool {
	_, ok := m.clearedFields[clinic.FieldClinicNameOldSystem]
	return ok
}

// ResetClinicNameOldSystem resets all changes to the "clinic_name_old_system" field.
func (m *ClinicMutation) ResetClinicNameOldSystem() {
	m.clinic_name_old_system = nil
	delete(m.clearedFields, clinic.FieldClinicNameOldSystem)
}

// SetClinicSignupTime sets the "clinic_signup_time" field.
func (m *ClinicMutation) SetClinicSignupTime(t time.Time) {
	m.clinic_signup_time = &t
}

// ClinicSignupTime returns the value of the "clinic_signup_time" field in the mutation.
func (m *ClinicMutation) ClinicSignupTime() (r time.Time, exists bool) {
	v := m.clinic_signup_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicSignupTime returns the old "clinic_signup_time" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldClinicSignupTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicSignupTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicSignupTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicSignupTime: %w", err)
	}
	return oldValue.ClinicSignupTime, nil
}

// ResetClinicSignupTime resets all changes to the "clinic_signup_time" field.
func (m *ClinicMutation) ResetClinicSignupTime() {
	m.clinic_signup_time = nil
}

// SetClinicUpdatedTime sets the "clinic_updated_time" field.
func (m *ClinicMutation) SetClinicUpdatedTime(t time.Time) {
	m.clinic_updated_time = &t
}

// ClinicUpdatedTime returns the value of the "clinic_updated_time" field in the mutation.
func (m *ClinicMutation) ClinicUpdatedTime() (r time.Time, exists bool) {
	v := m.clinic_updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicUpdatedTime returns the old "clinic_updated_time" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldClinicUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicUpdatedTime: %w", err)
	}
	return oldValue.ClinicUpdatedTime, nil
}

// ClearClinicUpdatedTime clears the value of the "clinic_updated_time" field.
func (m *ClinicMutation) ClearClinicUpdatedTime() {
	m.clinic_updated_time = nil
	m.clearedFields[clinic.FieldClinicUpdatedTime] = struct{}{}
}

// ClinicUpdatedTimeCleared returns if the "clinic_updated_time" field was cleared in this mutation.
func (m *ClinicMutation) ClinicUpdatedTimeCleared() bool {
	_, ok := m.clearedFields[clinic.FieldClinicUpdatedTime]
	return ok
}

// ResetClinicUpdatedTime resets all changes to the "clinic_updated_time" field.
func (m *ClinicMutation) ResetClinicUpdatedTime() {
	m.clinic_updated_time = nil
	delete(m.clearedFields, clinic.FieldClinicUpdatedTime)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClinicMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[clinic.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClinicMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClinicMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClinicMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddClinicContactIDs adds the "clinic_contacts" edge to the Contact entity by ids.
func (m *ClinicMutation) AddClinicContactIDs(ids ...int) {
	if m.clinic_contacts == nil {
		m.clinic_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_contacts[ids[i]] = struct{}{}
	}
}

// ClearClinicContacts clears the "clinic_contacts" edge to the Contact entity.
func (m *ClinicMutation) ClearClinicContacts() {
	m.clearedclinic_contacts = true
}

// ClinicContactsCleared reports if the "clinic_contacts" edge to the Contact entity was cleared.
func (m *ClinicMutation) ClinicContactsCleared() bool {
	return m.clearedclinic_contacts
}

// RemoveClinicContactIDs removes the "clinic_contacts" edge to the Contact entity by IDs.
func (m *ClinicMutation) RemoveClinicContactIDs(ids ...int) {
	if m.removedclinic_contacts == nil {
		m.removedclinic_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_contacts, ids[i])
		m.removedclinic_contacts[ids[i]] = struct{}{}
	}
}

// RemovedClinicContacts returns the removed IDs of the "clinic_contacts" edge to the Contact entity.
func (m *ClinicMutation) RemovedClinicContactsIDs() (ids []int) {
	for id := range m.removedclinic_contacts {
		ids = append(ids, id)
	}
	return
}

// ClinicContactsIDs returns the "clinic_contacts" edge IDs in the mutation.
func (m *ClinicMutation) ClinicContactsIDs() (ids []int) {
	for id := range m.clinic_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetClinicContacts resets all changes to the "clinic_contacts" edge.
func (m *ClinicMutation) ResetClinicContacts() {
	m.clinic_contacts = nil
	m.clearedclinic_contacts = false
	m.removedclinic_contacts = nil
}

// AddClinicAddressIDs adds the "clinic_addresses" edge to the Address entity by ids.
func (m *ClinicMutation) AddClinicAddressIDs(ids ...int) {
	if m.clinic_addresses == nil {
		m.clinic_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_addresses[ids[i]] = struct{}{}
	}
}

// ClearClinicAddresses clears the "clinic_addresses" edge to the Address entity.
func (m *ClinicMutation) ClearClinicAddresses() {
	m.clearedclinic_addresses = true
}

// ClinicAddressesCleared reports if the "clinic_addresses" edge to the Address entity was cleared.
func (m *ClinicMutation) ClinicAddressesCleared() bool {
	return m.clearedclinic_addresses
}

// RemoveClinicAddressIDs removes the "clinic_addresses" edge to the Address entity by IDs.
func (m *ClinicMutation) RemoveClinicAddressIDs(ids ...int) {
	if m.removedclinic_addresses == nil {
		m.removedclinic_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_addresses, ids[i])
		m.removedclinic_addresses[ids[i]] = struct{}{}
	}
}

// RemovedClinicAddresses returns the removed IDs of the "clinic_addresses" edge to the Address entity.
func (m *ClinicMutation) RemovedClinicAddressesIDs() (ids []int) {
	for id := range m.removedclinic_addresses {
		ids = append(ids, id)
	}
	return
}

// ClinicAddressesIDs returns the "clinic_addresses" edge IDs in the mutation.
func (m *ClinicMutation) ClinicAddressesIDs() (ids []int) {
	for id := range m.clinic_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetClinicAddresses resets all changes to the "clinic_addresses" edge.
func (m *ClinicMutation) ResetClinicAddresses() {
	m.clinic_addresses = nil
	m.clearedclinic_addresses = false
	m.removedclinic_addresses = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *ClinicMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *ClinicMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *ClinicMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *ClinicMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *ClinicMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *ClinicMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *ClinicMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddClinicSettingIDs adds the "clinic_settings" edge to the Setting entity by ids.
func (m *ClinicMutation) AddClinicSettingIDs(ids ...int) {
	if m.clinic_settings == nil {
		m.clinic_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_settings[ids[i]] = struct{}{}
	}
}

// ClearClinicSettings clears the "clinic_settings" edge to the Setting entity.
func (m *ClinicMutation) ClearClinicSettings() {
	m.clearedclinic_settings = true
}

// ClinicSettingsCleared reports if the "clinic_settings" edge to the Setting entity was cleared.
func (m *ClinicMutation) ClinicSettingsCleared() bool {
	return m.clearedclinic_settings
}

// RemoveClinicSettingIDs removes the "clinic_settings" edge to the Setting entity by IDs.
func (m *ClinicMutation) RemoveClinicSettingIDs(ids ...int) {
	if m.removedclinic_settings == nil {
		m.removedclinic_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_settings, ids[i])
		m.removedclinic_settings[ids[i]] = struct{}{}
	}
}

// RemovedClinicSettings returns the removed IDs of the "clinic_settings" edge to the Setting entity.
func (m *ClinicMutation) RemovedClinicSettingsIDs() (ids []int) {
	for id := range m.removedclinic_settings {
		ids = append(ids, id)
	}
	return
}

// ClinicSettingsIDs returns the "clinic_settings" edge IDs in the mutation.
func (m *ClinicMutation) ClinicSettingsIDs() (ids []int) {
	for id := range m.clinic_settings {
		ids = append(ids, id)
	}
	return
}

// ResetClinicSettings resets all changes to the "clinic_settings" edge.
func (m *ClinicMutation) ResetClinicSettings() {
	m.clinic_settings = nil
	m.clearedclinic_settings = false
	m.removedclinic_settings = nil
}

// AddClinicOrderIDs adds the "clinic_orders" edge to the OrderInfo entity by ids.
func (m *ClinicMutation) AddClinicOrderIDs(ids ...int) {
	if m.clinic_orders == nil {
		m.clinic_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_orders[ids[i]] = struct{}{}
	}
}

// ClearClinicOrders clears the "clinic_orders" edge to the OrderInfo entity.
func (m *ClinicMutation) ClearClinicOrders() {
	m.clearedclinic_orders = true
}

// ClinicOrdersCleared reports if the "clinic_orders" edge to the OrderInfo entity was cleared.
func (m *ClinicMutation) ClinicOrdersCleared() bool {
	return m.clearedclinic_orders
}

// RemoveClinicOrderIDs removes the "clinic_orders" edge to the OrderInfo entity by IDs.
func (m *ClinicMutation) RemoveClinicOrderIDs(ids ...int) {
	if m.removedclinic_orders == nil {
		m.removedclinic_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_orders, ids[i])
		m.removedclinic_orders[ids[i]] = struct{}{}
	}
}

// RemovedClinicOrders returns the removed IDs of the "clinic_orders" edge to the OrderInfo entity.
func (m *ClinicMutation) RemovedClinicOrdersIDs() (ids []int) {
	for id := range m.removedclinic_orders {
		ids = append(ids, id)
	}
	return
}

// ClinicOrdersIDs returns the "clinic_orders" edge IDs in the mutation.
func (m *ClinicMutation) ClinicOrdersIDs() (ids []int) {
	for id := range m.clinic_orders {
		ids = append(ids, id)
	}
	return
}

// ResetClinicOrders resets all changes to the "clinic_orders" edge.
func (m *ClinicMutation) ResetClinicOrders() {
	m.clinic_orders = nil
	m.clearedclinic_orders = false
	m.removedclinic_orders = nil
}

// AddClinicPatientIDs adds the "clinic_patients" edge to the Patient entity by ids.
func (m *ClinicMutation) AddClinicPatientIDs(ids ...int) {
	if m.clinic_patients == nil {
		m.clinic_patients = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_patients[ids[i]] = struct{}{}
	}
}

// ClearClinicPatients clears the "clinic_patients" edge to the Patient entity.
func (m *ClinicMutation) ClearClinicPatients() {
	m.clearedclinic_patients = true
}

// ClinicPatientsCleared reports if the "clinic_patients" edge to the Patient entity was cleared.
func (m *ClinicMutation) ClinicPatientsCleared() bool {
	return m.clearedclinic_patients
}

// RemoveClinicPatientIDs removes the "clinic_patients" edge to the Patient entity by IDs.
func (m *ClinicMutation) RemoveClinicPatientIDs(ids ...int) {
	if m.removedclinic_patients == nil {
		m.removedclinic_patients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_patients, ids[i])
		m.removedclinic_patients[ids[i]] = struct{}{}
	}
}

// RemovedClinicPatients returns the removed IDs of the "clinic_patients" edge to the Patient entity.
func (m *ClinicMutation) RemovedClinicPatientsIDs() (ids []int) {
	for id := range m.removedclinic_patients {
		ids = append(ids, id)
	}
	return
}

// ClinicPatientsIDs returns the "clinic_patients" edge IDs in the mutation.
func (m *ClinicMutation) ClinicPatientsIDs() (ids []int) {
	for id := range m.clinic_patients {
		ids = append(ids, id)
	}
	return
}

// ResetClinicPatients resets all changes to the "clinic_patients" edge.
func (m *ClinicMutation) ResetClinicPatients() {
	m.clinic_patients = nil
	m.clearedclinic_patients = false
	m.removedclinic_patients = nil
}

// AddClinicBetaProgramParticipationIDs adds the "clinic_beta_program_participations" edge to the BetaProgramParticipation entity by ids.
func (m *ClinicMutation) AddClinicBetaProgramParticipationIDs(ids ...int) {
	if m.clinic_beta_program_participations == nil {
		m.clinic_beta_program_participations = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_beta_program_participations[ids[i]] = struct{}{}
	}
}

// ClearClinicBetaProgramParticipations clears the "clinic_beta_program_participations" edge to the BetaProgramParticipation entity.
func (m *ClinicMutation) ClearClinicBetaProgramParticipations() {
	m.clearedclinic_beta_program_participations = true
}

// ClinicBetaProgramParticipationsCleared reports if the "clinic_beta_program_participations" edge to the BetaProgramParticipation entity was cleared.
func (m *ClinicMutation) ClinicBetaProgramParticipationsCleared() bool {
	return m.clearedclinic_beta_program_participations
}

// RemoveClinicBetaProgramParticipationIDs removes the "clinic_beta_program_participations" edge to the BetaProgramParticipation entity by IDs.
func (m *ClinicMutation) RemoveClinicBetaProgramParticipationIDs(ids ...int) {
	if m.removedclinic_beta_program_participations == nil {
		m.removedclinic_beta_program_participations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_beta_program_participations, ids[i])
		m.removedclinic_beta_program_participations[ids[i]] = struct{}{}
	}
}

// RemovedClinicBetaProgramParticipations returns the removed IDs of the "clinic_beta_program_participations" edge to the BetaProgramParticipation entity.
func (m *ClinicMutation) RemovedClinicBetaProgramParticipationsIDs() (ids []int) {
	for id := range m.removedclinic_beta_program_participations {
		ids = append(ids, id)
	}
	return
}

// ClinicBetaProgramParticipationsIDs returns the "clinic_beta_program_participations" edge IDs in the mutation.
func (m *ClinicMutation) ClinicBetaProgramParticipationsIDs() (ids []int) {
	for id := range m.clinic_beta_program_participations {
		ids = append(ids, id)
	}
	return
}

// ResetClinicBetaProgramParticipations resets all changes to the "clinic_beta_program_participations" edge.
func (m *ClinicMutation) ResetClinicBetaProgramParticipations() {
	m.clinic_beta_program_participations = nil
	m.clearedclinic_beta_program_participations = false
	m.removedclinic_beta_program_participations = nil
}

// AddClinicCustomerSettingIDs adds the "clinic_customer_settings" edge to the CustomerSettingOnClinics entity by ids.
func (m *ClinicMutation) AddClinicCustomerSettingIDs(ids ...int) {
	if m.clinic_customer_settings == nil {
		m.clinic_customer_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_customer_settings[ids[i]] = struct{}{}
	}
}

// ClearClinicCustomerSettings clears the "clinic_customer_settings" edge to the CustomerSettingOnClinics entity.
func (m *ClinicMutation) ClearClinicCustomerSettings() {
	m.clearedclinic_customer_settings = true
}

// ClinicCustomerSettingsCleared reports if the "clinic_customer_settings" edge to the CustomerSettingOnClinics entity was cleared.
func (m *ClinicMutation) ClinicCustomerSettingsCleared() bool {
	return m.clearedclinic_customer_settings
}

// RemoveClinicCustomerSettingIDs removes the "clinic_customer_settings" edge to the CustomerSettingOnClinics entity by IDs.
func (m *ClinicMutation) RemoveClinicCustomerSettingIDs(ids ...int) {
	if m.removedclinic_customer_settings == nil {
		m.removedclinic_customer_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_customer_settings, ids[i])
		m.removedclinic_customer_settings[ids[i]] = struct{}{}
	}
}

// RemovedClinicCustomerSettings returns the removed IDs of the "clinic_customer_settings" edge to the CustomerSettingOnClinics entity.
func (m *ClinicMutation) RemovedClinicCustomerSettingsIDs() (ids []int) {
	for id := range m.removedclinic_customer_settings {
		ids = append(ids, id)
	}
	return
}

// ClinicCustomerSettingsIDs returns the "clinic_customer_settings" edge IDs in the mutation.
func (m *ClinicMutation) ClinicCustomerSettingsIDs() (ids []int) {
	for id := range m.clinic_customer_settings {
		ids = append(ids, id)
	}
	return
}

// ResetClinicCustomerSettings resets all changes to the "clinic_customer_settings" edge.
func (m *ClinicMutation) ResetClinicCustomerSettings() {
	m.clinic_customer_settings = nil
	m.clearedclinic_customer_settings = false
	m.removedclinic_customer_settings = nil
}

// AddClinicCustomerAddressIDs adds the "clinic_customer_addresses" edge to the CustomerAddressOnClinics entity by ids.
func (m *ClinicMutation) AddClinicCustomerAddressIDs(ids ...int) {
	if m.clinic_customer_addresses == nil {
		m.clinic_customer_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_customer_addresses[ids[i]] = struct{}{}
	}
}

// ClearClinicCustomerAddresses clears the "clinic_customer_addresses" edge to the CustomerAddressOnClinics entity.
func (m *ClinicMutation) ClearClinicCustomerAddresses() {
	m.clearedclinic_customer_addresses = true
}

// ClinicCustomerAddressesCleared reports if the "clinic_customer_addresses" edge to the CustomerAddressOnClinics entity was cleared.
func (m *ClinicMutation) ClinicCustomerAddressesCleared() bool {
	return m.clearedclinic_customer_addresses
}

// RemoveClinicCustomerAddressIDs removes the "clinic_customer_addresses" edge to the CustomerAddressOnClinics entity by IDs.
func (m *ClinicMutation) RemoveClinicCustomerAddressIDs(ids ...int) {
	if m.removedclinic_customer_addresses == nil {
		m.removedclinic_customer_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_customer_addresses, ids[i])
		m.removedclinic_customer_addresses[ids[i]] = struct{}{}
	}
}

// RemovedClinicCustomerAddresses returns the removed IDs of the "clinic_customer_addresses" edge to the CustomerAddressOnClinics entity.
func (m *ClinicMutation) RemovedClinicCustomerAddressesIDs() (ids []int) {
	for id := range m.removedclinic_customer_addresses {
		ids = append(ids, id)
	}
	return
}

// ClinicCustomerAddressesIDs returns the "clinic_customer_addresses" edge IDs in the mutation.
func (m *ClinicMutation) ClinicCustomerAddressesIDs() (ids []int) {
	for id := range m.clinic_customer_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetClinicCustomerAddresses resets all changes to the "clinic_customer_addresses" edge.
func (m *ClinicMutation) ResetClinicCustomerAddresses() {
	m.clinic_customer_addresses = nil
	m.clearedclinic_customer_addresses = false
	m.removedclinic_customer_addresses = nil
}

// AddClinicCustomerContactIDs adds the "clinic_customer_contacts" edge to the CustomerContactOnClinics entity by ids.
func (m *ClinicMutation) AddClinicCustomerContactIDs(ids ...int) {
	if m.clinic_customer_contacts == nil {
		m.clinic_customer_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_customer_contacts[ids[i]] = struct{}{}
	}
}

// ClearClinicCustomerContacts clears the "clinic_customer_contacts" edge to the CustomerContactOnClinics entity.
func (m *ClinicMutation) ClearClinicCustomerContacts() {
	m.clearedclinic_customer_contacts = true
}

// ClinicCustomerContactsCleared reports if the "clinic_customer_contacts" edge to the CustomerContactOnClinics entity was cleared.
func (m *ClinicMutation) ClinicCustomerContactsCleared() bool {
	return m.clearedclinic_customer_contacts
}

// RemoveClinicCustomerContactIDs removes the "clinic_customer_contacts" edge to the CustomerContactOnClinics entity by IDs.
func (m *ClinicMutation) RemoveClinicCustomerContactIDs(ids ...int) {
	if m.removedclinic_customer_contacts == nil {
		m.removedclinic_customer_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_customer_contacts, ids[i])
		m.removedclinic_customer_contacts[ids[i]] = struct{}{}
	}
}

// RemovedClinicCustomerContacts returns the removed IDs of the "clinic_customer_contacts" edge to the CustomerContactOnClinics entity.
func (m *ClinicMutation) RemovedClinicCustomerContactsIDs() (ids []int) {
	for id := range m.removedclinic_customer_contacts {
		ids = append(ids, id)
	}
	return
}

// ClinicCustomerContactsIDs returns the "clinic_customer_contacts" edge IDs in the mutation.
func (m *ClinicMutation) ClinicCustomerContactsIDs() (ids []int) {
	for id := range m.clinic_customer_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetClinicCustomerContacts resets all changes to the "clinic_customer_contacts" edge.
func (m *ClinicMutation) ResetClinicCustomerContacts() {
	m.clinic_customer_contacts = nil
	m.clearedclinic_customer_contacts = false
	m.removedclinic_customer_contacts = nil
}

// Where appends a list predicates to the ClinicMutation builder.
func (m *ClinicMutation) Where(ps ...predicate.Clinic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClinicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClinicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Clinic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClinicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClinicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Clinic).
func (m *ClinicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.clinic_name != nil {
		fields = append(fields, clinic.FieldClinicName)
	}
	if m.user != nil {
		fields = append(fields, clinic.FieldUserID)
	}
	if m.is_active != nil {
		fields = append(fields, clinic.FieldIsActive)
	}
	if m.clinic_account_id != nil {
		fields = append(fields, clinic.FieldClinicAccountID)
	}
	if m.clinic_name_old_system != nil {
		fields = append(fields, clinic.FieldClinicNameOldSystem)
	}
	if m.clinic_signup_time != nil {
		fields = append(fields, clinic.FieldClinicSignupTime)
	}
	if m.clinic_updated_time != nil {
		fields = append(fields, clinic.FieldClinicUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinic.FieldClinicName:
		return m.ClinicName()
	case clinic.FieldUserID:
		return m.UserID()
	case clinic.FieldIsActive:
		return m.IsActive()
	case clinic.FieldClinicAccountID:
		return m.ClinicAccountID()
	case clinic.FieldClinicNameOldSystem:
		return m.ClinicNameOldSystem()
	case clinic.FieldClinicSignupTime:
		return m.ClinicSignupTime()
	case clinic.FieldClinicUpdatedTime:
		return m.ClinicUpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinic.FieldClinicName:
		return m.OldClinicName(ctx)
	case clinic.FieldUserID:
		return m.OldUserID(ctx)
	case clinic.FieldIsActive:
		return m.OldIsActive(ctx)
	case clinic.FieldClinicAccountID:
		return m.OldClinicAccountID(ctx)
	case clinic.FieldClinicNameOldSystem:
		return m.OldClinicNameOldSystem(ctx)
	case clinic.FieldClinicSignupTime:
		return m.OldClinicSignupTime(ctx)
	case clinic.FieldClinicUpdatedTime:
		return m.OldClinicUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Clinic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinic.FieldClinicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicName(v)
		return nil
	case clinic.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case clinic.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case clinic.FieldClinicAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicAccountID(v)
		return nil
	case clinic.FieldClinicNameOldSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicNameOldSystem(v)
		return nil
	case clinic.FieldClinicSignupTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicSignupTime(v)
		return nil
	case clinic.FieldClinicUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicMutation) AddedFields() []string {
	var fields []string
	if m.addclinic_account_id != nil {
		fields = append(fields, clinic.FieldClinicAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case clinic.FieldClinicAccountID:
		return m.AddedClinicAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case clinic.FieldClinicAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClinicAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Clinic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clinic.FieldUserID) {
		fields = append(fields, clinic.FieldUserID)
	}
	if m.FieldCleared(clinic.FieldClinicAccountID) {
		fields = append(fields, clinic.FieldClinicAccountID)
	}
	if m.FieldCleared(clinic.FieldClinicNameOldSystem) {
		fields = append(fields, clinic.FieldClinicNameOldSystem)
	}
	if m.FieldCleared(clinic.FieldClinicUpdatedTime) {
		fields = append(fields, clinic.FieldClinicUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicMutation) ClearField(name string) error {
	switch name {
	case clinic.FieldUserID:
		m.ClearUserID()
		return nil
	case clinic.FieldClinicAccountID:
		m.ClearClinicAccountID()
		return nil
	case clinic.FieldClinicNameOldSystem:
		m.ClearClinicNameOldSystem()
		return nil
	case clinic.FieldClinicUpdatedTime:
		m.ClearClinicUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Clinic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicMutation) ResetField(name string) error {
	switch name {
	case clinic.FieldClinicName:
		m.ResetClinicName()
		return nil
	case clinic.FieldUserID:
		m.ResetUserID()
		return nil
	case clinic.FieldIsActive:
		m.ResetIsActive()
		return nil
	case clinic.FieldClinicAccountID:
		m.ResetClinicAccountID()
		return nil
	case clinic.FieldClinicNameOldSystem:
		m.ResetClinicNameOldSystem()
		return nil
	case clinic.FieldClinicSignupTime:
		m.ResetClinicSignupTime()
		return nil
	case clinic.FieldClinicUpdatedTime:
		m.ResetClinicUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.user != nil {
		edges = append(edges, clinic.EdgeUser)
	}
	if m.clinic_contacts != nil {
		edges = append(edges, clinic.EdgeClinicContacts)
	}
	if m.clinic_addresses != nil {
		edges = append(edges, clinic.EdgeClinicAddresses)
	}
	if m.customers != nil {
		edges = append(edges, clinic.EdgeCustomers)
	}
	if m.clinic_settings != nil {
		edges = append(edges, clinic.EdgeClinicSettings)
	}
	if m.clinic_orders != nil {
		edges = append(edges, clinic.EdgeClinicOrders)
	}
	if m.clinic_patients != nil {
		edges = append(edges, clinic.EdgeClinicPatients)
	}
	if m.clinic_beta_program_participations != nil {
		edges = append(edges, clinic.EdgeClinicBetaProgramParticipations)
	}
	if m.clinic_customer_settings != nil {
		edges = append(edges, clinic.EdgeClinicCustomerSettings)
	}
	if m.clinic_customer_addresses != nil {
		edges = append(edges, clinic.EdgeClinicCustomerAddresses)
	}
	if m.clinic_customer_contacts != nil {
		edges = append(edges, clinic.EdgeClinicCustomerContacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case clinic.EdgeClinicContacts:
		ids := make([]ent.Value, 0, len(m.clinic_contacts))
		for id := range m.clinic_contacts {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicAddresses:
		ids := make([]ent.Value, 0, len(m.clinic_addresses))
		for id := range m.clinic_addresses {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicSettings:
		ids := make([]ent.Value, 0, len(m.clinic_settings))
		for id := range m.clinic_settings {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicOrders:
		ids := make([]ent.Value, 0, len(m.clinic_orders))
		for id := range m.clinic_orders {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicPatients:
		ids := make([]ent.Value, 0, len(m.clinic_patients))
		for id := range m.clinic_patients {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicBetaProgramParticipations:
		ids := make([]ent.Value, 0, len(m.clinic_beta_program_participations))
		for id := range m.clinic_beta_program_participations {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerSettings:
		ids := make([]ent.Value, 0, len(m.clinic_customer_settings))
		for id := range m.clinic_customer_settings {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerAddresses:
		ids := make([]ent.Value, 0, len(m.clinic_customer_addresses))
		for id := range m.clinic_customer_addresses {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerContacts:
		ids := make([]ent.Value, 0, len(m.clinic_customer_contacts))
		for id := range m.clinic_customer_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedclinic_contacts != nil {
		edges = append(edges, clinic.EdgeClinicContacts)
	}
	if m.removedclinic_addresses != nil {
		edges = append(edges, clinic.EdgeClinicAddresses)
	}
	if m.removedcustomers != nil {
		edges = append(edges, clinic.EdgeCustomers)
	}
	if m.removedclinic_settings != nil {
		edges = append(edges, clinic.EdgeClinicSettings)
	}
	if m.removedclinic_orders != nil {
		edges = append(edges, clinic.EdgeClinicOrders)
	}
	if m.removedclinic_patients != nil {
		edges = append(edges, clinic.EdgeClinicPatients)
	}
	if m.removedclinic_beta_program_participations != nil {
		edges = append(edges, clinic.EdgeClinicBetaProgramParticipations)
	}
	if m.removedclinic_customer_settings != nil {
		edges = append(edges, clinic.EdgeClinicCustomerSettings)
	}
	if m.removedclinic_customer_addresses != nil {
		edges = append(edges, clinic.EdgeClinicCustomerAddresses)
	}
	if m.removedclinic_customer_contacts != nil {
		edges = append(edges, clinic.EdgeClinicCustomerContacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeClinicContacts:
		ids := make([]ent.Value, 0, len(m.removedclinic_contacts))
		for id := range m.removedclinic_contacts {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicAddresses:
		ids := make([]ent.Value, 0, len(m.removedclinic_addresses))
		for id := range m.removedclinic_addresses {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicSettings:
		ids := make([]ent.Value, 0, len(m.removedclinic_settings))
		for id := range m.removedclinic_settings {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicOrders:
		ids := make([]ent.Value, 0, len(m.removedclinic_orders))
		for id := range m.removedclinic_orders {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicPatients:
		ids := make([]ent.Value, 0, len(m.removedclinic_patients))
		for id := range m.removedclinic_patients {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicBetaProgramParticipations:
		ids := make([]ent.Value, 0, len(m.removedclinic_beta_program_participations))
		for id := range m.removedclinic_beta_program_participations {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerSettings:
		ids := make([]ent.Value, 0, len(m.removedclinic_customer_settings))
		for id := range m.removedclinic_customer_settings {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerAddresses:
		ids := make([]ent.Value, 0, len(m.removedclinic_customer_addresses))
		for id := range m.removedclinic_customer_addresses {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeClinicCustomerContacts:
		ids := make([]ent.Value, 0, len(m.removedclinic_customer_contacts))
		for id := range m.removedclinic_customer_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.cleareduser {
		edges = append(edges, clinic.EdgeUser)
	}
	if m.clearedclinic_contacts {
		edges = append(edges, clinic.EdgeClinicContacts)
	}
	if m.clearedclinic_addresses {
		edges = append(edges, clinic.EdgeClinicAddresses)
	}
	if m.clearedcustomers {
		edges = append(edges, clinic.EdgeCustomers)
	}
	if m.clearedclinic_settings {
		edges = append(edges, clinic.EdgeClinicSettings)
	}
	if m.clearedclinic_orders {
		edges = append(edges, clinic.EdgeClinicOrders)
	}
	if m.clearedclinic_patients {
		edges = append(edges, clinic.EdgeClinicPatients)
	}
	if m.clearedclinic_beta_program_participations {
		edges = append(edges, clinic.EdgeClinicBetaProgramParticipations)
	}
	if m.clearedclinic_customer_settings {
		edges = append(edges, clinic.EdgeClinicCustomerSettings)
	}
	if m.clearedclinic_customer_addresses {
		edges = append(edges, clinic.EdgeClinicCustomerAddresses)
	}
	if m.clearedclinic_customer_contacts {
		edges = append(edges, clinic.EdgeClinicCustomerContacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicMutation) EdgeCleared(name string) bool {
	switch name {
	case clinic.EdgeUser:
		return m.cleareduser
	case clinic.EdgeClinicContacts:
		return m.clearedclinic_contacts
	case clinic.EdgeClinicAddresses:
		return m.clearedclinic_addresses
	case clinic.EdgeCustomers:
		return m.clearedcustomers
	case clinic.EdgeClinicSettings:
		return m.clearedclinic_settings
	case clinic.EdgeClinicOrders:
		return m.clearedclinic_orders
	case clinic.EdgeClinicPatients:
		return m.clearedclinic_patients
	case clinic.EdgeClinicBetaProgramParticipations:
		return m.clearedclinic_beta_program_participations
	case clinic.EdgeClinicCustomerSettings:
		return m.clearedclinic_customer_settings
	case clinic.EdgeClinicCustomerAddresses:
		return m.clearedclinic_customer_addresses
	case clinic.EdgeClinicCustomerContacts:
		return m.clearedclinic_customer_contacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicMutation) ClearEdge(name string) error {
	switch name {
	case clinic.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Clinic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicMutation) ResetEdge(name string) error {
	switch name {
	case clinic.EdgeUser:
		m.ResetUser()
		return nil
	case clinic.EdgeClinicContacts:
		m.ResetClinicContacts()
		return nil
	case clinic.EdgeClinicAddresses:
		m.ResetClinicAddresses()
		return nil
	case clinic.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case clinic.EdgeClinicSettings:
		m.ResetClinicSettings()
		return nil
	case clinic.EdgeClinicOrders:
		m.ResetClinicOrders()
		return nil
	case clinic.EdgeClinicPatients:
		m.ResetClinicPatients()
		return nil
	case clinic.EdgeClinicBetaProgramParticipations:
		m.ResetClinicBetaProgramParticipations()
		return nil
	case clinic.EdgeClinicCustomerSettings:
		m.ResetClinicCustomerSettings()
		return nil
	case clinic.EdgeClinicCustomerAddresses:
		m.ResetClinicCustomerAddresses()
		return nil
	case clinic.EdgeClinicCustomerContacts:
		m.ResetClinicCustomerContacts()
		return nil
	}
	return fmt.Errorf("unknown Clinic edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	contact_description             *string
	contact_details                 *string
	contact_type                    *string
	is_primary_contact              *bool
	is_2fa_contact                  *bool
	user_id                         *int
	adduser_id                      *int
	contact_level                   *int
	addcontact_level                *int
	contact_level_name              *string
	apply_to_all_group_member       *bool
	is_group_contact                *bool
	use_as_default_create_contact   *bool
	use_group_contact               *bool
	clearedFields                   map[string]struct{}
	clinic                          *int
	clearedclinic                   bool
	patient                         *int
	clearedpatient                  bool
	customer                        *int
	clearedcustomer                 bool
	customer_clinic_mappings        map[int]struct{}
	removedcustomer_clinic_mappings map[int]struct{}
	clearedcustomer_clinic_mappings bool
	member_contacts                 map[int]struct{}
	removedmember_contacts          map[int]struct{}
	clearedmember_contacts          bool
	group_contact                   *int
	clearedgroup_contact            bool
	internal_user                   *int
	clearedinternal_user            bool
	orders                          map[int]struct{}
	removedorders                   map[int]struct{}
	clearedorders                   bool
	done                            bool
	oldValue                        func(context.Context) (*Contact, error)
	predicates                      []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id int) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContactDescription sets the "contact_description" field.
func (m *ContactMutation) SetContactDescription(s string) {
	m.contact_description = &s
}

// ContactDescription returns the value of the "contact_description" field in the mutation.
func (m *ContactMutation) ContactDescription() (r string, exists bool) {
	v := m.contact_description
	if v == nil {
		return
	}
	return *v, true
}

// OldContactDescription returns the old "contact_description" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldContactDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactDescription: %w", err)
	}
	return oldValue.ContactDescription, nil
}

// ClearContactDescription clears the value of the "contact_description" field.
func (m *ContactMutation) ClearContactDescription() {
	m.contact_description = nil
	m.clearedFields[contact.FieldContactDescription] = struct{}{}
}

// ContactDescriptionCleared returns if the "contact_description" field was cleared in this mutation.
func (m *ContactMutation) ContactDescriptionCleared() bool {
	_, ok := m.clearedFields[contact.FieldContactDescription]
	return ok
}

// ResetContactDescription resets all changes to the "contact_description" field.
func (m *ContactMutation) ResetContactDescription() {
	m.contact_description = nil
	delete(m.clearedFields, contact.FieldContactDescription)
}

// SetContactDetails sets the "contact_details" field.
func (m *ContactMutation) SetContactDetails(s string) {
	m.contact_details = &s
}

// ContactDetails returns the value of the "contact_details" field in the mutation.
func (m *ContactMutation) ContactDetails() (r string, exists bool) {
	v := m.contact_details
	if v == nil {
		return
	}
	return *v, true
}

// OldContactDetails returns the old "contact_details" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldContactDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactDetails: %w", err)
	}
	return oldValue.ContactDetails, nil
}

// ResetContactDetails resets all changes to the "contact_details" field.
func (m *ContactMutation) ResetContactDetails() {
	m.contact_details = nil
}

// SetContactType sets the "contact_type" field.
func (m *ContactMutation) SetContactType(s string) {
	m.contact_type = &s
}

// ContactType returns the value of the "contact_type" field in the mutation.
func (m *ContactMutation) ContactType() (r string, exists bool) {
	v := m.contact_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContactType returns the old "contact_type" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldContactType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactType: %w", err)
	}
	return oldValue.ContactType, nil
}

// ClearContactType clears the value of the "contact_type" field.
func (m *ContactMutation) ClearContactType() {
	m.contact_type = nil
	m.clearedFields[contact.FieldContactType] = struct{}{}
}

// ContactTypeCleared returns if the "contact_type" field was cleared in this mutation.
func (m *ContactMutation) ContactTypeCleared() bool {
	_, ok := m.clearedFields[contact.FieldContactType]
	return ok
}

// ResetContactType resets all changes to the "contact_type" field.
func (m *ContactMutation) ResetContactType() {
	m.contact_type = nil
	delete(m.clearedFields, contact.FieldContactType)
}

// SetIsPrimaryContact sets the "is_primary_contact" field.
func (m *ContactMutation) SetIsPrimaryContact(b bool) {
	m.is_primary_contact = &b
}

// IsPrimaryContact returns the value of the "is_primary_contact" field in the mutation.
func (m *ContactMutation) IsPrimaryContact() (r bool, exists bool) {
	v := m.is_primary_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimaryContact returns the old "is_primary_contact" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldIsPrimaryContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimaryContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimaryContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimaryContact: %w", err)
	}
	return oldValue.IsPrimaryContact, nil
}

// ClearIsPrimaryContact clears the value of the "is_primary_contact" field.
func (m *ContactMutation) ClearIsPrimaryContact() {
	m.is_primary_contact = nil
	m.clearedFields[contact.FieldIsPrimaryContact] = struct{}{}
}

// IsPrimaryContactCleared returns if the "is_primary_contact" field was cleared in this mutation.
func (m *ContactMutation) IsPrimaryContactCleared() bool {
	_, ok := m.clearedFields[contact.FieldIsPrimaryContact]
	return ok
}

// ResetIsPrimaryContact resets all changes to the "is_primary_contact" field.
func (m *ContactMutation) ResetIsPrimaryContact() {
	m.is_primary_contact = nil
	delete(m.clearedFields, contact.FieldIsPrimaryContact)
}

// SetIs2faContact sets the "is_2fa_contact" field.
func (m *ContactMutation) SetIs2faContact(b bool) {
	m.is_2fa_contact = &b
}

// Is2faContact returns the value of the "is_2fa_contact" field in the mutation.
func (m *ContactMutation) Is2faContact() (r bool, exists bool) {
	v := m.is_2fa_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIs2faContact returns the old "is_2fa_contact" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldIs2faContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIs2faContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIs2faContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIs2faContact: %w", err)
	}
	return oldValue.Is2faContact, nil
}

// ResetIs2faContact resets all changes to the "is_2fa_contact" field.
func (m *ContactMutation) ResetIs2faContact() {
	m.is_2fa_contact = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *ContactMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *ContactMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *ContactMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[contact.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *ContactMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *ContactMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, contact.FieldCustomerID)
}

// SetPatientID sets the "patient_id" field.
func (m *ContactMutation) SetPatientID(i int) {
	m.patient = &i
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *ContactMutation) PatientID() (r int, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldPatientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ClearPatientID clears the value of the "patient_id" field.
func (m *ContactMutation) ClearPatientID() {
	m.patient = nil
	m.clearedFields[contact.FieldPatientID] = struct{}{}
}

// PatientIDCleared returns if the "patient_id" field was cleared in this mutation.
func (m *ContactMutation) PatientIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldPatientID]
	return ok
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *ContactMutation) ResetPatientID() {
	m.patient = nil
	delete(m.clearedFields, contact.FieldPatientID)
}

// SetClinicID sets the "clinic_id" field.
func (m *ContactMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *ContactMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ClearClinicID clears the value of the "clinic_id" field.
func (m *ContactMutation) ClearClinicID() {
	m.clinic = nil
	m.clearedFields[contact.FieldClinicID] = struct{}{}
}

// ClinicIDCleared returns if the "clinic_id" field was cleared in this mutation.
func (m *ContactMutation) ClinicIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldClinicID]
	return ok
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *ContactMutation) ResetClinicID() {
	m.clinic = nil
	delete(m.clearedFields, contact.FieldClinicID)
}

// SetInternalUserID sets the "internal_user_id" field.
func (m *ContactMutation) SetInternalUserID(i int) {
	m.internal_user = &i
}

// InternalUserID returns the value of the "internal_user_id" field in the mutation.
func (m *ContactMutation) InternalUserID() (r int, exists bool) {
	v := m.internal_user
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserID returns the old "internal_user_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldInternalUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserID: %w", err)
	}
	return oldValue.InternalUserID, nil
}

// ClearInternalUserID clears the value of the "internal_user_id" field.
func (m *ContactMutation) ClearInternalUserID() {
	m.internal_user = nil
	m.clearedFields[contact.FieldInternalUserID] = struct{}{}
}

// InternalUserIDCleared returns if the "internal_user_id" field was cleared in this mutation.
func (m *ContactMutation) InternalUserIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldInternalUserID]
	return ok
}

// ResetInternalUserID resets all changes to the "internal_user_id" field.
func (m *ContactMutation) ResetInternalUserID() {
	m.internal_user = nil
	delete(m.clearedFields, contact.FieldInternalUserID)
}

// SetUserID sets the "user_id" field.
func (m *ContactMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ContactMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ContactMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ContactMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ContactMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[contact.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ContactMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ContactMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, contact.FieldUserID)
}

// SetContactLevel sets the "contact_level" field.
func (m *ContactMutation) SetContactLevel(i int) {
	m.contact_level = &i
	m.addcontact_level = nil
}

// ContactLevel returns the value of the "contact_level" field in the mutation.
func (m *ContactMutation) ContactLevel() (r int, exists bool) {
	v := m.contact_level
	if v == nil {
		return
	}
	return *v, true
}

// OldContactLevel returns the old "contact_level" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldContactLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactLevel: %w", err)
	}
	return oldValue.ContactLevel, nil
}

// AddContactLevel adds i to the "contact_level" field.
func (m *ContactMutation) AddContactLevel(i int) {
	if m.addcontact_level != nil {
		*m.addcontact_level += i
	} else {
		m.addcontact_level = &i
	}
}

// AddedContactLevel returns the value that was added to the "contact_level" field in this mutation.
func (m *ContactMutation) AddedContactLevel() (r int, exists bool) {
	v := m.addcontact_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetContactLevel resets all changes to the "contact_level" field.
func (m *ContactMutation) ResetContactLevel() {
	m.contact_level = nil
	m.addcontact_level = nil
}

// SetContactLevelName sets the "contact_level_name" field.
func (m *ContactMutation) SetContactLevelName(s string) {
	m.contact_level_name = &s
}

// ContactLevelName returns the value of the "contact_level_name" field in the mutation.
func (m *ContactMutation) ContactLevelName() (r string, exists bool) {
	v := m.contact_level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactLevelName returns the old "contact_level_name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldContactLevelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactLevelName: %w", err)
	}
	return oldValue.ContactLevelName, nil
}

// ResetContactLevelName resets all changes to the "contact_level_name" field.
func (m *ContactMutation) ResetContactLevelName() {
	m.contact_level_name = nil
}

// SetGroupContactID sets the "group_contact_id" field.
func (m *ContactMutation) SetGroupContactID(i int) {
	m.group_contact = &i
}

// GroupContactID returns the value of the "group_contact_id" field in the mutation.
func (m *ContactMutation) GroupContactID() (r int, exists bool) {
	v := m.group_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupContactID returns the old "group_contact_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldGroupContactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupContactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupContactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupContactID: %w", err)
	}
	return oldValue.GroupContactID, nil
}

// ClearGroupContactID clears the value of the "group_contact_id" field.
func (m *ContactMutation) ClearGroupContactID() {
	m.group_contact = nil
	m.clearedFields[contact.FieldGroupContactID] = struct{}{}
}

// GroupContactIDCleared returns if the "group_contact_id" field was cleared in this mutation.
func (m *ContactMutation) GroupContactIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldGroupContactID]
	return ok
}

// ResetGroupContactID resets all changes to the "group_contact_id" field.
func (m *ContactMutation) ResetGroupContactID() {
	m.group_contact = nil
	delete(m.clearedFields, contact.FieldGroupContactID)
}

// SetApplyToAllGroupMember sets the "apply_to_all_group_member" field.
func (m *ContactMutation) SetApplyToAllGroupMember(b bool) {
	m.apply_to_all_group_member = &b
}

// ApplyToAllGroupMember returns the value of the "apply_to_all_group_member" field in the mutation.
func (m *ContactMutation) ApplyToAllGroupMember() (r bool, exists bool) {
	v := m.apply_to_all_group_member
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyToAllGroupMember returns the old "apply_to_all_group_member" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldApplyToAllGroupMember(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyToAllGroupMember is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyToAllGroupMember requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyToAllGroupMember: %w", err)
	}
	return oldValue.ApplyToAllGroupMember, nil
}

// ResetApplyToAllGroupMember resets all changes to the "apply_to_all_group_member" field.
func (m *ContactMutation) ResetApplyToAllGroupMember() {
	m.apply_to_all_group_member = nil
}

// SetIsGroupContact sets the "is_group_contact" field.
func (m *ContactMutation) SetIsGroupContact(b bool) {
	m.is_group_contact = &b
}

// IsGroupContact returns the value of the "is_group_contact" field in the mutation.
func (m *ContactMutation) IsGroupContact() (r bool, exists bool) {
	v := m.is_group_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGroupContact returns the old "is_group_contact" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldIsGroupContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGroupContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGroupContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGroupContact: %w", err)
	}
	return oldValue.IsGroupContact, nil
}

// ResetIsGroupContact resets all changes to the "is_group_contact" field.
func (m *ContactMutation) ResetIsGroupContact() {
	m.is_group_contact = nil
}

// SetUseAsDefaultCreateContact sets the "use_as_default_create_contact" field.
func (m *ContactMutation) SetUseAsDefaultCreateContact(b bool) {
	m.use_as_default_create_contact = &b
}

// UseAsDefaultCreateContact returns the value of the "use_as_default_create_contact" field in the mutation.
func (m *ContactMutation) UseAsDefaultCreateContact() (r bool, exists bool) {
	v := m.use_as_default_create_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldUseAsDefaultCreateContact returns the old "use_as_default_create_contact" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUseAsDefaultCreateContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseAsDefaultCreateContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseAsDefaultCreateContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseAsDefaultCreateContact: %w", err)
	}
	return oldValue.UseAsDefaultCreateContact, nil
}

// ResetUseAsDefaultCreateContact resets all changes to the "use_as_default_create_contact" field.
func (m *ContactMutation) ResetUseAsDefaultCreateContact() {
	m.use_as_default_create_contact = nil
}

// SetUseGroupContact sets the "use_group_contact" field.
func (m *ContactMutation) SetUseGroupContact(b bool) {
	m.use_group_contact = &b
}

// UseGroupContact returns the value of the "use_group_contact" field in the mutation.
func (m *ContactMutation) UseGroupContact() (r bool, exists bool) {
	v := m.use_group_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldUseGroupContact returns the old "use_group_contact" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUseGroupContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseGroupContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseGroupContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseGroupContact: %w", err)
	}
	return oldValue.UseGroupContact, nil
}

// ClearUseGroupContact clears the value of the "use_group_contact" field.
func (m *ContactMutation) ClearUseGroupContact() {
	m.use_group_contact = nil
	m.clearedFields[contact.FieldUseGroupContact] = struct{}{}
}

// UseGroupContactCleared returns if the "use_group_contact" field was cleared in this mutation.
func (m *ContactMutation) UseGroupContactCleared() bool {
	_, ok := m.clearedFields[contact.FieldUseGroupContact]
	return ok
}

// ResetUseGroupContact resets all changes to the "use_group_contact" field.
func (m *ContactMutation) ResetUseGroupContact() {
	m.use_group_contact = nil
	delete(m.clearedFields, contact.FieldUseGroupContact)
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *ContactMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[contact.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *ContactMutation) ClinicCleared() bool {
	return m.ClinicIDCleared() || m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *ContactMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *ContactMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[contact.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *ContactMutation) PatientCleared() bool {
	return m.PatientIDCleared() || m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *ContactMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *ContactMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[contact.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *ContactMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *ContactMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddCustomerClinicMappingIDs adds the "customer_clinic_mappings" edge to the CustomerContactOnClinics entity by ids.
func (m *ContactMutation) AddCustomerClinicMappingIDs(ids ...int) {
	if m.customer_clinic_mappings == nil {
		m.customer_clinic_mappings = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_clinic_mappings[ids[i]] = struct{}{}
	}
}

// ClearCustomerClinicMappings clears the "customer_clinic_mappings" edge to the CustomerContactOnClinics entity.
func (m *ContactMutation) ClearCustomerClinicMappings() {
	m.clearedcustomer_clinic_mappings = true
}

// CustomerClinicMappingsCleared reports if the "customer_clinic_mappings" edge to the CustomerContactOnClinics entity was cleared.
func (m *ContactMutation) CustomerClinicMappingsCleared() bool {
	return m.clearedcustomer_clinic_mappings
}

// RemoveCustomerClinicMappingIDs removes the "customer_clinic_mappings" edge to the CustomerContactOnClinics entity by IDs.
func (m *ContactMutation) RemoveCustomerClinicMappingIDs(ids ...int) {
	if m.removedcustomer_clinic_mappings == nil {
		m.removedcustomer_clinic_mappings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_clinic_mappings, ids[i])
		m.removedcustomer_clinic_mappings[ids[i]] = struct{}{}
	}
}

// RemovedCustomerClinicMappings returns the removed IDs of the "customer_clinic_mappings" edge to the CustomerContactOnClinics entity.
func (m *ContactMutation) RemovedCustomerClinicMappingsIDs() (ids []int) {
	for id := range m.removedcustomer_clinic_mappings {
		ids = append(ids, id)
	}
	return
}

// CustomerClinicMappingsIDs returns the "customer_clinic_mappings" edge IDs in the mutation.
func (m *ContactMutation) CustomerClinicMappingsIDs() (ids []int) {
	for id := range m.customer_clinic_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerClinicMappings resets all changes to the "customer_clinic_mappings" edge.
func (m *ContactMutation) ResetCustomerClinicMappings() {
	m.customer_clinic_mappings = nil
	m.clearedcustomer_clinic_mappings = false
	m.removedcustomer_clinic_mappings = nil
}

// AddMemberContactIDs adds the "member_contacts" edge to the Contact entity by ids.
func (m *ContactMutation) AddMemberContactIDs(ids ...int) {
	if m.member_contacts == nil {
		m.member_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.member_contacts[ids[i]] = struct{}{}
	}
}

// ClearMemberContacts clears the "member_contacts" edge to the Contact entity.
func (m *ContactMutation) ClearMemberContacts() {
	m.clearedmember_contacts = true
}

// MemberContactsCleared reports if the "member_contacts" edge to the Contact entity was cleared.
func (m *ContactMutation) MemberContactsCleared() bool {
	return m.clearedmember_contacts
}

// RemoveMemberContactIDs removes the "member_contacts" edge to the Contact entity by IDs.
func (m *ContactMutation) RemoveMemberContactIDs(ids ...int) {
	if m.removedmember_contacts == nil {
		m.removedmember_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.member_contacts, ids[i])
		m.removedmember_contacts[ids[i]] = struct{}{}
	}
}

// RemovedMemberContacts returns the removed IDs of the "member_contacts" edge to the Contact entity.
func (m *ContactMutation) RemovedMemberContactsIDs() (ids []int) {
	for id := range m.removedmember_contacts {
		ids = append(ids, id)
	}
	return
}

// MemberContactsIDs returns the "member_contacts" edge IDs in the mutation.
func (m *ContactMutation) MemberContactsIDs() (ids []int) {
	for id := range m.member_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContacts resets all changes to the "member_contacts" edge.
func (m *ContactMutation) ResetMemberContacts() {
	m.member_contacts = nil
	m.clearedmember_contacts = false
	m.removedmember_contacts = nil
}

// ClearGroupContact clears the "group_contact" edge to the Contact entity.
func (m *ContactMutation) ClearGroupContact() {
	m.clearedgroup_contact = true
	m.clearedFields[contact.FieldGroupContactID] = struct{}{}
}

// GroupContactCleared reports if the "group_contact" edge to the Contact entity was cleared.
func (m *ContactMutation) GroupContactCleared() bool {
	return m.GroupContactIDCleared() || m.clearedgroup_contact
}

// GroupContactIDs returns the "group_contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupContactID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) GroupContactIDs() (ids []int) {
	if id := m.group_contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupContact resets all changes to the "group_contact" edge.
func (m *ContactMutation) ResetGroupContact() {
	m.group_contact = nil
	m.clearedgroup_contact = false
}

// ClearInternalUser clears the "internal_user" edge to the InternalUser entity.
func (m *ContactMutation) ClearInternalUser() {
	m.clearedinternal_user = true
	m.clearedFields[contact.FieldInternalUserID] = struct{}{}
}

// InternalUserCleared reports if the "internal_user" edge to the InternalUser entity was cleared.
func (m *ContactMutation) InternalUserCleared() bool {
	return m.InternalUserIDCleared() || m.clearedinternal_user
}

// InternalUserIDs returns the "internal_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InternalUserID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) InternalUserIDs() (ids []int) {
	if id := m.internal_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInternalUser resets all changes to the "internal_user" edge.
func (m *ContactMutation) ResetInternalUser() {
	m.internal_user = nil
	m.clearedinternal_user = false
}

// AddOrderIDs adds the "orders" edge to the OrderInfo entity by ids.
func (m *ContactMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the OrderInfo entity.
func (m *ContactMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the OrderInfo entity was cleared.
func (m *ContactMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the OrderInfo entity by IDs.
func (m *ContactMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the OrderInfo entity.
func (m *ContactMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ContactMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ContactMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.contact_description != nil {
		fields = append(fields, contact.FieldContactDescription)
	}
	if m.contact_details != nil {
		fields = append(fields, contact.FieldContactDetails)
	}
	if m.contact_type != nil {
		fields = append(fields, contact.FieldContactType)
	}
	if m.is_primary_contact != nil {
		fields = append(fields, contact.FieldIsPrimaryContact)
	}
	if m.is_2fa_contact != nil {
		fields = append(fields, contact.FieldIs2faContact)
	}
	if m.customer != nil {
		fields = append(fields, contact.FieldCustomerID)
	}
	if m.patient != nil {
		fields = append(fields, contact.FieldPatientID)
	}
	if m.clinic != nil {
		fields = append(fields, contact.FieldClinicID)
	}
	if m.internal_user != nil {
		fields = append(fields, contact.FieldInternalUserID)
	}
	if m.user_id != nil {
		fields = append(fields, contact.FieldUserID)
	}
	if m.contact_level != nil {
		fields = append(fields, contact.FieldContactLevel)
	}
	if m.contact_level_name != nil {
		fields = append(fields, contact.FieldContactLevelName)
	}
	if m.group_contact != nil {
		fields = append(fields, contact.FieldGroupContactID)
	}
	if m.apply_to_all_group_member != nil {
		fields = append(fields, contact.FieldApplyToAllGroupMember)
	}
	if m.is_group_contact != nil {
		fields = append(fields, contact.FieldIsGroupContact)
	}
	if m.use_as_default_create_contact != nil {
		fields = append(fields, contact.FieldUseAsDefaultCreateContact)
	}
	if m.use_group_contact != nil {
		fields = append(fields, contact.FieldUseGroupContact)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldContactDescription:
		return m.ContactDescription()
	case contact.FieldContactDetails:
		return m.ContactDetails()
	case contact.FieldContactType:
		return m.ContactType()
	case contact.FieldIsPrimaryContact:
		return m.IsPrimaryContact()
	case contact.FieldIs2faContact:
		return m.Is2faContact()
	case contact.FieldCustomerID:
		return m.CustomerID()
	case contact.FieldPatientID:
		return m.PatientID()
	case contact.FieldClinicID:
		return m.ClinicID()
	case contact.FieldInternalUserID:
		return m.InternalUserID()
	case contact.FieldUserID:
		return m.UserID()
	case contact.FieldContactLevel:
		return m.ContactLevel()
	case contact.FieldContactLevelName:
		return m.ContactLevelName()
	case contact.FieldGroupContactID:
		return m.GroupContactID()
	case contact.FieldApplyToAllGroupMember:
		return m.ApplyToAllGroupMember()
	case contact.FieldIsGroupContact:
		return m.IsGroupContact()
	case contact.FieldUseAsDefaultCreateContact:
		return m.UseAsDefaultCreateContact()
	case contact.FieldUseGroupContact:
		return m.UseGroupContact()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldContactDescription:
		return m.OldContactDescription(ctx)
	case contact.FieldContactDetails:
		return m.OldContactDetails(ctx)
	case contact.FieldContactType:
		return m.OldContactType(ctx)
	case contact.FieldIsPrimaryContact:
		return m.OldIsPrimaryContact(ctx)
	case contact.FieldIs2faContact:
		return m.OldIs2faContact(ctx)
	case contact.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case contact.FieldPatientID:
		return m.OldPatientID(ctx)
	case contact.FieldClinicID:
		return m.OldClinicID(ctx)
	case contact.FieldInternalUserID:
		return m.OldInternalUserID(ctx)
	case contact.FieldUserID:
		return m.OldUserID(ctx)
	case contact.FieldContactLevel:
		return m.OldContactLevel(ctx)
	case contact.FieldContactLevelName:
		return m.OldContactLevelName(ctx)
	case contact.FieldGroupContactID:
		return m.OldGroupContactID(ctx)
	case contact.FieldApplyToAllGroupMember:
		return m.OldApplyToAllGroupMember(ctx)
	case contact.FieldIsGroupContact:
		return m.OldIsGroupContact(ctx)
	case contact.FieldUseAsDefaultCreateContact:
		return m.OldUseAsDefaultCreateContact(ctx)
	case contact.FieldUseGroupContact:
		return m.OldUseGroupContact(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldContactDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactDescription(v)
		return nil
	case contact.FieldContactDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactDetails(v)
		return nil
	case contact.FieldContactType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactType(v)
		return nil
	case contact.FieldIsPrimaryContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimaryContact(v)
		return nil
	case contact.FieldIs2faContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIs2faContact(v)
		return nil
	case contact.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case contact.FieldPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case contact.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case contact.FieldInternalUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserID(v)
		return nil
	case contact.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case contact.FieldContactLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactLevel(v)
		return nil
	case contact.FieldContactLevelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactLevelName(v)
		return nil
	case contact.FieldGroupContactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupContactID(v)
		return nil
	case contact.FieldApplyToAllGroupMember:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyToAllGroupMember(v)
		return nil
	case contact.FieldIsGroupContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGroupContact(v)
		return nil
	case contact.FieldUseAsDefaultCreateContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseAsDefaultCreateContact(v)
		return nil
	case contact.FieldUseGroupContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseGroupContact(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, contact.FieldUserID)
	}
	if m.addcontact_level != nil {
		fields = append(fields, contact.FieldContactLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldUserID:
		return m.AddedUserID()
	case contact.FieldContactLevel:
		return m.AddedContactLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contact.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case contact.FieldContactLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContactLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contact.FieldContactDescription) {
		fields = append(fields, contact.FieldContactDescription)
	}
	if m.FieldCleared(contact.FieldContactType) {
		fields = append(fields, contact.FieldContactType)
	}
	if m.FieldCleared(contact.FieldIsPrimaryContact) {
		fields = append(fields, contact.FieldIsPrimaryContact)
	}
	if m.FieldCleared(contact.FieldCustomerID) {
		fields = append(fields, contact.FieldCustomerID)
	}
	if m.FieldCleared(contact.FieldPatientID) {
		fields = append(fields, contact.FieldPatientID)
	}
	if m.FieldCleared(contact.FieldClinicID) {
		fields = append(fields, contact.FieldClinicID)
	}
	if m.FieldCleared(contact.FieldInternalUserID) {
		fields = append(fields, contact.FieldInternalUserID)
	}
	if m.FieldCleared(contact.FieldUserID) {
		fields = append(fields, contact.FieldUserID)
	}
	if m.FieldCleared(contact.FieldGroupContactID) {
		fields = append(fields, contact.FieldGroupContactID)
	}
	if m.FieldCleared(contact.FieldUseGroupContact) {
		fields = append(fields, contact.FieldUseGroupContact)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	switch name {
	case contact.FieldContactDescription:
		m.ClearContactDescription()
		return nil
	case contact.FieldContactType:
		m.ClearContactType()
		return nil
	case contact.FieldIsPrimaryContact:
		m.ClearIsPrimaryContact()
		return nil
	case contact.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case contact.FieldPatientID:
		m.ClearPatientID()
		return nil
	case contact.FieldClinicID:
		m.ClearClinicID()
		return nil
	case contact.FieldInternalUserID:
		m.ClearInternalUserID()
		return nil
	case contact.FieldUserID:
		m.ClearUserID()
		return nil
	case contact.FieldGroupContactID:
		m.ClearGroupContactID()
		return nil
	case contact.FieldUseGroupContact:
		m.ClearUseGroupContact()
		return nil
	}
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldContactDescription:
		m.ResetContactDescription()
		return nil
	case contact.FieldContactDetails:
		m.ResetContactDetails()
		return nil
	case contact.FieldContactType:
		m.ResetContactType()
		return nil
	case contact.FieldIsPrimaryContact:
		m.ResetIsPrimaryContact()
		return nil
	case contact.FieldIs2faContact:
		m.ResetIs2faContact()
		return nil
	case contact.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case contact.FieldPatientID:
		m.ResetPatientID()
		return nil
	case contact.FieldClinicID:
		m.ResetClinicID()
		return nil
	case contact.FieldInternalUserID:
		m.ResetInternalUserID()
		return nil
	case contact.FieldUserID:
		m.ResetUserID()
		return nil
	case contact.FieldContactLevel:
		m.ResetContactLevel()
		return nil
	case contact.FieldContactLevelName:
		m.ResetContactLevelName()
		return nil
	case contact.FieldGroupContactID:
		m.ResetGroupContactID()
		return nil
	case contact.FieldApplyToAllGroupMember:
		m.ResetApplyToAllGroupMember()
		return nil
	case contact.FieldIsGroupContact:
		m.ResetIsGroupContact()
		return nil
	case contact.FieldUseAsDefaultCreateContact:
		m.ResetUseAsDefaultCreateContact()
		return nil
	case contact.FieldUseGroupContact:
		m.ResetUseGroupContact()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clinic != nil {
		edges = append(edges, contact.EdgeClinic)
	}
	if m.patient != nil {
		edges = append(edges, contact.EdgePatient)
	}
	if m.customer != nil {
		edges = append(edges, contact.EdgeCustomer)
	}
	if m.customer_clinic_mappings != nil {
		edges = append(edges, contact.EdgeCustomerClinicMappings)
	}
	if m.member_contacts != nil {
		edges = append(edges, contact.EdgeMemberContacts)
	}
	if m.group_contact != nil {
		edges = append(edges, contact.EdgeGroupContact)
	}
	if m.internal_user != nil {
		edges = append(edges, contact.EdgeInternalUser)
	}
	if m.orders != nil {
		edges = append(edges, contact.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeCustomerClinicMappings:
		ids := make([]ent.Value, 0, len(m.customer_clinic_mappings))
		for id := range m.customer_clinic_mappings {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeMemberContacts:
		ids := make([]ent.Value, 0, len(m.member_contacts))
		for id := range m.member_contacts {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeGroupContact:
		if id := m.group_contact; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeInternalUser:
		if id := m.internal_user; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcustomer_clinic_mappings != nil {
		edges = append(edges, contact.EdgeCustomerClinicMappings)
	}
	if m.removedmember_contacts != nil {
		edges = append(edges, contact.EdgeMemberContacts)
	}
	if m.removedorders != nil {
		edges = append(edges, contact.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeCustomerClinicMappings:
		ids := make([]ent.Value, 0, len(m.removedcustomer_clinic_mappings))
		for id := range m.removedcustomer_clinic_mappings {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeMemberContacts:
		ids := make([]ent.Value, 0, len(m.removedmember_contacts))
		for id := range m.removedmember_contacts {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedclinic {
		edges = append(edges, contact.EdgeClinic)
	}
	if m.clearedpatient {
		edges = append(edges, contact.EdgePatient)
	}
	if m.clearedcustomer {
		edges = append(edges, contact.EdgeCustomer)
	}
	if m.clearedcustomer_clinic_mappings {
		edges = append(edges, contact.EdgeCustomerClinicMappings)
	}
	if m.clearedmember_contacts {
		edges = append(edges, contact.EdgeMemberContacts)
	}
	if m.clearedgroup_contact {
		edges = append(edges, contact.EdgeGroupContact)
	}
	if m.clearedinternal_user {
		edges = append(edges, contact.EdgeInternalUser)
	}
	if m.clearedorders {
		edges = append(edges, contact.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeClinic:
		return m.clearedclinic
	case contact.EdgePatient:
		return m.clearedpatient
	case contact.EdgeCustomer:
		return m.clearedcustomer
	case contact.EdgeCustomerClinicMappings:
		return m.clearedcustomer_clinic_mappings
	case contact.EdgeMemberContacts:
		return m.clearedmember_contacts
	case contact.EdgeGroupContact:
		return m.clearedgroup_contact
	case contact.EdgeInternalUser:
		return m.clearedinternal_user
	case contact.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeClinic:
		m.ClearClinic()
		return nil
	case contact.EdgePatient:
		m.ClearPatient()
		return nil
	case contact.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case contact.EdgeGroupContact:
		m.ClearGroupContact()
		return nil
	case contact.EdgeInternalUser:
		m.ClearInternalUser()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeClinic:
		m.ResetClinic()
		return nil
	case contact.EdgePatient:
		m.ResetPatient()
		return nil
	case contact.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case contact.EdgeCustomerClinicMappings:
		m.ResetCustomerClinicMappings()
		return nil
	case contact.EdgeMemberContacts:
		m.ResetMemberContacts()
		return nil
	case contact.EdgeGroupContact:
		m.ResetGroupContact()
		return nil
	case contact.EdgeInternalUser:
		m.ResetInternalUser()
		return nil
	case contact.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// CountryListMutation represents an operation that mutates the CountryList nodes in the graph.
type CountryListMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	country_name            *string
	alpha_2_code            *string
	alpha_3_code            *string
	country_code_enum       *string
	iso                     *string
	country_region          *string
	country_subregion       *string
	country_region_code     *string
	country_sub_region_code *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*CountryList, error)
	predicates              []predicate.CountryList
}

var _ ent.Mutation = (*CountryListMutation)(nil)

// countrylistOption allows management of the mutation configuration using functional options.
type countrylistOption func(*CountryListMutation)

// newCountryListMutation creates new mutation for the CountryList entity.
func newCountryListMutation(c config, op Op, opts ...countrylistOption) *CountryListMutation {
	m := &CountryListMutation{
		config:        c,
		op:            op,
		typ:           TypeCountryList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryListID sets the ID field of the mutation.
func withCountryListID(id int) countrylistOption {
	return func(m *CountryListMutation) {
		var (
			err   error
			once  sync.Once
			value *CountryList
		)
		m.oldValue = func(ctx context.Context) (*CountryList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CountryList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountryList sets the old CountryList of the mutation.
func withCountryList(node *CountryList) countrylistOption {
	return func(m *CountryListMutation) {
		m.oldValue = func(context.Context) (*CountryList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CountryList entities.
func (m *CountryListMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CountryList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountryName sets the "country_name" field.
func (m *CountryListMutation) SetCountryName(s string) {
	m.country_name = &s
}

// CountryName returns the value of the "country_name" field in the mutation.
func (m *CountryListMutation) CountryName() (r string, exists bool) {
	v := m.country_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryName returns the old "country_name" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryName: %w", err)
	}
	return oldValue.CountryName, nil
}

// ResetCountryName resets all changes to the "country_name" field.
func (m *CountryListMutation) ResetCountryName() {
	m.country_name = nil
}

// SetAlpha2Code sets the "alpha_2_code" field.
func (m *CountryListMutation) SetAlpha2Code(s string) {
	m.alpha_2_code = &s
}

// Alpha2Code returns the value of the "alpha_2_code" field in the mutation.
func (m *CountryListMutation) Alpha2Code() (r string, exists bool) {
	v := m.alpha_2_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAlpha2Code returns the old "alpha_2_code" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldAlpha2Code(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlpha2Code is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlpha2Code requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlpha2Code: %w", err)
	}
	return oldValue.Alpha2Code, nil
}

// ResetAlpha2Code resets all changes to the "alpha_2_code" field.
func (m *CountryListMutation) ResetAlpha2Code() {
	m.alpha_2_code = nil
}

// SetAlpha3Code sets the "alpha_3_code" field.
func (m *CountryListMutation) SetAlpha3Code(s string) {
	m.alpha_3_code = &s
}

// Alpha3Code returns the value of the "alpha_3_code" field in the mutation.
func (m *CountryListMutation) Alpha3Code() (r string, exists bool) {
	v := m.alpha_3_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAlpha3Code returns the old "alpha_3_code" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldAlpha3Code(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlpha3Code is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlpha3Code requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlpha3Code: %w", err)
	}
	return oldValue.Alpha3Code, nil
}

// ResetAlpha3Code resets all changes to the "alpha_3_code" field.
func (m *CountryListMutation) ResetAlpha3Code() {
	m.alpha_3_code = nil
}

// SetCountryCodeEnum sets the "country_code_enum" field.
func (m *CountryListMutation) SetCountryCodeEnum(s string) {
	m.country_code_enum = &s
}

// CountryCodeEnum returns the value of the "country_code_enum" field in the mutation.
func (m *CountryListMutation) CountryCodeEnum() (r string, exists bool) {
	v := m.country_code_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCodeEnum returns the old "country_code_enum" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountryCodeEnum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCodeEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCodeEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCodeEnum: %w", err)
	}
	return oldValue.CountryCodeEnum, nil
}

// ResetCountryCodeEnum resets all changes to the "country_code_enum" field.
func (m *CountryListMutation) ResetCountryCodeEnum() {
	m.country_code_enum = nil
}

// SetIso sets the "iso" field.
func (m *CountryListMutation) SetIso(s string) {
	m.iso = &s
}

// Iso returns the value of the "iso" field in the mutation.
func (m *CountryListMutation) Iso() (r string, exists bool) {
	v := m.iso
	if v == nil {
		return
	}
	return *v, true
}

// OldIso returns the old "iso" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldIso(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIso is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIso requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIso: %w", err)
	}
	return oldValue.Iso, nil
}

// ResetIso resets all changes to the "iso" field.
func (m *CountryListMutation) ResetIso() {
	m.iso = nil
}

// SetCountryRegion sets the "country_region" field.
func (m *CountryListMutation) SetCountryRegion(s string) {
	m.country_region = &s
}

// CountryRegion returns the value of the "country_region" field in the mutation.
func (m *CountryListMutation) CountryRegion() (r string, exists bool) {
	v := m.country_region
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryRegion returns the old "country_region" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountryRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryRegion: %w", err)
	}
	return oldValue.CountryRegion, nil
}

// ResetCountryRegion resets all changes to the "country_region" field.
func (m *CountryListMutation) ResetCountryRegion() {
	m.country_region = nil
}

// SetCountrySubregion sets the "country_subregion" field.
func (m *CountryListMutation) SetCountrySubregion(s string) {
	m.country_subregion = &s
}

// CountrySubregion returns the value of the "country_subregion" field in the mutation.
func (m *CountryListMutation) CountrySubregion() (r string, exists bool) {
	v := m.country_subregion
	if v == nil {
		return
	}
	return *v, true
}

// OldCountrySubregion returns the old "country_subregion" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountrySubregion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountrySubregion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountrySubregion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountrySubregion: %w", err)
	}
	return oldValue.CountrySubregion, nil
}

// ResetCountrySubregion resets all changes to the "country_subregion" field.
func (m *CountryListMutation) ResetCountrySubregion() {
	m.country_subregion = nil
}

// SetCountryRegionCode sets the "country_region_code" field.
func (m *CountryListMutation) SetCountryRegionCode(s string) {
	m.country_region_code = &s
}

// CountryRegionCode returns the value of the "country_region_code" field in the mutation.
func (m *CountryListMutation) CountryRegionCode() (r string, exists bool) {
	v := m.country_region_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryRegionCode returns the old "country_region_code" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountryRegionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryRegionCode: %w", err)
	}
	return oldValue.CountryRegionCode, nil
}

// ResetCountryRegionCode resets all changes to the "country_region_code" field.
func (m *CountryListMutation) ResetCountryRegionCode() {
	m.country_region_code = nil
}

// SetCountrySubRegionCode sets the "country_sub_region_code" field.
func (m *CountryListMutation) SetCountrySubRegionCode(s string) {
	m.country_sub_region_code = &s
}

// CountrySubRegionCode returns the value of the "country_sub_region_code" field in the mutation.
func (m *CountryListMutation) CountrySubRegionCode() (r string, exists bool) {
	v := m.country_sub_region_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountrySubRegionCode returns the old "country_sub_region_code" field's value of the CountryList entity.
// If the CountryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryListMutation) OldCountrySubRegionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountrySubRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountrySubRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountrySubRegionCode: %w", err)
	}
	return oldValue.CountrySubRegionCode, nil
}

// ResetCountrySubRegionCode resets all changes to the "country_sub_region_code" field.
func (m *CountryListMutation) ResetCountrySubRegionCode() {
	m.country_sub_region_code = nil
}

// Where appends a list predicates to the CountryListMutation builder.
func (m *CountryListMutation) Where(ps ...predicate.CountryList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CountryList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CountryList).
func (m *CountryListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryListMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.country_name != nil {
		fields = append(fields, countrylist.FieldCountryName)
	}
	if m.alpha_2_code != nil {
		fields = append(fields, countrylist.FieldAlpha2Code)
	}
	if m.alpha_3_code != nil {
		fields = append(fields, countrylist.FieldAlpha3Code)
	}
	if m.country_code_enum != nil {
		fields = append(fields, countrylist.FieldCountryCodeEnum)
	}
	if m.iso != nil {
		fields = append(fields, countrylist.FieldIso)
	}
	if m.country_region != nil {
		fields = append(fields, countrylist.FieldCountryRegion)
	}
	if m.country_subregion != nil {
		fields = append(fields, countrylist.FieldCountrySubregion)
	}
	if m.country_region_code != nil {
		fields = append(fields, countrylist.FieldCountryRegionCode)
	}
	if m.country_sub_region_code != nil {
		fields = append(fields, countrylist.FieldCountrySubRegionCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case countrylist.FieldCountryName:
		return m.CountryName()
	case countrylist.FieldAlpha2Code:
		return m.Alpha2Code()
	case countrylist.FieldAlpha3Code:
		return m.Alpha3Code()
	case countrylist.FieldCountryCodeEnum:
		return m.CountryCodeEnum()
	case countrylist.FieldIso:
		return m.Iso()
	case countrylist.FieldCountryRegion:
		return m.CountryRegion()
	case countrylist.FieldCountrySubregion:
		return m.CountrySubregion()
	case countrylist.FieldCountryRegionCode:
		return m.CountryRegionCode()
	case countrylist.FieldCountrySubRegionCode:
		return m.CountrySubRegionCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case countrylist.FieldCountryName:
		return m.OldCountryName(ctx)
	case countrylist.FieldAlpha2Code:
		return m.OldAlpha2Code(ctx)
	case countrylist.FieldAlpha3Code:
		return m.OldAlpha3Code(ctx)
	case countrylist.FieldCountryCodeEnum:
		return m.OldCountryCodeEnum(ctx)
	case countrylist.FieldIso:
		return m.OldIso(ctx)
	case countrylist.FieldCountryRegion:
		return m.OldCountryRegion(ctx)
	case countrylist.FieldCountrySubregion:
		return m.OldCountrySubregion(ctx)
	case countrylist.FieldCountryRegionCode:
		return m.OldCountryRegionCode(ctx)
	case countrylist.FieldCountrySubRegionCode:
		return m.OldCountrySubRegionCode(ctx)
	}
	return nil, fmt.Errorf("unknown CountryList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case countrylist.FieldCountryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryName(v)
		return nil
	case countrylist.FieldAlpha2Code:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlpha2Code(v)
		return nil
	case countrylist.FieldAlpha3Code:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlpha3Code(v)
		return nil
	case countrylist.FieldCountryCodeEnum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCodeEnum(v)
		return nil
	case countrylist.FieldIso:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIso(v)
		return nil
	case countrylist.FieldCountryRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryRegion(v)
		return nil
	case countrylist.FieldCountrySubregion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountrySubregion(v)
		return nil
	case countrylist.FieldCountryRegionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryRegionCode(v)
		return nil
	case countrylist.FieldCountrySubRegionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountrySubRegionCode(v)
		return nil
	}
	return fmt.Errorf("unknown CountryList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CountryList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CountryList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryListMutation) ResetField(name string) error {
	switch name {
	case countrylist.FieldCountryName:
		m.ResetCountryName()
		return nil
	case countrylist.FieldAlpha2Code:
		m.ResetAlpha2Code()
		return nil
	case countrylist.FieldAlpha3Code:
		m.ResetAlpha3Code()
		return nil
	case countrylist.FieldCountryCodeEnum:
		m.ResetCountryCodeEnum()
		return nil
	case countrylist.FieldIso:
		m.ResetIso()
		return nil
	case countrylist.FieldCountryRegion:
		m.ResetCountryRegion()
		return nil
	case countrylist.FieldCountrySubregion:
		m.ResetCountrySubregion()
		return nil
	case countrylist.FieldCountryRegionCode:
		m.ResetCountryRegionCode()
		return nil
	case countrylist.FieldCountrySubRegionCode:
		m.ResetCountrySubRegionCode()
		return nil
	}
	return fmt.Errorf("unknown CountryList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CountryList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CountryList edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	customer_type                               *string
	customer_first_name                         *string
	customer_last_name                          *string
	customer_middle_name                        *string
	customer_type_id                            *string
	customer_suffix                             *string
	customer_samples_received                   *string
	customer_request_submit_time                *time.Time
	customer_signup_time                        *time.Time
	is_active                                   *bool
	customer_npi_number                         *string
	referral_source                             *string
	order_placement_allowed                     *bool
	beta_program_enabled                        *bool
	onboarding_questionnaire_filled_on          *time.Time
	clearedFields                               map[string]struct{}
	samples                                     map[int]struct{}
	removedsamples                              map[int]struct{}
	clearedsamples                              bool
	customer_contacts                           map[int]struct{}
	removedcustomer_contacts                    map[int]struct{}
	clearedcustomer_contacts                    bool
	customer_addresses                          map[int]struct{}
	removedcustomer_addresses                   map[int]struct{}
	clearedcustomer_addresses                   bool
	clinics                                     map[int]struct{}
	removedclinics                              map[int]struct{}
	clearedclinics                              bool
	sales                                       *int
	clearedsales                                bool
	user                                        *int
	cleareduser                                 bool
	orders                                      map[int]struct{}
	removedorders                               map[int]struct{}
	clearedorders                               bool
	current_patients                            map[int]struct{}
	removedcurrent_patients                     map[int]struct{}
	clearedcurrent_patients                     bool
	patients                                    map[int]struct{}
	removedpatients                             map[int]struct{}
	clearedpatients                             bool
	customer_beta_program_participations        map[int]struct{}
	removedcustomer_beta_program_participations map[int]struct{}
	clearedcustomer_beta_program_participations bool
	customer_settings_on_clinics                map[int]struct{}
	removedcustomer_settings_on_clinics         map[int]struct{}
	clearedcustomer_settings_on_clinics         bool
	customer_addresses_on_clinics               map[int]struct{}
	removedcustomer_addresses_on_clinics        map[int]struct{}
	clearedcustomer_addresses_on_clinics        bool
	customer_contacts_on_clinics                map[int]struct{}
	removedcustomer_contacts_on_clinics         map[int]struct{}
	clearedcustomer_contacts_on_clinics         bool
	done                                        bool
	oldValue                                    func(context.Context) (*Customer, error)
	predicates                                  []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CustomerMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CustomerMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CustomerMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[customer.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CustomerMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CustomerMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, customer.FieldUserID)
}

// SetCustomerType sets the "customer_type" field.
func (m *CustomerMutation) SetCustomerType(s string) {
	m.customer_type = &s
}

// CustomerType returns the value of the "customer_type" field in the mutation.
func (m *CustomerMutation) CustomerType() (r string, exists bool) {
	v := m.customer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerType returns the old "customer_type" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerType: %w", err)
	}
	return oldValue.CustomerType, nil
}

// ResetCustomerType resets all changes to the "customer_type" field.
func (m *CustomerMutation) ResetCustomerType() {
	m.customer_type = nil
}

// SetCustomerFirstName sets the "customer_first_name" field.
func (m *CustomerMutation) SetCustomerFirstName(s string) {
	m.customer_first_name = &s
}

// CustomerFirstName returns the value of the "customer_first_name" field in the mutation.
func (m *CustomerMutation) CustomerFirstName() (r string, exists bool) {
	v := m.customer_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerFirstName returns the old "customer_first_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerFirstName: %w", err)
	}
	return oldValue.CustomerFirstName, nil
}

// ClearCustomerFirstName clears the value of the "customer_first_name" field.
func (m *CustomerMutation) ClearCustomerFirstName() {
	m.customer_first_name = nil
	m.clearedFields[customer.FieldCustomerFirstName] = struct{}{}
}

// CustomerFirstNameCleared returns if the "customer_first_name" field was cleared in this mutation.
func (m *CustomerMutation) CustomerFirstNameCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerFirstName]
	return ok
}

// ResetCustomerFirstName resets all changes to the "customer_first_name" field.
func (m *CustomerMutation) ResetCustomerFirstName() {
	m.customer_first_name = nil
	delete(m.clearedFields, customer.FieldCustomerFirstName)
}

// SetCustomerLastName sets the "customer_last_name" field.
func (m *CustomerMutation) SetCustomerLastName(s string) {
	m.customer_last_name = &s
}

// CustomerLastName returns the value of the "customer_last_name" field in the mutation.
func (m *CustomerMutation) CustomerLastName() (r string, exists bool) {
	v := m.customer_last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerLastName returns the old "customer_last_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerLastName: %w", err)
	}
	return oldValue.CustomerLastName, nil
}

// ClearCustomerLastName clears the value of the "customer_last_name" field.
func (m *CustomerMutation) ClearCustomerLastName() {
	m.customer_last_name = nil
	m.clearedFields[customer.FieldCustomerLastName] = struct{}{}
}

// CustomerLastNameCleared returns if the "customer_last_name" field was cleared in this mutation.
func (m *CustomerMutation) CustomerLastNameCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerLastName]
	return ok
}

// ResetCustomerLastName resets all changes to the "customer_last_name" field.
func (m *CustomerMutation) ResetCustomerLastName() {
	m.customer_last_name = nil
	delete(m.clearedFields, customer.FieldCustomerLastName)
}

// SetCustomerMiddleName sets the "customer_middle_name" field.
func (m *CustomerMutation) SetCustomerMiddleName(s string) {
	m.customer_middle_name = &s
}

// CustomerMiddleName returns the value of the "customer_middle_name" field in the mutation.
func (m *CustomerMutation) CustomerMiddleName() (r string, exists bool) {
	v := m.customer_middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerMiddleName returns the old "customer_middle_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerMiddleName: %w", err)
	}
	return oldValue.CustomerMiddleName, nil
}

// ClearCustomerMiddleName clears the value of the "customer_middle_name" field.
func (m *CustomerMutation) ClearCustomerMiddleName() {
	m.customer_middle_name = nil
	m.clearedFields[customer.FieldCustomerMiddleName] = struct{}{}
}

// CustomerMiddleNameCleared returns if the "customer_middle_name" field was cleared in this mutation.
func (m *CustomerMutation) CustomerMiddleNameCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerMiddleName]
	return ok
}

// ResetCustomerMiddleName resets all changes to the "customer_middle_name" field.
func (m *CustomerMutation) ResetCustomerMiddleName() {
	m.customer_middle_name = nil
	delete(m.clearedFields, customer.FieldCustomerMiddleName)
}

// SetCustomerTypeID sets the "customer_type_id" field.
func (m *CustomerMutation) SetCustomerTypeID(s string) {
	m.customer_type_id = &s
}

// CustomerTypeID returns the value of the "customer_type_id" field in the mutation.
func (m *CustomerMutation) CustomerTypeID() (r string, exists bool) {
	v := m.customer_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerTypeID returns the old "customer_type_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerTypeID: %w", err)
	}
	return oldValue.CustomerTypeID, nil
}

// ClearCustomerTypeID clears the value of the "customer_type_id" field.
func (m *CustomerMutation) ClearCustomerTypeID() {
	m.customer_type_id = nil
	m.clearedFields[customer.FieldCustomerTypeID] = struct{}{}
}

// CustomerTypeIDCleared returns if the "customer_type_id" field was cleared in this mutation.
func (m *CustomerMutation) CustomerTypeIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerTypeID]
	return ok
}

// ResetCustomerTypeID resets all changes to the "customer_type_id" field.
func (m *CustomerMutation) ResetCustomerTypeID() {
	m.customer_type_id = nil
	delete(m.clearedFields, customer.FieldCustomerTypeID)
}

// SetCustomerSuffix sets the "customer_suffix" field.
func (m *CustomerMutation) SetCustomerSuffix(s string) {
	m.customer_suffix = &s
}

// CustomerSuffix returns the value of the "customer_suffix" field in the mutation.
func (m *CustomerMutation) CustomerSuffix() (r string, exists bool) {
	v := m.customer_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerSuffix returns the old "customer_suffix" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerSuffix: %w", err)
	}
	return oldValue.CustomerSuffix, nil
}

// ClearCustomerSuffix clears the value of the "customer_suffix" field.
func (m *CustomerMutation) ClearCustomerSuffix() {
	m.customer_suffix = nil
	m.clearedFields[customer.FieldCustomerSuffix] = struct{}{}
}

// CustomerSuffixCleared returns if the "customer_suffix" field was cleared in this mutation.
func (m *CustomerMutation) CustomerSuffixCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerSuffix]
	return ok
}

// ResetCustomerSuffix resets all changes to the "customer_suffix" field.
func (m *CustomerMutation) ResetCustomerSuffix() {
	m.customer_suffix = nil
	delete(m.clearedFields, customer.FieldCustomerSuffix)
}

// SetCustomerSamplesReceived sets the "customer_samples_received" field.
func (m *CustomerMutation) SetCustomerSamplesReceived(s string) {
	m.customer_samples_received = &s
}

// CustomerSamplesReceived returns the value of the "customer_samples_received" field in the mutation.
func (m *CustomerMutation) CustomerSamplesReceived() (r string, exists bool) {
	v := m.customer_samples_received
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerSamplesReceived returns the old "customer_samples_received" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerSamplesReceived(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerSamplesReceived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerSamplesReceived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerSamplesReceived: %w", err)
	}
	return oldValue.CustomerSamplesReceived, nil
}

// ClearCustomerSamplesReceived clears the value of the "customer_samples_received" field.
func (m *CustomerMutation) ClearCustomerSamplesReceived() {
	m.customer_samples_received = nil
	m.clearedFields[customer.FieldCustomerSamplesReceived] = struct{}{}
}

// CustomerSamplesReceivedCleared returns if the "customer_samples_received" field was cleared in this mutation.
func (m *CustomerMutation) CustomerSamplesReceivedCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerSamplesReceived]
	return ok
}

// ResetCustomerSamplesReceived resets all changes to the "customer_samples_received" field.
func (m *CustomerMutation) ResetCustomerSamplesReceived() {
	m.customer_samples_received = nil
	delete(m.clearedFields, customer.FieldCustomerSamplesReceived)
}

// SetCustomerRequestSubmitTime sets the "customer_request_submit_time" field.
func (m *CustomerMutation) SetCustomerRequestSubmitTime(t time.Time) {
	m.customer_request_submit_time = &t
}

// CustomerRequestSubmitTime returns the value of the "customer_request_submit_time" field in the mutation.
func (m *CustomerMutation) CustomerRequestSubmitTime() (r time.Time, exists bool) {
	v := m.customer_request_submit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRequestSubmitTime returns the old "customer_request_submit_time" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerRequestSubmitTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRequestSubmitTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRequestSubmitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRequestSubmitTime: %w", err)
	}
	return oldValue.CustomerRequestSubmitTime, nil
}

// ClearCustomerRequestSubmitTime clears the value of the "customer_request_submit_time" field.
func (m *CustomerMutation) ClearCustomerRequestSubmitTime() {
	m.customer_request_submit_time = nil
	m.clearedFields[customer.FieldCustomerRequestSubmitTime] = struct{}{}
}

// CustomerRequestSubmitTimeCleared returns if the "customer_request_submit_time" field was cleared in this mutation.
func (m *CustomerMutation) CustomerRequestSubmitTimeCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerRequestSubmitTime]
	return ok
}

// ResetCustomerRequestSubmitTime resets all changes to the "customer_request_submit_time" field.
func (m *CustomerMutation) ResetCustomerRequestSubmitTime() {
	m.customer_request_submit_time = nil
	delete(m.clearedFields, customer.FieldCustomerRequestSubmitTime)
}

// SetCustomerSignupTime sets the "customer_signup_time" field.
func (m *CustomerMutation) SetCustomerSignupTime(t time.Time) {
	m.customer_signup_time = &t
}

// CustomerSignupTime returns the value of the "customer_signup_time" field in the mutation.
func (m *CustomerMutation) CustomerSignupTime() (r time.Time, exists bool) {
	v := m.customer_signup_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerSignupTime returns the old "customer_signup_time" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerSignupTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerSignupTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerSignupTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerSignupTime: %w", err)
	}
	return oldValue.CustomerSignupTime, nil
}

// ClearCustomerSignupTime clears the value of the "customer_signup_time" field.
func (m *CustomerMutation) ClearCustomerSignupTime() {
	m.customer_signup_time = nil
	m.clearedFields[customer.FieldCustomerSignupTime] = struct{}{}
}

// CustomerSignupTimeCleared returns if the "customer_signup_time" field was cleared in this mutation.
func (m *CustomerMutation) CustomerSignupTimeCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerSignupTime]
	return ok
}

// ResetCustomerSignupTime resets all changes to the "customer_signup_time" field.
func (m *CustomerMutation) ResetCustomerSignupTime() {
	m.customer_signup_time = nil
	delete(m.clearedFields, customer.FieldCustomerSignupTime)
}

// SetIsActive sets the "is_active" field.
func (m *CustomerMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CustomerMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CustomerMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSalesID sets the "sales_id" field.
func (m *CustomerMutation) SetSalesID(i int) {
	m.sales = &i
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *CustomerMutation) SalesID() (r int, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldSalesID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *CustomerMutation) ClearSalesID() {
	m.sales = nil
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *CustomerMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *CustomerMutation) ResetSalesID() {
	m.sales = nil
	delete(m.clearedFields, customer.FieldSalesID)
}

// SetCustomerNpiNumber sets the "customer_npi_number" field.
func (m *CustomerMutation) SetCustomerNpiNumber(s string) {
	m.customer_npi_number = &s
}

// CustomerNpiNumber returns the value of the "customer_npi_number" field in the mutation.
func (m *CustomerMutation) CustomerNpiNumber() (r string, exists bool) {
	v := m.customer_npi_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerNpiNumber returns the old "customer_npi_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCustomerNpiNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerNpiNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerNpiNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerNpiNumber: %w", err)
	}
	return oldValue.CustomerNpiNumber, nil
}

// ClearCustomerNpiNumber clears the value of the "customer_npi_number" field.
func (m *CustomerMutation) ClearCustomerNpiNumber() {
	m.customer_npi_number = nil
	m.clearedFields[customer.FieldCustomerNpiNumber] = struct{}{}
}

// CustomerNpiNumberCleared returns if the "customer_npi_number" field was cleared in this mutation.
func (m *CustomerMutation) CustomerNpiNumberCleared() bool {
	_, ok := m.clearedFields[customer.FieldCustomerNpiNumber]
	return ok
}

// ResetCustomerNpiNumber resets all changes to the "customer_npi_number" field.
func (m *CustomerMutation) ResetCustomerNpiNumber() {
	m.customer_npi_number = nil
	delete(m.clearedFields, customer.FieldCustomerNpiNumber)
}

// SetReferralSource sets the "referral_source" field.
func (m *CustomerMutation) SetReferralSource(s string) {
	m.referral_source = &s
}

// ReferralSource returns the value of the "referral_source" field in the mutation.
func (m *CustomerMutation) ReferralSource() (r string, exists bool) {
	v := m.referral_source
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralSource returns the old "referral_source" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldReferralSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralSource: %w", err)
	}
	return oldValue.ReferralSource, nil
}

// ClearReferralSource clears the value of the "referral_source" field.
func (m *CustomerMutation) ClearReferralSource() {
	m.referral_source = nil
	m.clearedFields[customer.FieldReferralSource] = struct{}{}
}

// ReferralSourceCleared returns if the "referral_source" field was cleared in this mutation.
func (m *CustomerMutation) ReferralSourceCleared() bool {
	_, ok := m.clearedFields[customer.FieldReferralSource]
	return ok
}

// ResetReferralSource resets all changes to the "referral_source" field.
func (m *CustomerMutation) ResetReferralSource() {
	m.referral_source = nil
	delete(m.clearedFields, customer.FieldReferralSource)
}

// SetOrderPlacementAllowed sets the "order_placement_allowed" field.
func (m *CustomerMutation) SetOrderPlacementAllowed(b bool) {
	m.order_placement_allowed = &b
}

// OrderPlacementAllowed returns the value of the "order_placement_allowed" field in the mutation.
func (m *CustomerMutation) OrderPlacementAllowed() (r bool, exists bool) {
	v := m.order_placement_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPlacementAllowed returns the old "order_placement_allowed" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOrderPlacementAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderPlacementAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderPlacementAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPlacementAllowed: %w", err)
	}
	return oldValue.OrderPlacementAllowed, nil
}

// ClearOrderPlacementAllowed clears the value of the "order_placement_allowed" field.
func (m *CustomerMutation) ClearOrderPlacementAllowed() {
	m.order_placement_allowed = nil
	m.clearedFields[customer.FieldOrderPlacementAllowed] = struct{}{}
}

// OrderPlacementAllowedCleared returns if the "order_placement_allowed" field was cleared in this mutation.
func (m *CustomerMutation) OrderPlacementAllowedCleared() bool {
	_, ok := m.clearedFields[customer.FieldOrderPlacementAllowed]
	return ok
}

// ResetOrderPlacementAllowed resets all changes to the "order_placement_allowed" field.
func (m *CustomerMutation) ResetOrderPlacementAllowed() {
	m.order_placement_allowed = nil
	delete(m.clearedFields, customer.FieldOrderPlacementAllowed)
}

// SetBetaProgramEnabled sets the "beta_program_enabled" field.
func (m *CustomerMutation) SetBetaProgramEnabled(b bool) {
	m.beta_program_enabled = &b
}

// BetaProgramEnabled returns the value of the "beta_program_enabled" field in the mutation.
func (m *CustomerMutation) BetaProgramEnabled() (r bool, exists bool) {
	v := m.beta_program_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldBetaProgramEnabled returns the old "beta_program_enabled" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBetaProgramEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetaProgramEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetaProgramEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetaProgramEnabled: %w", err)
	}
	return oldValue.BetaProgramEnabled, nil
}

// ClearBetaProgramEnabled clears the value of the "beta_program_enabled" field.
func (m *CustomerMutation) ClearBetaProgramEnabled() {
	m.beta_program_enabled = nil
	m.clearedFields[customer.FieldBetaProgramEnabled] = struct{}{}
}

// BetaProgramEnabledCleared returns if the "beta_program_enabled" field was cleared in this mutation.
func (m *CustomerMutation) BetaProgramEnabledCleared() bool {
	_, ok := m.clearedFields[customer.FieldBetaProgramEnabled]
	return ok
}

// ResetBetaProgramEnabled resets all changes to the "beta_program_enabled" field.
func (m *CustomerMutation) ResetBetaProgramEnabled() {
	m.beta_program_enabled = nil
	delete(m.clearedFields, customer.FieldBetaProgramEnabled)
}

// SetOnboardingQuestionnaireFilledOn sets the "onboarding_questionnaire_filled_on" field.
func (m *CustomerMutation) SetOnboardingQuestionnaireFilledOn(t time.Time) {
	m.onboarding_questionnaire_filled_on = &t
}

// OnboardingQuestionnaireFilledOn returns the value of the "onboarding_questionnaire_filled_on" field in the mutation.
func (m *CustomerMutation) OnboardingQuestionnaireFilledOn() (r time.Time, exists bool) {
	v := m.onboarding_questionnaire_filled_on
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingQuestionnaireFilledOn returns the old "onboarding_questionnaire_filled_on" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOnboardingQuestionnaireFilledOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingQuestionnaireFilledOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingQuestionnaireFilledOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingQuestionnaireFilledOn: %w", err)
	}
	return oldValue.OnboardingQuestionnaireFilledOn, nil
}

// ClearOnboardingQuestionnaireFilledOn clears the value of the "onboarding_questionnaire_filled_on" field.
func (m *CustomerMutation) ClearOnboardingQuestionnaireFilledOn() {
	m.onboarding_questionnaire_filled_on = nil
	m.clearedFields[customer.FieldOnboardingQuestionnaireFilledOn] = struct{}{}
}

// OnboardingQuestionnaireFilledOnCleared returns if the "onboarding_questionnaire_filled_on" field was cleared in this mutation.
func (m *CustomerMutation) OnboardingQuestionnaireFilledOnCleared() bool {
	_, ok := m.clearedFields[customer.FieldOnboardingQuestionnaireFilledOn]
	return ok
}

// ResetOnboardingQuestionnaireFilledOn resets all changes to the "onboarding_questionnaire_filled_on" field.
func (m *CustomerMutation) ResetOnboardingQuestionnaireFilledOn() {
	m.onboarding_questionnaire_filled_on = nil
	delete(m.clearedFields, customer.FieldOnboardingQuestionnaireFilledOn)
}

// AddSampleIDs adds the "samples" edge to the Sample entity by ids.
func (m *CustomerMutation) AddSampleIDs(ids ...int) {
	if m.samples == nil {
		m.samples = make(map[int]struct{})
	}
	for i := range ids {
		m.samples[ids[i]] = struct{}{}
	}
}

// ClearSamples clears the "samples" edge to the Sample entity.
func (m *CustomerMutation) ClearSamples() {
	m.clearedsamples = true
}

// SamplesCleared reports if the "samples" edge to the Sample entity was cleared.
func (m *CustomerMutation) SamplesCleared() bool {
	return m.clearedsamples
}

// RemoveSampleIDs removes the "samples" edge to the Sample entity by IDs.
func (m *CustomerMutation) RemoveSampleIDs(ids ...int) {
	if m.removedsamples == nil {
		m.removedsamples = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.samples, ids[i])
		m.removedsamples[ids[i]] = struct{}{}
	}
}

// RemovedSamples returns the removed IDs of the "samples" edge to the Sample entity.
func (m *CustomerMutation) RemovedSamplesIDs() (ids []int) {
	for id := range m.removedsamples {
		ids = append(ids, id)
	}
	return
}

// SamplesIDs returns the "samples" edge IDs in the mutation.
func (m *CustomerMutation) SamplesIDs() (ids []int) {
	for id := range m.samples {
		ids = append(ids, id)
	}
	return
}

// ResetSamples resets all changes to the "samples" edge.
func (m *CustomerMutation) ResetSamples() {
	m.samples = nil
	m.clearedsamples = false
	m.removedsamples = nil
}

// AddCustomerContactIDs adds the "customer_contacts" edge to the Contact entity by ids.
func (m *CustomerMutation) AddCustomerContactIDs(ids ...int) {
	if m.customer_contacts == nil {
		m.customer_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_contacts[ids[i]] = struct{}{}
	}
}

// ClearCustomerContacts clears the "customer_contacts" edge to the Contact entity.
func (m *CustomerMutation) ClearCustomerContacts() {
	m.clearedcustomer_contacts = true
}

// CustomerContactsCleared reports if the "customer_contacts" edge to the Contact entity was cleared.
func (m *CustomerMutation) CustomerContactsCleared() bool {
	return m.clearedcustomer_contacts
}

// RemoveCustomerContactIDs removes the "customer_contacts" edge to the Contact entity by IDs.
func (m *CustomerMutation) RemoveCustomerContactIDs(ids ...int) {
	if m.removedcustomer_contacts == nil {
		m.removedcustomer_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_contacts, ids[i])
		m.removedcustomer_contacts[ids[i]] = struct{}{}
	}
}

// RemovedCustomerContacts returns the removed IDs of the "customer_contacts" edge to the Contact entity.
func (m *CustomerMutation) RemovedCustomerContactsIDs() (ids []int) {
	for id := range m.removedcustomer_contacts {
		ids = append(ids, id)
	}
	return
}

// CustomerContactsIDs returns the "customer_contacts" edge IDs in the mutation.
func (m *CustomerMutation) CustomerContactsIDs() (ids []int) {
	for id := range m.customer_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerContacts resets all changes to the "customer_contacts" edge.
func (m *CustomerMutation) ResetCustomerContacts() {
	m.customer_contacts = nil
	m.clearedcustomer_contacts = false
	m.removedcustomer_contacts = nil
}

// AddCustomerAddressIDs adds the "customer_addresses" edge to the Address entity by ids.
func (m *CustomerMutation) AddCustomerAddressIDs(ids ...int) {
	if m.customer_addresses == nil {
		m.customer_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_addresses[ids[i]] = struct{}{}
	}
}

// ClearCustomerAddresses clears the "customer_addresses" edge to the Address entity.
func (m *CustomerMutation) ClearCustomerAddresses() {
	m.clearedcustomer_addresses = true
}

// CustomerAddressesCleared reports if the "customer_addresses" edge to the Address entity was cleared.
func (m *CustomerMutation) CustomerAddressesCleared() bool {
	return m.clearedcustomer_addresses
}

// RemoveCustomerAddressIDs removes the "customer_addresses" edge to the Address entity by IDs.
func (m *CustomerMutation) RemoveCustomerAddressIDs(ids ...int) {
	if m.removedcustomer_addresses == nil {
		m.removedcustomer_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_addresses, ids[i])
		m.removedcustomer_addresses[ids[i]] = struct{}{}
	}
}

// RemovedCustomerAddresses returns the removed IDs of the "customer_addresses" edge to the Address entity.
func (m *CustomerMutation) RemovedCustomerAddressesIDs() (ids []int) {
	for id := range m.removedcustomer_addresses {
		ids = append(ids, id)
	}
	return
}

// CustomerAddressesIDs returns the "customer_addresses" edge IDs in the mutation.
func (m *CustomerMutation) CustomerAddressesIDs() (ids []int) {
	for id := range m.customer_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerAddresses resets all changes to the "customer_addresses" edge.
func (m *CustomerMutation) ResetCustomerAddresses() {
	m.customer_addresses = nil
	m.clearedcustomer_addresses = false
	m.removedcustomer_addresses = nil
}

// AddClinicIDs adds the "clinics" edge to the Clinic entity by ids.
func (m *CustomerMutation) AddClinicIDs(ids ...int) {
	if m.clinics == nil {
		m.clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.clinics[ids[i]] = struct{}{}
	}
}

// ClearClinics clears the "clinics" edge to the Clinic entity.
func (m *CustomerMutation) ClearClinics() {
	m.clearedclinics = true
}

// ClinicsCleared reports if the "clinics" edge to the Clinic entity was cleared.
func (m *CustomerMutation) ClinicsCleared() bool {
	return m.clearedclinics
}

// RemoveClinicIDs removes the "clinics" edge to the Clinic entity by IDs.
func (m *CustomerMutation) RemoveClinicIDs(ids ...int) {
	if m.removedclinics == nil {
		m.removedclinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinics, ids[i])
		m.removedclinics[ids[i]] = struct{}{}
	}
}

// RemovedClinics returns the removed IDs of the "clinics" edge to the Clinic entity.
func (m *CustomerMutation) RemovedClinicsIDs() (ids []int) {
	for id := range m.removedclinics {
		ids = append(ids, id)
	}
	return
}

// ClinicsIDs returns the "clinics" edge IDs in the mutation.
func (m *CustomerMutation) ClinicsIDs() (ids []int) {
	for id := range m.clinics {
		ids = append(ids, id)
	}
	return
}

// ResetClinics resets all changes to the "clinics" edge.
func (m *CustomerMutation) ResetClinics() {
	m.clinics = nil
	m.clearedclinics = false
	m.removedclinics = nil
}

// ClearSales clears the "sales" edge to the InternalUser entity.
func (m *CustomerMutation) ClearSales() {
	m.clearedsales = true
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesCleared reports if the "sales" edge to the InternalUser entity was cleared.
func (m *CustomerMutation) SalesCleared() bool {
	return m.SalesIDCleared() || m.clearedsales
}

// SalesIDs returns the "sales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) SalesIDs() (ids []int) {
	if id := m.sales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *CustomerMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *CustomerMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[customer.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CustomerMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CustomerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrderIDs adds the "orders" edge to the OrderInfo entity by ids.
func (m *CustomerMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the OrderInfo entity.
func (m *CustomerMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the OrderInfo entity was cleared.
func (m *CustomerMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the OrderInfo entity by IDs.
func (m *CustomerMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the OrderInfo entity.
func (m *CustomerMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CustomerMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CustomerMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddCurrentPatientIDs adds the "current_patients" edge to the Patient entity by ids.
func (m *CustomerMutation) AddCurrentPatientIDs(ids ...int) {
	if m.current_patients == nil {
		m.current_patients = make(map[int]struct{})
	}
	for i := range ids {
		m.current_patients[ids[i]] = struct{}{}
	}
}

// ClearCurrentPatients clears the "current_patients" edge to the Patient entity.
func (m *CustomerMutation) ClearCurrentPatients() {
	m.clearedcurrent_patients = true
}

// CurrentPatientsCleared reports if the "current_patients" edge to the Patient entity was cleared.
func (m *CustomerMutation) CurrentPatientsCleared() bool {
	return m.clearedcurrent_patients
}

// RemoveCurrentPatientIDs removes the "current_patients" edge to the Patient entity by IDs.
func (m *CustomerMutation) RemoveCurrentPatientIDs(ids ...int) {
	if m.removedcurrent_patients == nil {
		m.removedcurrent_patients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.current_patients, ids[i])
		m.removedcurrent_patients[ids[i]] = struct{}{}
	}
}

// RemovedCurrentPatients returns the removed IDs of the "current_patients" edge to the Patient entity.
func (m *CustomerMutation) RemovedCurrentPatientsIDs() (ids []int) {
	for id := range m.removedcurrent_patients {
		ids = append(ids, id)
	}
	return
}

// CurrentPatientsIDs returns the "current_patients" edge IDs in the mutation.
func (m *CustomerMutation) CurrentPatientsIDs() (ids []int) {
	for id := range m.current_patients {
		ids = append(ids, id)
	}
	return
}

// ResetCurrentPatients resets all changes to the "current_patients" edge.
func (m *CustomerMutation) ResetCurrentPatients() {
	m.current_patients = nil
	m.clearedcurrent_patients = false
	m.removedcurrent_patients = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *CustomerMutation) AddPatientIDs(ids ...int) {
	if m.patients == nil {
		m.patients = make(map[int]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *CustomerMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared reports if the "patients" edge to the Patient entity was cleared.
func (m *CustomerMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *CustomerMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patients, ids[i])
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *CustomerMutation) RemovedPatientsIDs() (ids []int) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *CustomerMutation) PatientsIDs() (ids []int) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *CustomerMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// AddCustomerBetaProgramParticipationIDs adds the "customer_beta_program_participations" edge to the BetaProgramParticipation entity by ids.
func (m *CustomerMutation) AddCustomerBetaProgramParticipationIDs(ids ...int) {
	if m.customer_beta_program_participations == nil {
		m.customer_beta_program_participations = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_beta_program_participations[ids[i]] = struct{}{}
	}
}

// ClearCustomerBetaProgramParticipations clears the "customer_beta_program_participations" edge to the BetaProgramParticipation entity.
func (m *CustomerMutation) ClearCustomerBetaProgramParticipations() {
	m.clearedcustomer_beta_program_participations = true
}

// CustomerBetaProgramParticipationsCleared reports if the "customer_beta_program_participations" edge to the BetaProgramParticipation entity was cleared.
func (m *CustomerMutation) CustomerBetaProgramParticipationsCleared() bool {
	return m.clearedcustomer_beta_program_participations
}

// RemoveCustomerBetaProgramParticipationIDs removes the "customer_beta_program_participations" edge to the BetaProgramParticipation entity by IDs.
func (m *CustomerMutation) RemoveCustomerBetaProgramParticipationIDs(ids ...int) {
	if m.removedcustomer_beta_program_participations == nil {
		m.removedcustomer_beta_program_participations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_beta_program_participations, ids[i])
		m.removedcustomer_beta_program_participations[ids[i]] = struct{}{}
	}
}

// RemovedCustomerBetaProgramParticipations returns the removed IDs of the "customer_beta_program_participations" edge to the BetaProgramParticipation entity.
func (m *CustomerMutation) RemovedCustomerBetaProgramParticipationsIDs() (ids []int) {
	for id := range m.removedcustomer_beta_program_participations {
		ids = append(ids, id)
	}
	return
}

// CustomerBetaProgramParticipationsIDs returns the "customer_beta_program_participations" edge IDs in the mutation.
func (m *CustomerMutation) CustomerBetaProgramParticipationsIDs() (ids []int) {
	for id := range m.customer_beta_program_participations {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerBetaProgramParticipations resets all changes to the "customer_beta_program_participations" edge.
func (m *CustomerMutation) ResetCustomerBetaProgramParticipations() {
	m.customer_beta_program_participations = nil
	m.clearedcustomer_beta_program_participations = false
	m.removedcustomer_beta_program_participations = nil
}

// AddCustomerSettingsOnClinicIDs adds the "customer_settings_on_clinics" edge to the CustomerSettingOnClinics entity by ids.
func (m *CustomerMutation) AddCustomerSettingsOnClinicIDs(ids ...int) {
	if m.customer_settings_on_clinics == nil {
		m.customer_settings_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_settings_on_clinics[ids[i]] = struct{}{}
	}
}

// ClearCustomerSettingsOnClinics clears the "customer_settings_on_clinics" edge to the CustomerSettingOnClinics entity.
func (m *CustomerMutation) ClearCustomerSettingsOnClinics() {
	m.clearedcustomer_settings_on_clinics = true
}

// CustomerSettingsOnClinicsCleared reports if the "customer_settings_on_clinics" edge to the CustomerSettingOnClinics entity was cleared.
func (m *CustomerMutation) CustomerSettingsOnClinicsCleared() bool {
	return m.clearedcustomer_settings_on_clinics
}

// RemoveCustomerSettingsOnClinicIDs removes the "customer_settings_on_clinics" edge to the CustomerSettingOnClinics entity by IDs.
func (m *CustomerMutation) RemoveCustomerSettingsOnClinicIDs(ids ...int) {
	if m.removedcustomer_settings_on_clinics == nil {
		m.removedcustomer_settings_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_settings_on_clinics, ids[i])
		m.removedcustomer_settings_on_clinics[ids[i]] = struct{}{}
	}
}

// RemovedCustomerSettingsOnClinics returns the removed IDs of the "customer_settings_on_clinics" edge to the CustomerSettingOnClinics entity.
func (m *CustomerMutation) RemovedCustomerSettingsOnClinicsIDs() (ids []int) {
	for id := range m.removedcustomer_settings_on_clinics {
		ids = append(ids, id)
	}
	return
}

// CustomerSettingsOnClinicsIDs returns the "customer_settings_on_clinics" edge IDs in the mutation.
func (m *CustomerMutation) CustomerSettingsOnClinicsIDs() (ids []int) {
	for id := range m.customer_settings_on_clinics {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerSettingsOnClinics resets all changes to the "customer_settings_on_clinics" edge.
func (m *CustomerMutation) ResetCustomerSettingsOnClinics() {
	m.customer_settings_on_clinics = nil
	m.clearedcustomer_settings_on_clinics = false
	m.removedcustomer_settings_on_clinics = nil
}

// AddCustomerAddressesOnClinicIDs adds the "customer_addresses_on_clinics" edge to the CustomerAddressOnClinics entity by ids.
func (m *CustomerMutation) AddCustomerAddressesOnClinicIDs(ids ...int) {
	if m.customer_addresses_on_clinics == nil {
		m.customer_addresses_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_addresses_on_clinics[ids[i]] = struct{}{}
	}
}

// ClearCustomerAddressesOnClinics clears the "customer_addresses_on_clinics" edge to the CustomerAddressOnClinics entity.
func (m *CustomerMutation) ClearCustomerAddressesOnClinics() {
	m.clearedcustomer_addresses_on_clinics = true
}

// CustomerAddressesOnClinicsCleared reports if the "customer_addresses_on_clinics" edge to the CustomerAddressOnClinics entity was cleared.
func (m *CustomerMutation) CustomerAddressesOnClinicsCleared() bool {
	return m.clearedcustomer_addresses_on_clinics
}

// RemoveCustomerAddressesOnClinicIDs removes the "customer_addresses_on_clinics" edge to the CustomerAddressOnClinics entity by IDs.
func (m *CustomerMutation) RemoveCustomerAddressesOnClinicIDs(ids ...int) {
	if m.removedcustomer_addresses_on_clinics == nil {
		m.removedcustomer_addresses_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_addresses_on_clinics, ids[i])
		m.removedcustomer_addresses_on_clinics[ids[i]] = struct{}{}
	}
}

// RemovedCustomerAddressesOnClinics returns the removed IDs of the "customer_addresses_on_clinics" edge to the CustomerAddressOnClinics entity.
func (m *CustomerMutation) RemovedCustomerAddressesOnClinicsIDs() (ids []int) {
	for id := range m.removedcustomer_addresses_on_clinics {
		ids = append(ids, id)
	}
	return
}

// CustomerAddressesOnClinicsIDs returns the "customer_addresses_on_clinics" edge IDs in the mutation.
func (m *CustomerMutation) CustomerAddressesOnClinicsIDs() (ids []int) {
	for id := range m.customer_addresses_on_clinics {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerAddressesOnClinics resets all changes to the "customer_addresses_on_clinics" edge.
func (m *CustomerMutation) ResetCustomerAddressesOnClinics() {
	m.customer_addresses_on_clinics = nil
	m.clearedcustomer_addresses_on_clinics = false
	m.removedcustomer_addresses_on_clinics = nil
}

// AddCustomerContactsOnClinicIDs adds the "customer_contacts_on_clinics" edge to the CustomerContactOnClinics entity by ids.
func (m *CustomerMutation) AddCustomerContactsOnClinicIDs(ids ...int) {
	if m.customer_contacts_on_clinics == nil {
		m.customer_contacts_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_contacts_on_clinics[ids[i]] = struct{}{}
	}
}

// ClearCustomerContactsOnClinics clears the "customer_contacts_on_clinics" edge to the CustomerContactOnClinics entity.
func (m *CustomerMutation) ClearCustomerContactsOnClinics() {
	m.clearedcustomer_contacts_on_clinics = true
}

// CustomerContactsOnClinicsCleared reports if the "customer_contacts_on_clinics" edge to the CustomerContactOnClinics entity was cleared.
func (m *CustomerMutation) CustomerContactsOnClinicsCleared() bool {
	return m.clearedcustomer_contacts_on_clinics
}

// RemoveCustomerContactsOnClinicIDs removes the "customer_contacts_on_clinics" edge to the CustomerContactOnClinics entity by IDs.
func (m *CustomerMutation) RemoveCustomerContactsOnClinicIDs(ids ...int) {
	if m.removedcustomer_contacts_on_clinics == nil {
		m.removedcustomer_contacts_on_clinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_contacts_on_clinics, ids[i])
		m.removedcustomer_contacts_on_clinics[ids[i]] = struct{}{}
	}
}

// RemovedCustomerContactsOnClinics returns the removed IDs of the "customer_contacts_on_clinics" edge to the CustomerContactOnClinics entity.
func (m *CustomerMutation) RemovedCustomerContactsOnClinicsIDs() (ids []int) {
	for id := range m.removedcustomer_contacts_on_clinics {
		ids = append(ids, id)
	}
	return
}

// CustomerContactsOnClinicsIDs returns the "customer_contacts_on_clinics" edge IDs in the mutation.
func (m *CustomerMutation) CustomerContactsOnClinicsIDs() (ids []int) {
	for id := range m.customer_contacts_on_clinics {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerContactsOnClinics resets all changes to the "customer_contacts_on_clinics" edge.
func (m *CustomerMutation) ResetCustomerContactsOnClinics() {
	m.customer_contacts_on_clinics = nil
	m.clearedcustomer_contacts_on_clinics = false
	m.removedcustomer_contacts_on_clinics = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.user != nil {
		fields = append(fields, customer.FieldUserID)
	}
	if m.customer_type != nil {
		fields = append(fields, customer.FieldCustomerType)
	}
	if m.customer_first_name != nil {
		fields = append(fields, customer.FieldCustomerFirstName)
	}
	if m.customer_last_name != nil {
		fields = append(fields, customer.FieldCustomerLastName)
	}
	if m.customer_middle_name != nil {
		fields = append(fields, customer.FieldCustomerMiddleName)
	}
	if m.customer_type_id != nil {
		fields = append(fields, customer.FieldCustomerTypeID)
	}
	if m.customer_suffix != nil {
		fields = append(fields, customer.FieldCustomerSuffix)
	}
	if m.customer_samples_received != nil {
		fields = append(fields, customer.FieldCustomerSamplesReceived)
	}
	if m.customer_request_submit_time != nil {
		fields = append(fields, customer.FieldCustomerRequestSubmitTime)
	}
	if m.customer_signup_time != nil {
		fields = append(fields, customer.FieldCustomerSignupTime)
	}
	if m.is_active != nil {
		fields = append(fields, customer.FieldIsActive)
	}
	if m.sales != nil {
		fields = append(fields, customer.FieldSalesID)
	}
	if m.customer_npi_number != nil {
		fields = append(fields, customer.FieldCustomerNpiNumber)
	}
	if m.referral_source != nil {
		fields = append(fields, customer.FieldReferralSource)
	}
	if m.order_placement_allowed != nil {
		fields = append(fields, customer.FieldOrderPlacementAllowed)
	}
	if m.beta_program_enabled != nil {
		fields = append(fields, customer.FieldBetaProgramEnabled)
	}
	if m.onboarding_questionnaire_filled_on != nil {
		fields = append(fields, customer.FieldOnboardingQuestionnaireFilledOn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldUserID:
		return m.UserID()
	case customer.FieldCustomerType:
		return m.CustomerType()
	case customer.FieldCustomerFirstName:
		return m.CustomerFirstName()
	case customer.FieldCustomerLastName:
		return m.CustomerLastName()
	case customer.FieldCustomerMiddleName:
		return m.CustomerMiddleName()
	case customer.FieldCustomerTypeID:
		return m.CustomerTypeID()
	case customer.FieldCustomerSuffix:
		return m.CustomerSuffix()
	case customer.FieldCustomerSamplesReceived:
		return m.CustomerSamplesReceived()
	case customer.FieldCustomerRequestSubmitTime:
		return m.CustomerRequestSubmitTime()
	case customer.FieldCustomerSignupTime:
		return m.CustomerSignupTime()
	case customer.FieldIsActive:
		return m.IsActive()
	case customer.FieldSalesID:
		return m.SalesID()
	case customer.FieldCustomerNpiNumber:
		return m.CustomerNpiNumber()
	case customer.FieldReferralSource:
		return m.ReferralSource()
	case customer.FieldOrderPlacementAllowed:
		return m.OrderPlacementAllowed()
	case customer.FieldBetaProgramEnabled:
		return m.BetaProgramEnabled()
	case customer.FieldOnboardingQuestionnaireFilledOn:
		return m.OnboardingQuestionnaireFilledOn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldUserID:
		return m.OldUserID(ctx)
	case customer.FieldCustomerType:
		return m.OldCustomerType(ctx)
	case customer.FieldCustomerFirstName:
		return m.OldCustomerFirstName(ctx)
	case customer.FieldCustomerLastName:
		return m.OldCustomerLastName(ctx)
	case customer.FieldCustomerMiddleName:
		return m.OldCustomerMiddleName(ctx)
	case customer.FieldCustomerTypeID:
		return m.OldCustomerTypeID(ctx)
	case customer.FieldCustomerSuffix:
		return m.OldCustomerSuffix(ctx)
	case customer.FieldCustomerSamplesReceived:
		return m.OldCustomerSamplesReceived(ctx)
	case customer.FieldCustomerRequestSubmitTime:
		return m.OldCustomerRequestSubmitTime(ctx)
	case customer.FieldCustomerSignupTime:
		return m.OldCustomerSignupTime(ctx)
	case customer.FieldIsActive:
		return m.OldIsActive(ctx)
	case customer.FieldSalesID:
		return m.OldSalesID(ctx)
	case customer.FieldCustomerNpiNumber:
		return m.OldCustomerNpiNumber(ctx)
	case customer.FieldReferralSource:
		return m.OldReferralSource(ctx)
	case customer.FieldOrderPlacementAllowed:
		return m.OldOrderPlacementAllowed(ctx)
	case customer.FieldBetaProgramEnabled:
		return m.OldBetaProgramEnabled(ctx)
	case customer.FieldOnboardingQuestionnaireFilledOn:
		return m.OldOnboardingQuestionnaireFilledOn(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case customer.FieldCustomerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerType(v)
		return nil
	case customer.FieldCustomerFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerFirstName(v)
		return nil
	case customer.FieldCustomerLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerLastName(v)
		return nil
	case customer.FieldCustomerMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerMiddleName(v)
		return nil
	case customer.FieldCustomerTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerTypeID(v)
		return nil
	case customer.FieldCustomerSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerSuffix(v)
		return nil
	case customer.FieldCustomerSamplesReceived:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerSamplesReceived(v)
		return nil
	case customer.FieldCustomerRequestSubmitTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRequestSubmitTime(v)
		return nil
	case customer.FieldCustomerSignupTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerSignupTime(v)
		return nil
	case customer.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case customer.FieldSalesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case customer.FieldCustomerNpiNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerNpiNumber(v)
		return nil
	case customer.FieldReferralSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralSource(v)
		return nil
	case customer.FieldOrderPlacementAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPlacementAllowed(v)
		return nil
	case customer.FieldBetaProgramEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetaProgramEnabled(v)
		return nil
	case customer.FieldOnboardingQuestionnaireFilledOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingQuestionnaireFilledOn(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldUserID) {
		fields = append(fields, customer.FieldUserID)
	}
	if m.FieldCleared(customer.FieldCustomerFirstName) {
		fields = append(fields, customer.FieldCustomerFirstName)
	}
	if m.FieldCleared(customer.FieldCustomerLastName) {
		fields = append(fields, customer.FieldCustomerLastName)
	}
	if m.FieldCleared(customer.FieldCustomerMiddleName) {
		fields = append(fields, customer.FieldCustomerMiddleName)
	}
	if m.FieldCleared(customer.FieldCustomerTypeID) {
		fields = append(fields, customer.FieldCustomerTypeID)
	}
	if m.FieldCleared(customer.FieldCustomerSuffix) {
		fields = append(fields, customer.FieldCustomerSuffix)
	}
	if m.FieldCleared(customer.FieldCustomerSamplesReceived) {
		fields = append(fields, customer.FieldCustomerSamplesReceived)
	}
	if m.FieldCleared(customer.FieldCustomerRequestSubmitTime) {
		fields = append(fields, customer.FieldCustomerRequestSubmitTime)
	}
	if m.FieldCleared(customer.FieldCustomerSignupTime) {
		fields = append(fields, customer.FieldCustomerSignupTime)
	}
	if m.FieldCleared(customer.FieldSalesID) {
		fields = append(fields, customer.FieldSalesID)
	}
	if m.FieldCleared(customer.FieldCustomerNpiNumber) {
		fields = append(fields, customer.FieldCustomerNpiNumber)
	}
	if m.FieldCleared(customer.FieldReferralSource) {
		fields = append(fields, customer.FieldReferralSource)
	}
	if m.FieldCleared(customer.FieldOrderPlacementAllowed) {
		fields = append(fields, customer.FieldOrderPlacementAllowed)
	}
	if m.FieldCleared(customer.FieldBetaProgramEnabled) {
		fields = append(fields, customer.FieldBetaProgramEnabled)
	}
	if m.FieldCleared(customer.FieldOnboardingQuestionnaireFilledOn) {
		fields = append(fields, customer.FieldOnboardingQuestionnaireFilledOn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldUserID:
		m.ClearUserID()
		return nil
	case customer.FieldCustomerFirstName:
		m.ClearCustomerFirstName()
		return nil
	case customer.FieldCustomerLastName:
		m.ClearCustomerLastName()
		return nil
	case customer.FieldCustomerMiddleName:
		m.ClearCustomerMiddleName()
		return nil
	case customer.FieldCustomerTypeID:
		m.ClearCustomerTypeID()
		return nil
	case customer.FieldCustomerSuffix:
		m.ClearCustomerSuffix()
		return nil
	case customer.FieldCustomerSamplesReceived:
		m.ClearCustomerSamplesReceived()
		return nil
	case customer.FieldCustomerRequestSubmitTime:
		m.ClearCustomerRequestSubmitTime()
		return nil
	case customer.FieldCustomerSignupTime:
		m.ClearCustomerSignupTime()
		return nil
	case customer.FieldSalesID:
		m.ClearSalesID()
		return nil
	case customer.FieldCustomerNpiNumber:
		m.ClearCustomerNpiNumber()
		return nil
	case customer.FieldReferralSource:
		m.ClearReferralSource()
		return nil
	case customer.FieldOrderPlacementAllowed:
		m.ClearOrderPlacementAllowed()
		return nil
	case customer.FieldBetaProgramEnabled:
		m.ClearBetaProgramEnabled()
		return nil
	case customer.FieldOnboardingQuestionnaireFilledOn:
		m.ClearOnboardingQuestionnaireFilledOn()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldUserID:
		m.ResetUserID()
		return nil
	case customer.FieldCustomerType:
		m.ResetCustomerType()
		return nil
	case customer.FieldCustomerFirstName:
		m.ResetCustomerFirstName()
		return nil
	case customer.FieldCustomerLastName:
		m.ResetCustomerLastName()
		return nil
	case customer.FieldCustomerMiddleName:
		m.ResetCustomerMiddleName()
		return nil
	case customer.FieldCustomerTypeID:
		m.ResetCustomerTypeID()
		return nil
	case customer.FieldCustomerSuffix:
		m.ResetCustomerSuffix()
		return nil
	case customer.FieldCustomerSamplesReceived:
		m.ResetCustomerSamplesReceived()
		return nil
	case customer.FieldCustomerRequestSubmitTime:
		m.ResetCustomerRequestSubmitTime()
		return nil
	case customer.FieldCustomerSignupTime:
		m.ResetCustomerSignupTime()
		return nil
	case customer.FieldIsActive:
		m.ResetIsActive()
		return nil
	case customer.FieldSalesID:
		m.ResetSalesID()
		return nil
	case customer.FieldCustomerNpiNumber:
		m.ResetCustomerNpiNumber()
		return nil
	case customer.FieldReferralSource:
		m.ResetReferralSource()
		return nil
	case customer.FieldOrderPlacementAllowed:
		m.ResetOrderPlacementAllowed()
		return nil
	case customer.FieldBetaProgramEnabled:
		m.ResetBetaProgramEnabled()
		return nil
	case customer.FieldOnboardingQuestionnaireFilledOn:
		m.ResetOnboardingQuestionnaireFilledOn()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.samples != nil {
		edges = append(edges, customer.EdgeSamples)
	}
	if m.customer_contacts != nil {
		edges = append(edges, customer.EdgeCustomerContacts)
	}
	if m.customer_addresses != nil {
		edges = append(edges, customer.EdgeCustomerAddresses)
	}
	if m.clinics != nil {
		edges = append(edges, customer.EdgeClinics)
	}
	if m.sales != nil {
		edges = append(edges, customer.EdgeSales)
	}
	if m.user != nil {
		edges = append(edges, customer.EdgeUser)
	}
	if m.orders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.current_patients != nil {
		edges = append(edges, customer.EdgeCurrentPatients)
	}
	if m.patients != nil {
		edges = append(edges, customer.EdgePatients)
	}
	if m.customer_beta_program_participations != nil {
		edges = append(edges, customer.EdgeCustomerBetaProgramParticipations)
	}
	if m.customer_settings_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerSettingsOnClinics)
	}
	if m.customer_addresses_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerAddressesOnClinics)
	}
	if m.customer_contacts_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerContactsOnClinics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeSamples:
		ids := make([]ent.Value, 0, len(m.samples))
		for id := range m.samples {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerContacts:
		ids := make([]ent.Value, 0, len(m.customer_contacts))
		for id := range m.customer_contacts {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerAddresses:
		ids := make([]ent.Value, 0, len(m.customer_addresses))
		for id := range m.customer_addresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeClinics:
		ids := make([]ent.Value, 0, len(m.clinics))
		for id := range m.clinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSales:
		if id := m.sales; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCurrentPatients:
		ids := make([]ent.Value, 0, len(m.current_patients))
		for id := range m.current_patients {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerBetaProgramParticipations:
		ids := make([]ent.Value, 0, len(m.customer_beta_program_participations))
		for id := range m.customer_beta_program_participations {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerSettingsOnClinics:
		ids := make([]ent.Value, 0, len(m.customer_settings_on_clinics))
		for id := range m.customer_settings_on_clinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerAddressesOnClinics:
		ids := make([]ent.Value, 0, len(m.customer_addresses_on_clinics))
		for id := range m.customer_addresses_on_clinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerContactsOnClinics:
		ids := make([]ent.Value, 0, len(m.customer_contacts_on_clinics))
		for id := range m.customer_contacts_on_clinics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedsamples != nil {
		edges = append(edges, customer.EdgeSamples)
	}
	if m.removedcustomer_contacts != nil {
		edges = append(edges, customer.EdgeCustomerContacts)
	}
	if m.removedcustomer_addresses != nil {
		edges = append(edges, customer.EdgeCustomerAddresses)
	}
	if m.removedclinics != nil {
		edges = append(edges, customer.EdgeClinics)
	}
	if m.removedorders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.removedcurrent_patients != nil {
		edges = append(edges, customer.EdgeCurrentPatients)
	}
	if m.removedpatients != nil {
		edges = append(edges, customer.EdgePatients)
	}
	if m.removedcustomer_beta_program_participations != nil {
		edges = append(edges, customer.EdgeCustomerBetaProgramParticipations)
	}
	if m.removedcustomer_settings_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerSettingsOnClinics)
	}
	if m.removedcustomer_addresses_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerAddressesOnClinics)
	}
	if m.removedcustomer_contacts_on_clinics != nil {
		edges = append(edges, customer.EdgeCustomerContactsOnClinics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeSamples:
		ids := make([]ent.Value, 0, len(m.removedsamples))
		for id := range m.removedsamples {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerContacts:
		ids := make([]ent.Value, 0, len(m.removedcustomer_contacts))
		for id := range m.removedcustomer_contacts {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerAddresses:
		ids := make([]ent.Value, 0, len(m.removedcustomer_addresses))
		for id := range m.removedcustomer_addresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeClinics:
		ids := make([]ent.Value, 0, len(m.removedclinics))
		for id := range m.removedclinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCurrentPatients:
		ids := make([]ent.Value, 0, len(m.removedcurrent_patients))
		for id := range m.removedcurrent_patients {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerBetaProgramParticipations:
		ids := make([]ent.Value, 0, len(m.removedcustomer_beta_program_participations))
		for id := range m.removedcustomer_beta_program_participations {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerSettingsOnClinics:
		ids := make([]ent.Value, 0, len(m.removedcustomer_settings_on_clinics))
		for id := range m.removedcustomer_settings_on_clinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerAddressesOnClinics:
		ids := make([]ent.Value, 0, len(m.removedcustomer_addresses_on_clinics))
		for id := range m.removedcustomer_addresses_on_clinics {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCustomerContactsOnClinics:
		ids := make([]ent.Value, 0, len(m.removedcustomer_contacts_on_clinics))
		for id := range m.removedcustomer_contacts_on_clinics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedsamples {
		edges = append(edges, customer.EdgeSamples)
	}
	if m.clearedcustomer_contacts {
		edges = append(edges, customer.EdgeCustomerContacts)
	}
	if m.clearedcustomer_addresses {
		edges = append(edges, customer.EdgeCustomerAddresses)
	}
	if m.clearedclinics {
		edges = append(edges, customer.EdgeClinics)
	}
	if m.clearedsales {
		edges = append(edges, customer.EdgeSales)
	}
	if m.cleareduser {
		edges = append(edges, customer.EdgeUser)
	}
	if m.clearedorders {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.clearedcurrent_patients {
		edges = append(edges, customer.EdgeCurrentPatients)
	}
	if m.clearedpatients {
		edges = append(edges, customer.EdgePatients)
	}
	if m.clearedcustomer_beta_program_participations {
		edges = append(edges, customer.EdgeCustomerBetaProgramParticipations)
	}
	if m.clearedcustomer_settings_on_clinics {
		edges = append(edges, customer.EdgeCustomerSettingsOnClinics)
	}
	if m.clearedcustomer_addresses_on_clinics {
		edges = append(edges, customer.EdgeCustomerAddressesOnClinics)
	}
	if m.clearedcustomer_contacts_on_clinics {
		edges = append(edges, customer.EdgeCustomerContactsOnClinics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeSamples:
		return m.clearedsamples
	case customer.EdgeCustomerContacts:
		return m.clearedcustomer_contacts
	case customer.EdgeCustomerAddresses:
		return m.clearedcustomer_addresses
	case customer.EdgeClinics:
		return m.clearedclinics
	case customer.EdgeSales:
		return m.clearedsales
	case customer.EdgeUser:
		return m.cleareduser
	case customer.EdgeOrders:
		return m.clearedorders
	case customer.EdgeCurrentPatients:
		return m.clearedcurrent_patients
	case customer.EdgePatients:
		return m.clearedpatients
	case customer.EdgeCustomerBetaProgramParticipations:
		return m.clearedcustomer_beta_program_participations
	case customer.EdgeCustomerSettingsOnClinics:
		return m.clearedcustomer_settings_on_clinics
	case customer.EdgeCustomerAddressesOnClinics:
		return m.clearedcustomer_addresses_on_clinics
	case customer.EdgeCustomerContactsOnClinics:
		return m.clearedcustomer_contacts_on_clinics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeSales:
		m.ClearSales()
		return nil
	case customer.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeSamples:
		m.ResetSamples()
		return nil
	case customer.EdgeCustomerContacts:
		m.ResetCustomerContacts()
		return nil
	case customer.EdgeCustomerAddresses:
		m.ResetCustomerAddresses()
		return nil
	case customer.EdgeClinics:
		m.ResetClinics()
		return nil
	case customer.EdgeSales:
		m.ResetSales()
		return nil
	case customer.EdgeUser:
		m.ResetUser()
		return nil
	case customer.EdgeOrders:
		m.ResetOrders()
		return nil
	case customer.EdgeCurrentPatients:
		m.ResetCurrentPatients()
		return nil
	case customer.EdgePatients:
		m.ResetPatients()
		return nil
	case customer.EdgeCustomerBetaProgramParticipations:
		m.ResetCustomerBetaProgramParticipations()
		return nil
	case customer.EdgeCustomerSettingsOnClinics:
		m.ResetCustomerSettingsOnClinics()
		return nil
	case customer.EdgeCustomerAddressesOnClinics:
		m.ResetCustomerAddressesOnClinics()
		return nil
	case customer.EdgeCustomerContactsOnClinics:
		m.ResetCustomerContactsOnClinics()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerAddressOnClinicsMutation represents an operation that mutates the CustomerAddressOnClinics nodes in the graph.
type CustomerAddressOnClinicsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	address_type    *string
	clearedFields   map[string]struct{}
	customer        *int
	clearedcustomer bool
	clinic          *int
	clearedclinic   bool
	address         *int
	clearedaddress  bool
	done            bool
	oldValue        func(context.Context) (*CustomerAddressOnClinics, error)
	predicates      []predicate.CustomerAddressOnClinics
}

var _ ent.Mutation = (*CustomerAddressOnClinicsMutation)(nil)

// customeraddressonclinicsOption allows management of the mutation configuration using functional options.
type customeraddressonclinicsOption func(*CustomerAddressOnClinicsMutation)

// newCustomerAddressOnClinicsMutation creates new mutation for the CustomerAddressOnClinics entity.
func newCustomerAddressOnClinicsMutation(c config, op Op, opts ...customeraddressonclinicsOption) *CustomerAddressOnClinicsMutation {
	m := &CustomerAddressOnClinicsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerAddressOnClinics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerAddressOnClinicsID sets the ID field of the mutation.
func withCustomerAddressOnClinicsID(id int) customeraddressonclinicsOption {
	return func(m *CustomerAddressOnClinicsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerAddressOnClinics
		)
		m.oldValue = func(ctx context.Context) (*CustomerAddressOnClinics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerAddressOnClinics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerAddressOnClinics sets the old CustomerAddressOnClinics of the mutation.
func withCustomerAddressOnClinics(node *CustomerAddressOnClinics) customeraddressonclinicsOption {
	return func(m *CustomerAddressOnClinicsMutation) {
		m.oldValue = func(context.Context) (*CustomerAddressOnClinics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerAddressOnClinicsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerAddressOnClinicsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerAddressOnClinicsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerAddressOnClinicsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerAddressOnClinics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerAddressOnClinicsMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerAddressOnClinicsMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerAddressOnClinics entity.
// If the CustomerAddressOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressOnClinicsMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerAddressOnClinicsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *CustomerAddressOnClinicsMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *CustomerAddressOnClinicsMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the CustomerAddressOnClinics entity.
// If the CustomerAddressOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressOnClinicsMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *CustomerAddressOnClinicsMutation) ResetClinicID() {
	m.clinic = nil
}

// SetAddressID sets the "address_id" field.
func (m *CustomerAddressOnClinicsMutation) SetAddressID(i int) {
	m.address = &i
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *CustomerAddressOnClinicsMutation) AddressID() (r int, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the CustomerAddressOnClinics entity.
// If the CustomerAddressOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressOnClinicsMutation) OldAddressID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *CustomerAddressOnClinicsMutation) ResetAddressID() {
	m.address = nil
}

// SetAddressType sets the "address_type" field.
func (m *CustomerAddressOnClinicsMutation) SetAddressType(s string) {
	m.address_type = &s
}

// AddressType returns the value of the "address_type" field in the mutation.
func (m *CustomerAddressOnClinicsMutation) AddressType() (r string, exists bool) {
	v := m.address_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressType returns the old "address_type" field's value of the CustomerAddressOnClinics entity.
// If the CustomerAddressOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressOnClinicsMutation) OldAddressType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressType: %w", err)
	}
	return oldValue.AddressType, nil
}

// ClearAddressType clears the value of the "address_type" field.
func (m *CustomerAddressOnClinicsMutation) ClearAddressType() {
	m.address_type = nil
	m.clearedFields[customeraddressonclinics.FieldAddressType] = struct{}{}
}

// AddressTypeCleared returns if the "address_type" field was cleared in this mutation.
func (m *CustomerAddressOnClinicsMutation) AddressTypeCleared() bool {
	_, ok := m.clearedFields[customeraddressonclinics.FieldAddressType]
	return ok
}

// ResetAddressType resets all changes to the "address_type" field.
func (m *CustomerAddressOnClinicsMutation) ResetAddressType() {
	m.address_type = nil
	delete(m.clearedFields, customeraddressonclinics.FieldAddressType)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerAddressOnClinicsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customeraddressonclinics.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerAddressOnClinicsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerAddressOnClinicsMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerAddressOnClinicsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *CustomerAddressOnClinicsMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[customeraddressonclinics.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *CustomerAddressOnClinicsMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *CustomerAddressOnClinicsMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *CustomerAddressOnClinicsMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *CustomerAddressOnClinicsMutation) ClearAddress() {
	m.clearedaddress = true
	m.clearedFields[customeraddressonclinics.FieldAddressID] = struct{}{}
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *CustomerAddressOnClinicsMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *CustomerAddressOnClinicsMutation) AddressIDs() (ids []int) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *CustomerAddressOnClinicsMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// Where appends a list predicates to the CustomerAddressOnClinicsMutation builder.
func (m *CustomerAddressOnClinicsMutation) Where(ps ...predicate.CustomerAddressOnClinics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerAddressOnClinicsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerAddressOnClinicsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerAddressOnClinics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerAddressOnClinicsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerAddressOnClinicsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerAddressOnClinics).
func (m *CustomerAddressOnClinicsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerAddressOnClinicsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.customer != nil {
		fields = append(fields, customeraddressonclinics.FieldCustomerID)
	}
	if m.clinic != nil {
		fields = append(fields, customeraddressonclinics.FieldClinicID)
	}
	if m.address != nil {
		fields = append(fields, customeraddressonclinics.FieldAddressID)
	}
	if m.address_type != nil {
		fields = append(fields, customeraddressonclinics.FieldAddressType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerAddressOnClinicsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customeraddressonclinics.FieldCustomerID:
		return m.CustomerID()
	case customeraddressonclinics.FieldClinicID:
		return m.ClinicID()
	case customeraddressonclinics.FieldAddressID:
		return m.AddressID()
	case customeraddressonclinics.FieldAddressType:
		return m.AddressType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerAddressOnClinicsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customeraddressonclinics.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customeraddressonclinics.FieldClinicID:
		return m.OldClinicID(ctx)
	case customeraddressonclinics.FieldAddressID:
		return m.OldAddressID(ctx)
	case customeraddressonclinics.FieldAddressType:
		return m.OldAddressType(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerAddressOnClinics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerAddressOnClinicsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customeraddressonclinics.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customeraddressonclinics.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case customeraddressonclinics.FieldAddressID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	case customeraddressonclinics.FieldAddressType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressType(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerAddressOnClinicsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerAddressOnClinicsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerAddressOnClinicsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerAddressOnClinicsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customeraddressonclinics.FieldAddressType) {
		fields = append(fields, customeraddressonclinics.FieldAddressType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerAddressOnClinicsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerAddressOnClinicsMutation) ClearField(name string) error {
	switch name {
	case customeraddressonclinics.FieldAddressType:
		m.ClearAddressType()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerAddressOnClinicsMutation) ResetField(name string) error {
	switch name {
	case customeraddressonclinics.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customeraddressonclinics.FieldClinicID:
		m.ResetClinicID()
		return nil
	case customeraddressonclinics.FieldAddressID:
		m.ResetAddressID()
		return nil
	case customeraddressonclinics.FieldAddressType:
		m.ResetAddressType()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerAddressOnClinicsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.customer != nil {
		edges = append(edges, customeraddressonclinics.EdgeCustomer)
	}
	if m.clinic != nil {
		edges = append(edges, customeraddressonclinics.EdgeClinic)
	}
	if m.address != nil {
		edges = append(edges, customeraddressonclinics.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerAddressOnClinicsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customeraddressonclinics.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customeraddressonclinics.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case customeraddressonclinics.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerAddressOnClinicsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerAddressOnClinicsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerAddressOnClinicsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcustomer {
		edges = append(edges, customeraddressonclinics.EdgeCustomer)
	}
	if m.clearedclinic {
		edges = append(edges, customeraddressonclinics.EdgeClinic)
	}
	if m.clearedaddress {
		edges = append(edges, customeraddressonclinics.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerAddressOnClinicsMutation) EdgeCleared(name string) bool {
	switch name {
	case customeraddressonclinics.EdgeCustomer:
		return m.clearedcustomer
	case customeraddressonclinics.EdgeClinic:
		return m.clearedclinic
	case customeraddressonclinics.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerAddressOnClinicsMutation) ClearEdge(name string) error {
	switch name {
	case customeraddressonclinics.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customeraddressonclinics.EdgeClinic:
		m.ClearClinic()
		return nil
	case customeraddressonclinics.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerAddressOnClinicsMutation) ResetEdge(name string) error {
	switch name {
	case customeraddressonclinics.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customeraddressonclinics.EdgeClinic:
		m.ResetClinic()
		return nil
	case customeraddressonclinics.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddressOnClinics edge %s", name)
}

// CustomerContactOnClinicsMutation represents an operation that mutates the CustomerContactOnClinics nodes in the graph.
type CustomerContactOnClinicsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	contact_type    *string
	clearedFields   map[string]struct{}
	customer        *int
	clearedcustomer bool
	clinic          *int
	clearedclinic   bool
	contact         *int
	clearedcontact  bool
	done            bool
	oldValue        func(context.Context) (*CustomerContactOnClinics, error)
	predicates      []predicate.CustomerContactOnClinics
}

var _ ent.Mutation = (*CustomerContactOnClinicsMutation)(nil)

// customercontactonclinicsOption allows management of the mutation configuration using functional options.
type customercontactonclinicsOption func(*CustomerContactOnClinicsMutation)

// newCustomerContactOnClinicsMutation creates new mutation for the CustomerContactOnClinics entity.
func newCustomerContactOnClinicsMutation(c config, op Op, opts ...customercontactonclinicsOption) *CustomerContactOnClinicsMutation {
	m := &CustomerContactOnClinicsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerContactOnClinics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerContactOnClinicsID sets the ID field of the mutation.
func withCustomerContactOnClinicsID(id int) customercontactonclinicsOption {
	return func(m *CustomerContactOnClinicsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerContactOnClinics
		)
		m.oldValue = func(ctx context.Context) (*CustomerContactOnClinics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerContactOnClinics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerContactOnClinics sets the old CustomerContactOnClinics of the mutation.
func withCustomerContactOnClinics(node *CustomerContactOnClinics) customercontactonclinicsOption {
	return func(m *CustomerContactOnClinicsMutation) {
		m.oldValue = func(context.Context) (*CustomerContactOnClinics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerContactOnClinicsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerContactOnClinicsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerContactOnClinicsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerContactOnClinicsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerContactOnClinics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerContactOnClinicsMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerContactOnClinicsMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerContactOnClinics entity.
// If the CustomerContactOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactOnClinicsMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerContactOnClinicsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *CustomerContactOnClinicsMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *CustomerContactOnClinicsMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the CustomerContactOnClinics entity.
// If the CustomerContactOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactOnClinicsMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *CustomerContactOnClinicsMutation) ResetClinicID() {
	m.clinic = nil
}

// SetContactID sets the "contact_id" field.
func (m *CustomerContactOnClinicsMutation) SetContactID(i int) {
	m.contact = &i
}

// ContactID returns the value of the "contact_id" field in the mutation.
func (m *CustomerContactOnClinicsMutation) ContactID() (r int, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContactID returns the old "contact_id" field's value of the CustomerContactOnClinics entity.
// If the CustomerContactOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactOnClinicsMutation) OldContactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactID: %w", err)
	}
	return oldValue.ContactID, nil
}

// ResetContactID resets all changes to the "contact_id" field.
func (m *CustomerContactOnClinicsMutation) ResetContactID() {
	m.contact = nil
}

// SetContactType sets the "contact_type" field.
func (m *CustomerContactOnClinicsMutation) SetContactType(s string) {
	m.contact_type = &s
}

// ContactType returns the value of the "contact_type" field in the mutation.
func (m *CustomerContactOnClinicsMutation) ContactType() (r string, exists bool) {
	v := m.contact_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContactType returns the old "contact_type" field's value of the CustomerContactOnClinics entity.
// If the CustomerContactOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactOnClinicsMutation) OldContactType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactType: %w", err)
	}
	return oldValue.ContactType, nil
}

// ClearContactType clears the value of the "contact_type" field.
func (m *CustomerContactOnClinicsMutation) ClearContactType() {
	m.contact_type = nil
	m.clearedFields[customercontactonclinics.FieldContactType] = struct{}{}
}

// ContactTypeCleared returns if the "contact_type" field was cleared in this mutation.
func (m *CustomerContactOnClinicsMutation) ContactTypeCleared() bool {
	_, ok := m.clearedFields[customercontactonclinics.FieldContactType]
	return ok
}

// ResetContactType resets all changes to the "contact_type" field.
func (m *CustomerContactOnClinicsMutation) ResetContactType() {
	m.contact_type = nil
	delete(m.clearedFields, customercontactonclinics.FieldContactType)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerContactOnClinicsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customercontactonclinics.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerContactOnClinicsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerContactOnClinicsMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerContactOnClinicsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *CustomerContactOnClinicsMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[customercontactonclinics.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *CustomerContactOnClinicsMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *CustomerContactOnClinicsMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *CustomerContactOnClinicsMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearContact clears the "contact" edge to the Contact entity.
func (m *CustomerContactOnClinicsMutation) ClearContact() {
	m.clearedcontact = true
	m.clearedFields[customercontactonclinics.FieldContactID] = struct{}{}
}

// ContactCleared reports if the "contact" edge to the Contact entity was cleared.
func (m *CustomerContactOnClinicsMutation) ContactCleared() bool {
	return m.clearedcontact
}

// ContactIDs returns the "contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContactID instead. It exists only for internal usage by the builders.
func (m *CustomerContactOnClinicsMutation) ContactIDs() (ids []int) {
	if id := m.contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *CustomerContactOnClinicsMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
}

// Where appends a list predicates to the CustomerContactOnClinicsMutation builder.
func (m *CustomerContactOnClinicsMutation) Where(ps ...predicate.CustomerContactOnClinics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerContactOnClinicsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerContactOnClinicsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerContactOnClinics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerContactOnClinicsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerContactOnClinicsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerContactOnClinics).
func (m *CustomerContactOnClinicsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerContactOnClinicsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.customer != nil {
		fields = append(fields, customercontactonclinics.FieldCustomerID)
	}
	if m.clinic != nil {
		fields = append(fields, customercontactonclinics.FieldClinicID)
	}
	if m.contact != nil {
		fields = append(fields, customercontactonclinics.FieldContactID)
	}
	if m.contact_type != nil {
		fields = append(fields, customercontactonclinics.FieldContactType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerContactOnClinicsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customercontactonclinics.FieldCustomerID:
		return m.CustomerID()
	case customercontactonclinics.FieldClinicID:
		return m.ClinicID()
	case customercontactonclinics.FieldContactID:
		return m.ContactID()
	case customercontactonclinics.FieldContactType:
		return m.ContactType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerContactOnClinicsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customercontactonclinics.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customercontactonclinics.FieldClinicID:
		return m.OldClinicID(ctx)
	case customercontactonclinics.FieldContactID:
		return m.OldContactID(ctx)
	case customercontactonclinics.FieldContactType:
		return m.OldContactType(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerContactOnClinics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactOnClinicsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customercontactonclinics.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customercontactonclinics.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case customercontactonclinics.FieldContactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactID(v)
		return nil
	case customercontactonclinics.FieldContactType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactType(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerContactOnClinics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerContactOnClinicsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerContactOnClinicsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactOnClinicsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerContactOnClinics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerContactOnClinicsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customercontactonclinics.FieldContactType) {
		fields = append(fields, customercontactonclinics.FieldContactType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerContactOnClinicsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerContactOnClinicsMutation) ClearField(name string) error {
	switch name {
	case customercontactonclinics.FieldContactType:
		m.ClearContactType()
		return nil
	}
	return fmt.Errorf("unknown CustomerContactOnClinics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerContactOnClinicsMutation) ResetField(name string) error {
	switch name {
	case customercontactonclinics.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customercontactonclinics.FieldClinicID:
		m.ResetClinicID()
		return nil
	case customercontactonclinics.FieldContactID:
		m.ResetContactID()
		return nil
	case customercontactonclinics.FieldContactType:
		m.ResetContactType()
		return nil
	}
	return fmt.Errorf("unknown CustomerContactOnClinics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerContactOnClinicsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.customer != nil {
		edges = append(edges, customercontactonclinics.EdgeCustomer)
	}
	if m.clinic != nil {
		edges = append(edges, customercontactonclinics.EdgeClinic)
	}
	if m.contact != nil {
		edges = append(edges, customercontactonclinics.EdgeContact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerContactOnClinicsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customercontactonclinics.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customercontactonclinics.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case customercontactonclinics.EdgeContact:
		if id := m.contact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerContactOnClinicsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerContactOnClinicsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerContactOnClinicsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcustomer {
		edges = append(edges, customercontactonclinics.EdgeCustomer)
	}
	if m.clearedclinic {
		edges = append(edges, customercontactonclinics.EdgeClinic)
	}
	if m.clearedcontact {
		edges = append(edges, customercontactonclinics.EdgeContact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerContactOnClinicsMutation) EdgeCleared(name string) bool {
	switch name {
	case customercontactonclinics.EdgeCustomer:
		return m.clearedcustomer
	case customercontactonclinics.EdgeClinic:
		return m.clearedclinic
	case customercontactonclinics.EdgeContact:
		return m.clearedcontact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerContactOnClinicsMutation) ClearEdge(name string) error {
	switch name {
	case customercontactonclinics.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customercontactonclinics.EdgeClinic:
		m.ClearClinic()
		return nil
	case customercontactonclinics.EdgeContact:
		m.ClearContact()
		return nil
	}
	return fmt.Errorf("unknown CustomerContactOnClinics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerContactOnClinicsMutation) ResetEdge(name string) error {
	switch name {
	case customercontactonclinics.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customercontactonclinics.EdgeClinic:
		m.ResetClinic()
		return nil
	case customercontactonclinics.EdgeContact:
		m.ResetContact()
		return nil
	}
	return fmt.Errorf("unknown CustomerContactOnClinics edge %s", name)
}

// CustomerSettingOnClinicsMutation represents an operation that mutates the CustomerSettingOnClinics nodes in the graph.
type CustomerSettingOnClinicsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	setting_name    *string
	clearedFields   map[string]struct{}
	customer        *int
	clearedcustomer bool
	clinic          *int
	clearedclinic   bool
	setting         *int
	clearedsetting  bool
	done            bool
	oldValue        func(context.Context) (*CustomerSettingOnClinics, error)
	predicates      []predicate.CustomerSettingOnClinics
}

var _ ent.Mutation = (*CustomerSettingOnClinicsMutation)(nil)

// customersettingonclinicsOption allows management of the mutation configuration using functional options.
type customersettingonclinicsOption func(*CustomerSettingOnClinicsMutation)

// newCustomerSettingOnClinicsMutation creates new mutation for the CustomerSettingOnClinics entity.
func newCustomerSettingOnClinicsMutation(c config, op Op, opts ...customersettingonclinicsOption) *CustomerSettingOnClinicsMutation {
	m := &CustomerSettingOnClinicsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerSettingOnClinics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerSettingOnClinicsID sets the ID field of the mutation.
func withCustomerSettingOnClinicsID(id int) customersettingonclinicsOption {
	return func(m *CustomerSettingOnClinicsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerSettingOnClinics
		)
		m.oldValue = func(ctx context.Context) (*CustomerSettingOnClinics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerSettingOnClinics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerSettingOnClinics sets the old CustomerSettingOnClinics of the mutation.
func withCustomerSettingOnClinics(node *CustomerSettingOnClinics) customersettingonclinicsOption {
	return func(m *CustomerSettingOnClinicsMutation) {
		m.oldValue = func(context.Context) (*CustomerSettingOnClinics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerSettingOnClinicsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerSettingOnClinicsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerSettingOnClinicsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerSettingOnClinicsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerSettingOnClinics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerSettingOnClinicsMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerSettingOnClinicsMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerSettingOnClinics entity.
// If the CustomerSettingOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSettingOnClinicsMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerSettingOnClinicsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *CustomerSettingOnClinicsMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *CustomerSettingOnClinicsMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the CustomerSettingOnClinics entity.
// If the CustomerSettingOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSettingOnClinicsMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *CustomerSettingOnClinicsMutation) ResetClinicID() {
	m.clinic = nil
}

// SetSettingID sets the "setting_id" field.
func (m *CustomerSettingOnClinicsMutation) SetSettingID(i int) {
	m.setting = &i
}

// SettingID returns the value of the "setting_id" field in the mutation.
func (m *CustomerSettingOnClinicsMutation) SettingID() (r int, exists bool) {
	v := m.setting
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingID returns the old "setting_id" field's value of the CustomerSettingOnClinics entity.
// If the CustomerSettingOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSettingOnClinicsMutation) OldSettingID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingID: %w", err)
	}
	return oldValue.SettingID, nil
}

// ResetSettingID resets all changes to the "setting_id" field.
func (m *CustomerSettingOnClinicsMutation) ResetSettingID() {
	m.setting = nil
}

// SetSettingName sets the "setting_name" field.
func (m *CustomerSettingOnClinicsMutation) SetSettingName(s string) {
	m.setting_name = &s
}

// SettingName returns the value of the "setting_name" field in the mutation.
func (m *CustomerSettingOnClinicsMutation) SettingName() (r string, exists bool) {
	v := m.setting_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingName returns the old "setting_name" field's value of the CustomerSettingOnClinics entity.
// If the CustomerSettingOnClinics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSettingOnClinicsMutation) OldSettingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingName: %w", err)
	}
	return oldValue.SettingName, nil
}

// ResetSettingName resets all changes to the "setting_name" field.
func (m *CustomerSettingOnClinicsMutation) ResetSettingName() {
	m.setting_name = nil
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerSettingOnClinicsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customersettingonclinics.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerSettingOnClinicsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerSettingOnClinicsMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerSettingOnClinicsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *CustomerSettingOnClinicsMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[customersettingonclinics.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *CustomerSettingOnClinicsMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *CustomerSettingOnClinicsMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *CustomerSettingOnClinicsMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearSetting clears the "setting" edge to the Setting entity.
func (m *CustomerSettingOnClinicsMutation) ClearSetting() {
	m.clearedsetting = true
	m.clearedFields[customersettingonclinics.FieldSettingID] = struct{}{}
}

// SettingCleared reports if the "setting" edge to the Setting entity was cleared.
func (m *CustomerSettingOnClinicsMutation) SettingCleared() bool {
	return m.clearedsetting
}

// SettingIDs returns the "setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingID instead. It exists only for internal usage by the builders.
func (m *CustomerSettingOnClinicsMutation) SettingIDs() (ids []int) {
	if id := m.setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSetting resets all changes to the "setting" edge.
func (m *CustomerSettingOnClinicsMutation) ResetSetting() {
	m.setting = nil
	m.clearedsetting = false
}

// Where appends a list predicates to the CustomerSettingOnClinicsMutation builder.
func (m *CustomerSettingOnClinicsMutation) Where(ps ...predicate.CustomerSettingOnClinics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerSettingOnClinicsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerSettingOnClinicsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerSettingOnClinics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerSettingOnClinicsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerSettingOnClinicsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerSettingOnClinics).
func (m *CustomerSettingOnClinicsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerSettingOnClinicsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.customer != nil {
		fields = append(fields, customersettingonclinics.FieldCustomerID)
	}
	if m.clinic != nil {
		fields = append(fields, customersettingonclinics.FieldClinicID)
	}
	if m.setting != nil {
		fields = append(fields, customersettingonclinics.FieldSettingID)
	}
	if m.setting_name != nil {
		fields = append(fields, customersettingonclinics.FieldSettingName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerSettingOnClinicsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customersettingonclinics.FieldCustomerID:
		return m.CustomerID()
	case customersettingonclinics.FieldClinicID:
		return m.ClinicID()
	case customersettingonclinics.FieldSettingID:
		return m.SettingID()
	case customersettingonclinics.FieldSettingName:
		return m.SettingName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerSettingOnClinicsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customersettingonclinics.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customersettingonclinics.FieldClinicID:
		return m.OldClinicID(ctx)
	case customersettingonclinics.FieldSettingID:
		return m.OldSettingID(ctx)
	case customersettingonclinics.FieldSettingName:
		return m.OldSettingName(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerSettingOnClinics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSettingOnClinicsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customersettingonclinics.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customersettingonclinics.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case customersettingonclinics.FieldSettingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingID(v)
		return nil
	case customersettingonclinics.FieldSettingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingName(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerSettingOnClinics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerSettingOnClinicsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerSettingOnClinicsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSettingOnClinicsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerSettingOnClinics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerSettingOnClinicsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerSettingOnClinicsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerSettingOnClinicsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomerSettingOnClinics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerSettingOnClinicsMutation) ResetField(name string) error {
	switch name {
	case customersettingonclinics.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customersettingonclinics.FieldClinicID:
		m.ResetClinicID()
		return nil
	case customersettingonclinics.FieldSettingID:
		m.ResetSettingID()
		return nil
	case customersettingonclinics.FieldSettingName:
		m.ResetSettingName()
		return nil
	}
	return fmt.Errorf("unknown CustomerSettingOnClinics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerSettingOnClinicsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.customer != nil {
		edges = append(edges, customersettingonclinics.EdgeCustomer)
	}
	if m.clinic != nil {
		edges = append(edges, customersettingonclinics.EdgeClinic)
	}
	if m.setting != nil {
		edges = append(edges, customersettingonclinics.EdgeSetting)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerSettingOnClinicsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customersettingonclinics.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customersettingonclinics.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case customersettingonclinics.EdgeSetting:
		if id := m.setting; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerSettingOnClinicsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerSettingOnClinicsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerSettingOnClinicsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcustomer {
		edges = append(edges, customersettingonclinics.EdgeCustomer)
	}
	if m.clearedclinic {
		edges = append(edges, customersettingonclinics.EdgeClinic)
	}
	if m.clearedsetting {
		edges = append(edges, customersettingonclinics.EdgeSetting)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerSettingOnClinicsMutation) EdgeCleared(name string) bool {
	switch name {
	case customersettingonclinics.EdgeCustomer:
		return m.clearedcustomer
	case customersettingonclinics.EdgeClinic:
		return m.clearedclinic
	case customersettingonclinics.EdgeSetting:
		return m.clearedsetting
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerSettingOnClinicsMutation) ClearEdge(name string) error {
	switch name {
	case customersettingonclinics.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customersettingonclinics.EdgeClinic:
		m.ClearClinic()
		return nil
	case customersettingonclinics.EdgeSetting:
		m.ClearSetting()
		return nil
	}
	return fmt.Errorf("unknown CustomerSettingOnClinics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerSettingOnClinicsMutation) ResetEdge(name string) error {
	switch name {
	case customersettingonclinics.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customersettingonclinics.EdgeClinic:
		m.ResetClinic()
		return nil
	case customersettingonclinics.EdgeSetting:
		m.ResetSetting()
		return nil
	}
	return fmt.Errorf("unknown CustomerSettingOnClinics edge %s", name)
}

// InternalUserMutation represents an operation that mutates the InternalUser nodes in the graph.
type InternalUserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	internal_user_role             *string
	internal_user_name             *string
	internal_user_firstname        *string
	internal_user_lastname         *string
	internal_user_middle_name      *string
	internal_user_is_full_time     *bool
	internal_user_email            *string
	internal_user_phone            *string
	isActive                       *bool
	internal_user_type             *string
	internal_user_role_id          *int
	addinternal_user_role_id       *int
	clearedFields                  map[string]struct{}
	sales_team                     map[int]struct{}
	removedsales_team              map[int]struct{}
	clearedsales_team              bool
	internal_user_contacts         map[int]struct{}
	removedinternal_user_contacts  map[int]struct{}
	clearedinternal_user_contacts  bool
	internal_user_addresses        map[int]struct{}
	removedinternal_user_addresses map[int]struct{}
	clearedinternal_user_addresses bool
	customers                      map[int]struct{}
	removedcustomers               map[int]struct{}
	clearedcustomers               bool
	user                           *int
	cleareduser                    bool
	internal_user_settings         map[int]struct{}
	removedinternal_user_settings  map[int]struct{}
	clearedinternal_user_settings  bool
	done                           bool
	oldValue                       func(context.Context) (*InternalUser, error)
	predicates                     []predicate.InternalUser
}

var _ ent.Mutation = (*InternalUserMutation)(nil)

// internaluserOption allows management of the mutation configuration using functional options.
type internaluserOption func(*InternalUserMutation)

// newInternalUserMutation creates new mutation for the InternalUser entity.
func newInternalUserMutation(c config, op Op, opts ...internaluserOption) *InternalUserMutation {
	m := &InternalUserMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalUserID sets the ID field of the mutation.
func withInternalUserID(id int) internaluserOption {
	return func(m *InternalUserMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalUser
		)
		m.oldValue = func(ctx context.Context) (*InternalUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalUser sets the old InternalUser of the mutation.
func withInternalUser(node *InternalUser) internaluserOption {
	return func(m *InternalUserMutation) {
		m.oldValue = func(context.Context) (*InternalUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalUser entities.
func (m *InternalUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalUserRole sets the "internal_user_role" field.
func (m *InternalUserMutation) SetInternalUserRole(s string) {
	m.internal_user_role = &s
}

// InternalUserRole returns the value of the "internal_user_role" field in the mutation.
func (m *InternalUserMutation) InternalUserRole() (r string, exists bool) {
	v := m.internal_user_role
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserRole returns the old "internal_user_role" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserRole: %w", err)
	}
	return oldValue.InternalUserRole, nil
}

// ResetInternalUserRole resets all changes to the "internal_user_role" field.
func (m *InternalUserMutation) ResetInternalUserRole() {
	m.internal_user_role = nil
}

// SetInternalUserName sets the "internal_user_name" field.
func (m *InternalUserMutation) SetInternalUserName(s string) {
	m.internal_user_name = &s
}

// InternalUserName returns the value of the "internal_user_name" field in the mutation.
func (m *InternalUserMutation) InternalUserName() (r string, exists bool) {
	v := m.internal_user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserName returns the old "internal_user_name" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserName: %w", err)
	}
	return oldValue.InternalUserName, nil
}

// ClearInternalUserName clears the value of the "internal_user_name" field.
func (m *InternalUserMutation) ClearInternalUserName() {
	m.internal_user_name = nil
	m.clearedFields[internaluser.FieldInternalUserName] = struct{}{}
}

// InternalUserNameCleared returns if the "internal_user_name" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserNameCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserName]
	return ok
}

// ResetInternalUserName resets all changes to the "internal_user_name" field.
func (m *InternalUserMutation) ResetInternalUserName() {
	m.internal_user_name = nil
	delete(m.clearedFields, internaluser.FieldInternalUserName)
}

// SetInternalUserFirstname sets the "internal_user_firstname" field.
func (m *InternalUserMutation) SetInternalUserFirstname(s string) {
	m.internal_user_firstname = &s
}

// InternalUserFirstname returns the value of the "internal_user_firstname" field in the mutation.
func (m *InternalUserMutation) InternalUserFirstname() (r string, exists bool) {
	v := m.internal_user_firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserFirstname returns the old "internal_user_firstname" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserFirstname: %w", err)
	}
	return oldValue.InternalUserFirstname, nil
}

// ClearInternalUserFirstname clears the value of the "internal_user_firstname" field.
func (m *InternalUserMutation) ClearInternalUserFirstname() {
	m.internal_user_firstname = nil
	m.clearedFields[internaluser.FieldInternalUserFirstname] = struct{}{}
}

// InternalUserFirstnameCleared returns if the "internal_user_firstname" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserFirstnameCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserFirstname]
	return ok
}

// ResetInternalUserFirstname resets all changes to the "internal_user_firstname" field.
func (m *InternalUserMutation) ResetInternalUserFirstname() {
	m.internal_user_firstname = nil
	delete(m.clearedFields, internaluser.FieldInternalUserFirstname)
}

// SetInternalUserLastname sets the "internal_user_lastname" field.
func (m *InternalUserMutation) SetInternalUserLastname(s string) {
	m.internal_user_lastname = &s
}

// InternalUserLastname returns the value of the "internal_user_lastname" field in the mutation.
func (m *InternalUserMutation) InternalUserLastname() (r string, exists bool) {
	v := m.internal_user_lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserLastname returns the old "internal_user_lastname" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserLastname: %w", err)
	}
	return oldValue.InternalUserLastname, nil
}

// ClearInternalUserLastname clears the value of the "internal_user_lastname" field.
func (m *InternalUserMutation) ClearInternalUserLastname() {
	m.internal_user_lastname = nil
	m.clearedFields[internaluser.FieldInternalUserLastname] = struct{}{}
}

// InternalUserLastnameCleared returns if the "internal_user_lastname" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserLastnameCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserLastname]
	return ok
}

// ResetInternalUserLastname resets all changes to the "internal_user_lastname" field.
func (m *InternalUserMutation) ResetInternalUserLastname() {
	m.internal_user_lastname = nil
	delete(m.clearedFields, internaluser.FieldInternalUserLastname)
}

// SetInternalUserMiddleName sets the "internal_user_middle_name" field.
func (m *InternalUserMutation) SetInternalUserMiddleName(s string) {
	m.internal_user_middle_name = &s
}

// InternalUserMiddleName returns the value of the "internal_user_middle_name" field in the mutation.
func (m *InternalUserMutation) InternalUserMiddleName() (r string, exists bool) {
	v := m.internal_user_middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserMiddleName returns the old "internal_user_middle_name" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserMiddleName: %w", err)
	}
	return oldValue.InternalUserMiddleName, nil
}

// ClearInternalUserMiddleName clears the value of the "internal_user_middle_name" field.
func (m *InternalUserMutation) ClearInternalUserMiddleName() {
	m.internal_user_middle_name = nil
	m.clearedFields[internaluser.FieldInternalUserMiddleName] = struct{}{}
}

// InternalUserMiddleNameCleared returns if the "internal_user_middle_name" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserMiddleNameCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserMiddleName]
	return ok
}

// ResetInternalUserMiddleName resets all changes to the "internal_user_middle_name" field.
func (m *InternalUserMutation) ResetInternalUserMiddleName() {
	m.internal_user_middle_name = nil
	delete(m.clearedFields, internaluser.FieldInternalUserMiddleName)
}

// SetInternalUserIsFullTime sets the "internal_user_is_full_time" field.
func (m *InternalUserMutation) SetInternalUserIsFullTime(b bool) {
	m.internal_user_is_full_time = &b
}

// InternalUserIsFullTime returns the value of the "internal_user_is_full_time" field in the mutation.
func (m *InternalUserMutation) InternalUserIsFullTime() (r bool, exists bool) {
	v := m.internal_user_is_full_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserIsFullTime returns the old "internal_user_is_full_time" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserIsFullTime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserIsFullTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserIsFullTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserIsFullTime: %w", err)
	}
	return oldValue.InternalUserIsFullTime, nil
}

// ResetInternalUserIsFullTime resets all changes to the "internal_user_is_full_time" field.
func (m *InternalUserMutation) ResetInternalUserIsFullTime() {
	m.internal_user_is_full_time = nil
}

// SetInternalUserEmail sets the "internal_user_email" field.
func (m *InternalUserMutation) SetInternalUserEmail(s string) {
	m.internal_user_email = &s
}

// InternalUserEmail returns the value of the "internal_user_email" field in the mutation.
func (m *InternalUserMutation) InternalUserEmail() (r string, exists bool) {
	v := m.internal_user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserEmail returns the old "internal_user_email" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserEmail: %w", err)
	}
	return oldValue.InternalUserEmail, nil
}

// ClearInternalUserEmail clears the value of the "internal_user_email" field.
func (m *InternalUserMutation) ClearInternalUserEmail() {
	m.internal_user_email = nil
	m.clearedFields[internaluser.FieldInternalUserEmail] = struct{}{}
}

// InternalUserEmailCleared returns if the "internal_user_email" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserEmailCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserEmail]
	return ok
}

// ResetInternalUserEmail resets all changes to the "internal_user_email" field.
func (m *InternalUserMutation) ResetInternalUserEmail() {
	m.internal_user_email = nil
	delete(m.clearedFields, internaluser.FieldInternalUserEmail)
}

// SetInternalUserPhone sets the "internal_user_phone" field.
func (m *InternalUserMutation) SetInternalUserPhone(s string) {
	m.internal_user_phone = &s
}

// InternalUserPhone returns the value of the "internal_user_phone" field in the mutation.
func (m *InternalUserMutation) InternalUserPhone() (r string, exists bool) {
	v := m.internal_user_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserPhone returns the old "internal_user_phone" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserPhone: %w", err)
	}
	return oldValue.InternalUserPhone, nil
}

// ClearInternalUserPhone clears the value of the "internal_user_phone" field.
func (m *InternalUserMutation) ClearInternalUserPhone() {
	m.internal_user_phone = nil
	m.clearedFields[internaluser.FieldInternalUserPhone] = struct{}{}
}

// InternalUserPhoneCleared returns if the "internal_user_phone" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserPhoneCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserPhone]
	return ok
}

// ResetInternalUserPhone resets all changes to the "internal_user_phone" field.
func (m *InternalUserMutation) ResetInternalUserPhone() {
	m.internal_user_phone = nil
	delete(m.clearedFields, internaluser.FieldInternalUserPhone)
}

// SetIsActive sets the "isActive" field.
func (m *InternalUserMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *InternalUserMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *InternalUserMutation) ResetIsActive() {
	m.isActive = nil
}

// SetUserID sets the "user_id" field.
func (m *InternalUserMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InternalUserMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *InternalUserMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[internaluser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *InternalUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InternalUserMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, internaluser.FieldUserID)
}

// SetInternalUserType sets the "internal_user_type" field.
func (m *InternalUserMutation) SetInternalUserType(s string) {
	m.internal_user_type = &s
}

// InternalUserType returns the value of the "internal_user_type" field in the mutation.
func (m *InternalUserMutation) InternalUserType() (r string, exists bool) {
	v := m.internal_user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserType returns the old "internal_user_type" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserType: %w", err)
	}
	return oldValue.InternalUserType, nil
}

// ClearInternalUserType clears the value of the "internal_user_type" field.
func (m *InternalUserMutation) ClearInternalUserType() {
	m.internal_user_type = nil
	m.clearedFields[internaluser.FieldInternalUserType] = struct{}{}
}

// InternalUserTypeCleared returns if the "internal_user_type" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserTypeCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserType]
	return ok
}

// ResetInternalUserType resets all changes to the "internal_user_type" field.
func (m *InternalUserMutation) ResetInternalUserType() {
	m.internal_user_type = nil
	delete(m.clearedFields, internaluser.FieldInternalUserType)
}

// SetInternalUserRoleID sets the "internal_user_role_id" field.
func (m *InternalUserMutation) SetInternalUserRoleID(i int) {
	m.internal_user_role_id = &i
	m.addinternal_user_role_id = nil
}

// InternalUserRoleID returns the value of the "internal_user_role_id" field in the mutation.
func (m *InternalUserMutation) InternalUserRoleID() (r int, exists bool) {
	v := m.internal_user_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserRoleID returns the old "internal_user_role_id" field's value of the InternalUser entity.
// If the InternalUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalUserMutation) OldInternalUserRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserRoleID: %w", err)
	}
	return oldValue.InternalUserRoleID, nil
}

// AddInternalUserRoleID adds i to the "internal_user_role_id" field.
func (m *InternalUserMutation) AddInternalUserRoleID(i int) {
	if m.addinternal_user_role_id != nil {
		*m.addinternal_user_role_id += i
	} else {
		m.addinternal_user_role_id = &i
	}
}

// AddedInternalUserRoleID returns the value that was added to the "internal_user_role_id" field in this mutation.
func (m *InternalUserMutation) AddedInternalUserRoleID() (r int, exists bool) {
	v := m.addinternal_user_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInternalUserRoleID clears the value of the "internal_user_role_id" field.
func (m *InternalUserMutation) ClearInternalUserRoleID() {
	m.internal_user_role_id = nil
	m.addinternal_user_role_id = nil
	m.clearedFields[internaluser.FieldInternalUserRoleID] = struct{}{}
}

// InternalUserRoleIDCleared returns if the "internal_user_role_id" field was cleared in this mutation.
func (m *InternalUserMutation) InternalUserRoleIDCleared() bool {
	_, ok := m.clearedFields[internaluser.FieldInternalUserRoleID]
	return ok
}

// ResetInternalUserRoleID resets all changes to the "internal_user_role_id" field.
func (m *InternalUserMutation) ResetInternalUserRoleID() {
	m.internal_user_role_id = nil
	m.addinternal_user_role_id = nil
	delete(m.clearedFields, internaluser.FieldInternalUserRoleID)
}

// AddSalesTeamIDs adds the "sales_team" edge to the SalesTeam entity by ids.
func (m *InternalUserMutation) AddSalesTeamIDs(ids ...int) {
	if m.sales_team == nil {
		m.sales_team = make(map[int]struct{})
	}
	for i := range ids {
		m.sales_team[ids[i]] = struct{}{}
	}
}

// ClearSalesTeam clears the "sales_team" edge to the SalesTeam entity.
func (m *InternalUserMutation) ClearSalesTeam() {
	m.clearedsales_team = true
}

// SalesTeamCleared reports if the "sales_team" edge to the SalesTeam entity was cleared.
func (m *InternalUserMutation) SalesTeamCleared() bool {
	return m.clearedsales_team
}

// RemoveSalesTeamIDs removes the "sales_team" edge to the SalesTeam entity by IDs.
func (m *InternalUserMutation) RemoveSalesTeamIDs(ids ...int) {
	if m.removedsales_team == nil {
		m.removedsales_team = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sales_team, ids[i])
		m.removedsales_team[ids[i]] = struct{}{}
	}
}

// RemovedSalesTeam returns the removed IDs of the "sales_team" edge to the SalesTeam entity.
func (m *InternalUserMutation) RemovedSalesTeamIDs() (ids []int) {
	for id := range m.removedsales_team {
		ids = append(ids, id)
	}
	return
}

// SalesTeamIDs returns the "sales_team" edge IDs in the mutation.
func (m *InternalUserMutation) SalesTeamIDs() (ids []int) {
	for id := range m.sales_team {
		ids = append(ids, id)
	}
	return
}

// ResetSalesTeam resets all changes to the "sales_team" edge.
func (m *InternalUserMutation) ResetSalesTeam() {
	m.sales_team = nil
	m.clearedsales_team = false
	m.removedsales_team = nil
}

// AddInternalUserContactIDs adds the "internal_user_contacts" edge to the Contact entity by ids.
func (m *InternalUserMutation) AddInternalUserContactIDs(ids ...int) {
	if m.internal_user_contacts == nil {
		m.internal_user_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.internal_user_contacts[ids[i]] = struct{}{}
	}
}

// ClearInternalUserContacts clears the "internal_user_contacts" edge to the Contact entity.
func (m *InternalUserMutation) ClearInternalUserContacts() {
	m.clearedinternal_user_contacts = true
}

// InternalUserContactsCleared reports if the "internal_user_contacts" edge to the Contact entity was cleared.
func (m *InternalUserMutation) InternalUserContactsCleared() bool {
	return m.clearedinternal_user_contacts
}

// RemoveInternalUserContactIDs removes the "internal_user_contacts" edge to the Contact entity by IDs.
func (m *InternalUserMutation) RemoveInternalUserContactIDs(ids ...int) {
	if m.removedinternal_user_contacts == nil {
		m.removedinternal_user_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.internal_user_contacts, ids[i])
		m.removedinternal_user_contacts[ids[i]] = struct{}{}
	}
}

// RemovedInternalUserContacts returns the removed IDs of the "internal_user_contacts" edge to the Contact entity.
func (m *InternalUserMutation) RemovedInternalUserContactsIDs() (ids []int) {
	for id := range m.removedinternal_user_contacts {
		ids = append(ids, id)
	}
	return
}

// InternalUserContactsIDs returns the "internal_user_contacts" edge IDs in the mutation.
func (m *InternalUserMutation) InternalUserContactsIDs() (ids []int) {
	for id := range m.internal_user_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetInternalUserContacts resets all changes to the "internal_user_contacts" edge.
func (m *InternalUserMutation) ResetInternalUserContacts() {
	m.internal_user_contacts = nil
	m.clearedinternal_user_contacts = false
	m.removedinternal_user_contacts = nil
}

// AddInternalUserAddressIDs adds the "internal_user_addresses" edge to the Address entity by ids.
func (m *InternalUserMutation) AddInternalUserAddressIDs(ids ...int) {
	if m.internal_user_addresses == nil {
		m.internal_user_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.internal_user_addresses[ids[i]] = struct{}{}
	}
}

// ClearInternalUserAddresses clears the "internal_user_addresses" edge to the Address entity.
func (m *InternalUserMutation) ClearInternalUserAddresses() {
	m.clearedinternal_user_addresses = true
}

// InternalUserAddressesCleared reports if the "internal_user_addresses" edge to the Address entity was cleared.
func (m *InternalUserMutation) InternalUserAddressesCleared() bool {
	return m.clearedinternal_user_addresses
}

// RemoveInternalUserAddressIDs removes the "internal_user_addresses" edge to the Address entity by IDs.
func (m *InternalUserMutation) RemoveInternalUserAddressIDs(ids ...int) {
	if m.removedinternal_user_addresses == nil {
		m.removedinternal_user_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.internal_user_addresses, ids[i])
		m.removedinternal_user_addresses[ids[i]] = struct{}{}
	}
}

// RemovedInternalUserAddresses returns the removed IDs of the "internal_user_addresses" edge to the Address entity.
func (m *InternalUserMutation) RemovedInternalUserAddressesIDs() (ids []int) {
	for id := range m.removedinternal_user_addresses {
		ids = append(ids, id)
	}
	return
}

// InternalUserAddressesIDs returns the "internal_user_addresses" edge IDs in the mutation.
func (m *InternalUserMutation) InternalUserAddressesIDs() (ids []int) {
	for id := range m.internal_user_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetInternalUserAddresses resets all changes to the "internal_user_addresses" edge.
func (m *InternalUserMutation) ResetInternalUserAddresses() {
	m.internal_user_addresses = nil
	m.clearedinternal_user_addresses = false
	m.removedinternal_user_addresses = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *InternalUserMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *InternalUserMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *InternalUserMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *InternalUserMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *InternalUserMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *InternalUserMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *InternalUserMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InternalUserMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[internaluser.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InternalUserMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InternalUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InternalUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddInternalUserSettingIDs adds the "internal_user_settings" edge to the Setting entity by ids.
func (m *InternalUserMutation) AddInternalUserSettingIDs(ids ...int) {
	if m.internal_user_settings == nil {
		m.internal_user_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.internal_user_settings[ids[i]] = struct{}{}
	}
}

// ClearInternalUserSettings clears the "internal_user_settings" edge to the Setting entity.
func (m *InternalUserMutation) ClearInternalUserSettings() {
	m.clearedinternal_user_settings = true
}

// InternalUserSettingsCleared reports if the "internal_user_settings" edge to the Setting entity was cleared.
func (m *InternalUserMutation) InternalUserSettingsCleared() bool {
	return m.clearedinternal_user_settings
}

// RemoveInternalUserSettingIDs removes the "internal_user_settings" edge to the Setting entity by IDs.
func (m *InternalUserMutation) RemoveInternalUserSettingIDs(ids ...int) {
	if m.removedinternal_user_settings == nil {
		m.removedinternal_user_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.internal_user_settings, ids[i])
		m.removedinternal_user_settings[ids[i]] = struct{}{}
	}
}

// RemovedInternalUserSettings returns the removed IDs of the "internal_user_settings" edge to the Setting entity.
func (m *InternalUserMutation) RemovedInternalUserSettingsIDs() (ids []int) {
	for id := range m.removedinternal_user_settings {
		ids = append(ids, id)
	}
	return
}

// InternalUserSettingsIDs returns the "internal_user_settings" edge IDs in the mutation.
func (m *InternalUserMutation) InternalUserSettingsIDs() (ids []int) {
	for id := range m.internal_user_settings {
		ids = append(ids, id)
	}
	return
}

// ResetInternalUserSettings resets all changes to the "internal_user_settings" edge.
func (m *InternalUserMutation) ResetInternalUserSettings() {
	m.internal_user_settings = nil
	m.clearedinternal_user_settings = false
	m.removedinternal_user_settings = nil
}

// Where appends a list predicates to the InternalUserMutation builder.
func (m *InternalUserMutation) Where(ps ...predicate.InternalUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalUser).
func (m *InternalUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalUserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.internal_user_role != nil {
		fields = append(fields, internaluser.FieldInternalUserRole)
	}
	if m.internal_user_name != nil {
		fields = append(fields, internaluser.FieldInternalUserName)
	}
	if m.internal_user_firstname != nil {
		fields = append(fields, internaluser.FieldInternalUserFirstname)
	}
	if m.internal_user_lastname != nil {
		fields = append(fields, internaluser.FieldInternalUserLastname)
	}
	if m.internal_user_middle_name != nil {
		fields = append(fields, internaluser.FieldInternalUserMiddleName)
	}
	if m.internal_user_is_full_time != nil {
		fields = append(fields, internaluser.FieldInternalUserIsFullTime)
	}
	if m.internal_user_email != nil {
		fields = append(fields, internaluser.FieldInternalUserEmail)
	}
	if m.internal_user_phone != nil {
		fields = append(fields, internaluser.FieldInternalUserPhone)
	}
	if m.isActive != nil {
		fields = append(fields, internaluser.FieldIsActive)
	}
	if m.user != nil {
		fields = append(fields, internaluser.FieldUserID)
	}
	if m.internal_user_type != nil {
		fields = append(fields, internaluser.FieldInternalUserType)
	}
	if m.internal_user_role_id != nil {
		fields = append(fields, internaluser.FieldInternalUserRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internaluser.FieldInternalUserRole:
		return m.InternalUserRole()
	case internaluser.FieldInternalUserName:
		return m.InternalUserName()
	case internaluser.FieldInternalUserFirstname:
		return m.InternalUserFirstname()
	case internaluser.FieldInternalUserLastname:
		return m.InternalUserLastname()
	case internaluser.FieldInternalUserMiddleName:
		return m.InternalUserMiddleName()
	case internaluser.FieldInternalUserIsFullTime:
		return m.InternalUserIsFullTime()
	case internaluser.FieldInternalUserEmail:
		return m.InternalUserEmail()
	case internaluser.FieldInternalUserPhone:
		return m.InternalUserPhone()
	case internaluser.FieldIsActive:
		return m.IsActive()
	case internaluser.FieldUserID:
		return m.UserID()
	case internaluser.FieldInternalUserType:
		return m.InternalUserType()
	case internaluser.FieldInternalUserRoleID:
		return m.InternalUserRoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internaluser.FieldInternalUserRole:
		return m.OldInternalUserRole(ctx)
	case internaluser.FieldInternalUserName:
		return m.OldInternalUserName(ctx)
	case internaluser.FieldInternalUserFirstname:
		return m.OldInternalUserFirstname(ctx)
	case internaluser.FieldInternalUserLastname:
		return m.OldInternalUserLastname(ctx)
	case internaluser.FieldInternalUserMiddleName:
		return m.OldInternalUserMiddleName(ctx)
	case internaluser.FieldInternalUserIsFullTime:
		return m.OldInternalUserIsFullTime(ctx)
	case internaluser.FieldInternalUserEmail:
		return m.OldInternalUserEmail(ctx)
	case internaluser.FieldInternalUserPhone:
		return m.OldInternalUserPhone(ctx)
	case internaluser.FieldIsActive:
		return m.OldIsActive(ctx)
	case internaluser.FieldUserID:
		return m.OldUserID(ctx)
	case internaluser.FieldInternalUserType:
		return m.OldInternalUserType(ctx)
	case internaluser.FieldInternalUserRoleID:
		return m.OldInternalUserRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown InternalUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internaluser.FieldInternalUserRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserRole(v)
		return nil
	case internaluser.FieldInternalUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserName(v)
		return nil
	case internaluser.FieldInternalUserFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserFirstname(v)
		return nil
	case internaluser.FieldInternalUserLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserLastname(v)
		return nil
	case internaluser.FieldInternalUserMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserMiddleName(v)
		return nil
	case internaluser.FieldInternalUserIsFullTime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserIsFullTime(v)
		return nil
	case internaluser.FieldInternalUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserEmail(v)
		return nil
	case internaluser.FieldInternalUserPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserPhone(v)
		return nil
	case internaluser.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case internaluser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case internaluser.FieldInternalUserType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserType(v)
		return nil
	case internaluser.FieldInternalUserRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalUserMutation) AddedFields() []string {
	var fields []string
	if m.addinternal_user_role_id != nil {
		fields = append(fields, internaluser.FieldInternalUserRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case internaluser.FieldInternalUserRoleID:
		return m.AddedInternalUserRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case internaluser.FieldInternalUserRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInternalUserRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internaluser.FieldInternalUserName) {
		fields = append(fields, internaluser.FieldInternalUserName)
	}
	if m.FieldCleared(internaluser.FieldInternalUserFirstname) {
		fields = append(fields, internaluser.FieldInternalUserFirstname)
	}
	if m.FieldCleared(internaluser.FieldInternalUserLastname) {
		fields = append(fields, internaluser.FieldInternalUserLastname)
	}
	if m.FieldCleared(internaluser.FieldInternalUserMiddleName) {
		fields = append(fields, internaluser.FieldInternalUserMiddleName)
	}
	if m.FieldCleared(internaluser.FieldInternalUserEmail) {
		fields = append(fields, internaluser.FieldInternalUserEmail)
	}
	if m.FieldCleared(internaluser.FieldInternalUserPhone) {
		fields = append(fields, internaluser.FieldInternalUserPhone)
	}
	if m.FieldCleared(internaluser.FieldUserID) {
		fields = append(fields, internaluser.FieldUserID)
	}
	if m.FieldCleared(internaluser.FieldInternalUserType) {
		fields = append(fields, internaluser.FieldInternalUserType)
	}
	if m.FieldCleared(internaluser.FieldInternalUserRoleID) {
		fields = append(fields, internaluser.FieldInternalUserRoleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalUserMutation) ClearField(name string) error {
	switch name {
	case internaluser.FieldInternalUserName:
		m.ClearInternalUserName()
		return nil
	case internaluser.FieldInternalUserFirstname:
		m.ClearInternalUserFirstname()
		return nil
	case internaluser.FieldInternalUserLastname:
		m.ClearInternalUserLastname()
		return nil
	case internaluser.FieldInternalUserMiddleName:
		m.ClearInternalUserMiddleName()
		return nil
	case internaluser.FieldInternalUserEmail:
		m.ClearInternalUserEmail()
		return nil
	case internaluser.FieldInternalUserPhone:
		m.ClearInternalUserPhone()
		return nil
	case internaluser.FieldUserID:
		m.ClearUserID()
		return nil
	case internaluser.FieldInternalUserType:
		m.ClearInternalUserType()
		return nil
	case internaluser.FieldInternalUserRoleID:
		m.ClearInternalUserRoleID()
		return nil
	}
	return fmt.Errorf("unknown InternalUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalUserMutation) ResetField(name string) error {
	switch name {
	case internaluser.FieldInternalUserRole:
		m.ResetInternalUserRole()
		return nil
	case internaluser.FieldInternalUserName:
		m.ResetInternalUserName()
		return nil
	case internaluser.FieldInternalUserFirstname:
		m.ResetInternalUserFirstname()
		return nil
	case internaluser.FieldInternalUserLastname:
		m.ResetInternalUserLastname()
		return nil
	case internaluser.FieldInternalUserMiddleName:
		m.ResetInternalUserMiddleName()
		return nil
	case internaluser.FieldInternalUserIsFullTime:
		m.ResetInternalUserIsFullTime()
		return nil
	case internaluser.FieldInternalUserEmail:
		m.ResetInternalUserEmail()
		return nil
	case internaluser.FieldInternalUserPhone:
		m.ResetInternalUserPhone()
		return nil
	case internaluser.FieldIsActive:
		m.ResetIsActive()
		return nil
	case internaluser.FieldUserID:
		m.ResetUserID()
		return nil
	case internaluser.FieldInternalUserType:
		m.ResetInternalUserType()
		return nil
	case internaluser.FieldInternalUserRoleID:
		m.ResetInternalUserRoleID()
		return nil
	}
	return fmt.Errorf("unknown InternalUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.sales_team != nil {
		edges = append(edges, internaluser.EdgeSalesTeam)
	}
	if m.internal_user_contacts != nil {
		edges = append(edges, internaluser.EdgeInternalUserContacts)
	}
	if m.internal_user_addresses != nil {
		edges = append(edges, internaluser.EdgeInternalUserAddresses)
	}
	if m.customers != nil {
		edges = append(edges, internaluser.EdgeCustomers)
	}
	if m.user != nil {
		edges = append(edges, internaluser.EdgeUser)
	}
	if m.internal_user_settings != nil {
		edges = append(edges, internaluser.EdgeInternalUserSettings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case internaluser.EdgeSalesTeam:
		ids := make([]ent.Value, 0, len(m.sales_team))
		for id := range m.sales_team {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeInternalUserContacts:
		ids := make([]ent.Value, 0, len(m.internal_user_contacts))
		for id := range m.internal_user_contacts {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeInternalUserAddresses:
		ids := make([]ent.Value, 0, len(m.internal_user_addresses))
		for id := range m.internal_user_addresses {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case internaluser.EdgeInternalUserSettings:
		ids := make([]ent.Value, 0, len(m.internal_user_settings))
		for id := range m.internal_user_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedsales_team != nil {
		edges = append(edges, internaluser.EdgeSalesTeam)
	}
	if m.removedinternal_user_contacts != nil {
		edges = append(edges, internaluser.EdgeInternalUserContacts)
	}
	if m.removedinternal_user_addresses != nil {
		edges = append(edges, internaluser.EdgeInternalUserAddresses)
	}
	if m.removedcustomers != nil {
		edges = append(edges, internaluser.EdgeCustomers)
	}
	if m.removedinternal_user_settings != nil {
		edges = append(edges, internaluser.EdgeInternalUserSettings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case internaluser.EdgeSalesTeam:
		ids := make([]ent.Value, 0, len(m.removedsales_team))
		for id := range m.removedsales_team {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeInternalUserContacts:
		ids := make([]ent.Value, 0, len(m.removedinternal_user_contacts))
		for id := range m.removedinternal_user_contacts {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeInternalUserAddresses:
		ids := make([]ent.Value, 0, len(m.removedinternal_user_addresses))
		for id := range m.removedinternal_user_addresses {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case internaluser.EdgeInternalUserSettings:
		ids := make([]ent.Value, 0, len(m.removedinternal_user_settings))
		for id := range m.removedinternal_user_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedsales_team {
		edges = append(edges, internaluser.EdgeSalesTeam)
	}
	if m.clearedinternal_user_contacts {
		edges = append(edges, internaluser.EdgeInternalUserContacts)
	}
	if m.clearedinternal_user_addresses {
		edges = append(edges, internaluser.EdgeInternalUserAddresses)
	}
	if m.clearedcustomers {
		edges = append(edges, internaluser.EdgeCustomers)
	}
	if m.cleareduser {
		edges = append(edges, internaluser.EdgeUser)
	}
	if m.clearedinternal_user_settings {
		edges = append(edges, internaluser.EdgeInternalUserSettings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalUserMutation) EdgeCleared(name string) bool {
	switch name {
	case internaluser.EdgeSalesTeam:
		return m.clearedsales_team
	case internaluser.EdgeInternalUserContacts:
		return m.clearedinternal_user_contacts
	case internaluser.EdgeInternalUserAddresses:
		return m.clearedinternal_user_addresses
	case internaluser.EdgeCustomers:
		return m.clearedcustomers
	case internaluser.EdgeUser:
		return m.cleareduser
	case internaluser.EdgeInternalUserSettings:
		return m.clearedinternal_user_settings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalUserMutation) ClearEdge(name string) error {
	switch name {
	case internaluser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown InternalUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalUserMutation) ResetEdge(name string) error {
	switch name {
	case internaluser.EdgeSalesTeam:
		m.ResetSalesTeam()
		return nil
	case internaluser.EdgeInternalUserContacts:
		m.ResetInternalUserContacts()
		return nil
	case internaluser.EdgeInternalUserAddresses:
		m.ResetInternalUserAddresses()
		return nil
	case internaluser.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case internaluser.EdgeUser:
		m.ResetUser()
		return nil
	case internaluser.EdgeInternalUserSettings:
		m.ResetInternalUserSettings()
		return nil
	}
	return fmt.Errorf("unknown InternalUser edge %s", name)
}

// LabOrderSendHistoryMutation represents an operation that mutates the LabOrderSendHistory nodes in the graph.
type LabOrderSendHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	tube_type            *string
	sendout_time         *time.Time
	is_redraw_order      *bool
	is_lab_special_order *bool
	action               *string
	is_resend_blocked    *bool
	clearedFields        map[string]struct{}
	sample               *int
	clearedsample        bool
	done                 bool
	oldValue             func(context.Context) (*LabOrderSendHistory, error)
	predicates           []predicate.LabOrderSendHistory
}

var _ ent.Mutation = (*LabOrderSendHistoryMutation)(nil)

// labordersendhistoryOption allows management of the mutation configuration using functional options.
type labordersendhistoryOption func(*LabOrderSendHistoryMutation)

// newLabOrderSendHistoryMutation creates new mutation for the LabOrderSendHistory entity.
func newLabOrderSendHistoryMutation(c config, op Op, opts ...labordersendhistoryOption) *LabOrderSendHistoryMutation {
	m := &LabOrderSendHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLabOrderSendHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLabOrderSendHistoryID sets the ID field of the mutation.
func withLabOrderSendHistoryID(id int) labordersendhistoryOption {
	return func(m *LabOrderSendHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LabOrderSendHistory
		)
		m.oldValue = func(ctx context.Context) (*LabOrderSendHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LabOrderSendHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLabOrderSendHistory sets the old LabOrderSendHistory of the mutation.
func withLabOrderSendHistory(node *LabOrderSendHistory) labordersendhistoryOption {
	return func(m *LabOrderSendHistoryMutation) {
		m.oldValue = func(context.Context) (*LabOrderSendHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabOrderSendHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabOrderSendHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LabOrderSendHistory entities.
func (m *LabOrderSendHistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabOrderSendHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabOrderSendHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LabOrderSendHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSampleID sets the "sample_id" field.
func (m *LabOrderSendHistoryMutation) SetSampleID(i int) {
	m.sample = &i
}

// SampleID returns the value of the "sample_id" field in the mutation.
func (m *LabOrderSendHistoryMutation) SampleID() (r int, exists bool) {
	v := m.sample
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleID returns the old "sample_id" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldSampleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleID: %w", err)
	}
	return oldValue.SampleID, nil
}

// ResetSampleID resets all changes to the "sample_id" field.
func (m *LabOrderSendHistoryMutation) ResetSampleID() {
	m.sample = nil
}

// SetTubeType sets the "tube_type" field.
func (m *LabOrderSendHistoryMutation) SetTubeType(s string) {
	m.tube_type = &s
}

// TubeType returns the value of the "tube_type" field in the mutation.
func (m *LabOrderSendHistoryMutation) TubeType() (r string, exists bool) {
	v := m.tube_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeType returns the old "tube_type" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldTubeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeType: %w", err)
	}
	return oldValue.TubeType, nil
}

// ResetTubeType resets all changes to the "tube_type" field.
func (m *LabOrderSendHistoryMutation) ResetTubeType() {
	m.tube_type = nil
}

// SetSendoutTime sets the "sendout_time" field.
func (m *LabOrderSendHistoryMutation) SetSendoutTime(t time.Time) {
	m.sendout_time = &t
}

// SendoutTime returns the value of the "sendout_time" field in the mutation.
func (m *LabOrderSendHistoryMutation) SendoutTime() (r time.Time, exists bool) {
	v := m.sendout_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSendoutTime returns the old "sendout_time" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldSendoutTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendoutTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendoutTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendoutTime: %w", err)
	}
	return oldValue.SendoutTime, nil
}

// ClearSendoutTime clears the value of the "sendout_time" field.
func (m *LabOrderSendHistoryMutation) ClearSendoutTime() {
	m.sendout_time = nil
	m.clearedFields[labordersendhistory.FieldSendoutTime] = struct{}{}
}

// SendoutTimeCleared returns if the "sendout_time" field was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) SendoutTimeCleared() bool {
	_, ok := m.clearedFields[labordersendhistory.FieldSendoutTime]
	return ok
}

// ResetSendoutTime resets all changes to the "sendout_time" field.
func (m *LabOrderSendHistoryMutation) ResetSendoutTime() {
	m.sendout_time = nil
	delete(m.clearedFields, labordersendhistory.FieldSendoutTime)
}

// SetIsRedrawOrder sets the "is_redraw_order" field.
func (m *LabOrderSendHistoryMutation) SetIsRedrawOrder(b bool) {
	m.is_redraw_order = &b
}

// IsRedrawOrder returns the value of the "is_redraw_order" field in the mutation.
func (m *LabOrderSendHistoryMutation) IsRedrawOrder() (r bool, exists bool) {
	v := m.is_redraw_order
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRedrawOrder returns the old "is_redraw_order" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldIsRedrawOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRedrawOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRedrawOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRedrawOrder: %w", err)
	}
	return oldValue.IsRedrawOrder, nil
}

// ClearIsRedrawOrder clears the value of the "is_redraw_order" field.
func (m *LabOrderSendHistoryMutation) ClearIsRedrawOrder() {
	m.is_redraw_order = nil
	m.clearedFields[labordersendhistory.FieldIsRedrawOrder] = struct{}{}
}

// IsRedrawOrderCleared returns if the "is_redraw_order" field was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) IsRedrawOrderCleared() bool {
	_, ok := m.clearedFields[labordersendhistory.FieldIsRedrawOrder]
	return ok
}

// ResetIsRedrawOrder resets all changes to the "is_redraw_order" field.
func (m *LabOrderSendHistoryMutation) ResetIsRedrawOrder() {
	m.is_redraw_order = nil
	delete(m.clearedFields, labordersendhistory.FieldIsRedrawOrder)
}

// SetIsLabSpecialOrder sets the "is_lab_special_order" field.
func (m *LabOrderSendHistoryMutation) SetIsLabSpecialOrder(b bool) {
	m.is_lab_special_order = &b
}

// IsLabSpecialOrder returns the value of the "is_lab_special_order" field in the mutation.
func (m *LabOrderSendHistoryMutation) IsLabSpecialOrder() (r bool, exists bool) {
	v := m.is_lab_special_order
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLabSpecialOrder returns the old "is_lab_special_order" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldIsLabSpecialOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLabSpecialOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLabSpecialOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLabSpecialOrder: %w", err)
	}
	return oldValue.IsLabSpecialOrder, nil
}

// ClearIsLabSpecialOrder clears the value of the "is_lab_special_order" field.
func (m *LabOrderSendHistoryMutation) ClearIsLabSpecialOrder() {
	m.is_lab_special_order = nil
	m.clearedFields[labordersendhistory.FieldIsLabSpecialOrder] = struct{}{}
}

// IsLabSpecialOrderCleared returns if the "is_lab_special_order" field was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) IsLabSpecialOrderCleared() bool {
	_, ok := m.clearedFields[labordersendhistory.FieldIsLabSpecialOrder]
	return ok
}

// ResetIsLabSpecialOrder resets all changes to the "is_lab_special_order" field.
func (m *LabOrderSendHistoryMutation) ResetIsLabSpecialOrder() {
	m.is_lab_special_order = nil
	delete(m.clearedFields, labordersendhistory.FieldIsLabSpecialOrder)
}

// SetAction sets the "action" field.
func (m *LabOrderSendHistoryMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *LabOrderSendHistoryMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *LabOrderSendHistoryMutation) ClearAction() {
	m.action = nil
	m.clearedFields[labordersendhistory.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) ActionCleared() bool {
	_, ok := m.clearedFields[labordersendhistory.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *LabOrderSendHistoryMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, labordersendhistory.FieldAction)
}

// SetIsResendBlocked sets the "is_resend_blocked" field.
func (m *LabOrderSendHistoryMutation) SetIsResendBlocked(b bool) {
	m.is_resend_blocked = &b
}

// IsResendBlocked returns the value of the "is_resend_blocked" field in the mutation.
func (m *LabOrderSendHistoryMutation) IsResendBlocked() (r bool, exists bool) {
	v := m.is_resend_blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsResendBlocked returns the old "is_resend_blocked" field's value of the LabOrderSendHistory entity.
// If the LabOrderSendHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabOrderSendHistoryMutation) OldIsResendBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsResendBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsResendBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsResendBlocked: %w", err)
	}
	return oldValue.IsResendBlocked, nil
}

// ClearIsResendBlocked clears the value of the "is_resend_blocked" field.
func (m *LabOrderSendHistoryMutation) ClearIsResendBlocked() {
	m.is_resend_blocked = nil
	m.clearedFields[labordersendhistory.FieldIsResendBlocked] = struct{}{}
}

// IsResendBlockedCleared returns if the "is_resend_blocked" field was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) IsResendBlockedCleared() bool {
	_, ok := m.clearedFields[labordersendhistory.FieldIsResendBlocked]
	return ok
}

// ResetIsResendBlocked resets all changes to the "is_resend_blocked" field.
func (m *LabOrderSendHistoryMutation) ResetIsResendBlocked() {
	m.is_resend_blocked = nil
	delete(m.clearedFields, labordersendhistory.FieldIsResendBlocked)
}

// ClearSample clears the "sample" edge to the Sample entity.
func (m *LabOrderSendHistoryMutation) ClearSample() {
	m.clearedsample = true
	m.clearedFields[labordersendhistory.FieldSampleID] = struct{}{}
}

// SampleCleared reports if the "sample" edge to the Sample entity was cleared.
func (m *LabOrderSendHistoryMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *LabOrderSendHistoryMutation) SampleIDs() (ids []int) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *LabOrderSendHistoryMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the LabOrderSendHistoryMutation builder.
func (m *LabOrderSendHistoryMutation) Where(ps ...predicate.LabOrderSendHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LabOrderSendHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LabOrderSendHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LabOrderSendHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LabOrderSendHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LabOrderSendHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LabOrderSendHistory).
func (m *LabOrderSendHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabOrderSendHistoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.sample != nil {
		fields = append(fields, labordersendhistory.FieldSampleID)
	}
	if m.tube_type != nil {
		fields = append(fields, labordersendhistory.FieldTubeType)
	}
	if m.sendout_time != nil {
		fields = append(fields, labordersendhistory.FieldSendoutTime)
	}
	if m.is_redraw_order != nil {
		fields = append(fields, labordersendhistory.FieldIsRedrawOrder)
	}
	if m.is_lab_special_order != nil {
		fields = append(fields, labordersendhistory.FieldIsLabSpecialOrder)
	}
	if m.action != nil {
		fields = append(fields, labordersendhistory.FieldAction)
	}
	if m.is_resend_blocked != nil {
		fields = append(fields, labordersendhistory.FieldIsResendBlocked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabOrderSendHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case labordersendhistory.FieldSampleID:
		return m.SampleID()
	case labordersendhistory.FieldTubeType:
		return m.TubeType()
	case labordersendhistory.FieldSendoutTime:
		return m.SendoutTime()
	case labordersendhistory.FieldIsRedrawOrder:
		return m.IsRedrawOrder()
	case labordersendhistory.FieldIsLabSpecialOrder:
		return m.IsLabSpecialOrder()
	case labordersendhistory.FieldAction:
		return m.Action()
	case labordersendhistory.FieldIsResendBlocked:
		return m.IsResendBlocked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabOrderSendHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case labordersendhistory.FieldSampleID:
		return m.OldSampleID(ctx)
	case labordersendhistory.FieldTubeType:
		return m.OldTubeType(ctx)
	case labordersendhistory.FieldSendoutTime:
		return m.OldSendoutTime(ctx)
	case labordersendhistory.FieldIsRedrawOrder:
		return m.OldIsRedrawOrder(ctx)
	case labordersendhistory.FieldIsLabSpecialOrder:
		return m.OldIsLabSpecialOrder(ctx)
	case labordersendhistory.FieldAction:
		return m.OldAction(ctx)
	case labordersendhistory.FieldIsResendBlocked:
		return m.OldIsResendBlocked(ctx)
	}
	return nil, fmt.Errorf("unknown LabOrderSendHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabOrderSendHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case labordersendhistory.FieldSampleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleID(v)
		return nil
	case labordersendhistory.FieldTubeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeType(v)
		return nil
	case labordersendhistory.FieldSendoutTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendoutTime(v)
		return nil
	case labordersendhistory.FieldIsRedrawOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRedrawOrder(v)
		return nil
	case labordersendhistory.FieldIsLabSpecialOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLabSpecialOrder(v)
		return nil
	case labordersendhistory.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case labordersendhistory.FieldIsResendBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsResendBlocked(v)
		return nil
	}
	return fmt.Errorf("unknown LabOrderSendHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabOrderSendHistoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabOrderSendHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabOrderSendHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LabOrderSendHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabOrderSendHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(labordersendhistory.FieldSendoutTime) {
		fields = append(fields, labordersendhistory.FieldSendoutTime)
	}
	if m.FieldCleared(labordersendhistory.FieldIsRedrawOrder) {
		fields = append(fields, labordersendhistory.FieldIsRedrawOrder)
	}
	if m.FieldCleared(labordersendhistory.FieldIsLabSpecialOrder) {
		fields = append(fields, labordersendhistory.FieldIsLabSpecialOrder)
	}
	if m.FieldCleared(labordersendhistory.FieldAction) {
		fields = append(fields, labordersendhistory.FieldAction)
	}
	if m.FieldCleared(labordersendhistory.FieldIsResendBlocked) {
		fields = append(fields, labordersendhistory.FieldIsResendBlocked)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabOrderSendHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabOrderSendHistoryMutation) ClearField(name string) error {
	switch name {
	case labordersendhistory.FieldSendoutTime:
		m.ClearSendoutTime()
		return nil
	case labordersendhistory.FieldIsRedrawOrder:
		m.ClearIsRedrawOrder()
		return nil
	case labordersendhistory.FieldIsLabSpecialOrder:
		m.ClearIsLabSpecialOrder()
		return nil
	case labordersendhistory.FieldAction:
		m.ClearAction()
		return nil
	case labordersendhistory.FieldIsResendBlocked:
		m.ClearIsResendBlocked()
		return nil
	}
	return fmt.Errorf("unknown LabOrderSendHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabOrderSendHistoryMutation) ResetField(name string) error {
	switch name {
	case labordersendhistory.FieldSampleID:
		m.ResetSampleID()
		return nil
	case labordersendhistory.FieldTubeType:
		m.ResetTubeType()
		return nil
	case labordersendhistory.FieldSendoutTime:
		m.ResetSendoutTime()
		return nil
	case labordersendhistory.FieldIsRedrawOrder:
		m.ResetIsRedrawOrder()
		return nil
	case labordersendhistory.FieldIsLabSpecialOrder:
		m.ResetIsLabSpecialOrder()
		return nil
	case labordersendhistory.FieldAction:
		m.ResetAction()
		return nil
	case labordersendhistory.FieldIsResendBlocked:
		m.ResetIsResendBlocked()
		return nil
	}
	return fmt.Errorf("unknown LabOrderSendHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabOrderSendHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sample != nil {
		edges = append(edges, labordersendhistory.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabOrderSendHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case labordersendhistory.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabOrderSendHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabOrderSendHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabOrderSendHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsample {
		edges = append(edges, labordersendhistory.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabOrderSendHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case labordersendhistory.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabOrderSendHistoryMutation) ClearEdge(name string) error {
	switch name {
	case labordersendhistory.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown LabOrderSendHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabOrderSendHistoryMutation) ResetEdge(name string) error {
	switch name {
	case labordersendhistory.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown LabOrderSendHistory edge %s", name)
}

// LoginHistoryMutation represents an operation that mutates the LoginHistory nodes in the graph.
type LoginHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	username           *string
	login_time         *time.Time
	login_ip           *string
	login_successfully *bool
	failure_reason     *string
	login_portal       *string
	token              *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*LoginHistory, error)
	predicates         []predicate.LoginHistory
}

var _ ent.Mutation = (*LoginHistoryMutation)(nil)

// loginhistoryOption allows management of the mutation configuration using functional options.
type loginhistoryOption func(*LoginHistoryMutation)

// newLoginHistoryMutation creates new mutation for the LoginHistory entity.
func newLoginHistoryMutation(c config, op Op, opts ...loginhistoryOption) *LoginHistoryMutation {
	m := &LoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginHistoryID sets the ID field of the mutation.
func withLoginHistoryID(id int) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginHistory
		)
		m.oldValue = func(ctx context.Context) (*LoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginHistory sets the old LoginHistory of the mutation.
func withLoginHistory(node *LoginHistory) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		m.oldValue = func(context.Context) (*LoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *LoginHistoryMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *LoginHistoryMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *LoginHistoryMutation) ResetUsername() {
	m.username = nil
}

// SetLoginTime sets the "login_time" field.
func (m *LoginHistoryMutation) SetLoginTime(t time.Time) {
	m.login_time = &t
}

// LoginTime returns the value of the "login_time" field in the mutation.
func (m *LoginHistoryMutation) LoginTime() (r time.Time, exists bool) {
	v := m.login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTime returns the old "login_time" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTime: %w", err)
	}
	return oldValue.LoginTime, nil
}

// ResetLoginTime resets all changes to the "login_time" field.
func (m *LoginHistoryMutation) ResetLoginTime() {
	m.login_time = nil
}

// SetLoginIP sets the "login_ip" field.
func (m *LoginHistoryMutation) SetLoginIP(s string) {
	m.login_ip = &s
}

// LoginIP returns the value of the "login_ip" field in the mutation.
func (m *LoginHistoryMutation) LoginIP() (r string, exists bool) {
	v := m.login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginIP returns the old "login_ip" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginIP: %w", err)
	}
	return oldValue.LoginIP, nil
}

// ResetLoginIP resets all changes to the "login_ip" field.
func (m *LoginHistoryMutation) ResetLoginIP() {
	m.login_ip = nil
}

// SetLoginSuccessfully sets the "login_successfully" field.
func (m *LoginHistoryMutation) SetLoginSuccessfully(b bool) {
	m.login_successfully = &b
}

// LoginSuccessfully returns the value of the "login_successfully" field in the mutation.
func (m *LoginHistoryMutation) LoginSuccessfully() (r bool, exists bool) {
	v := m.login_successfully
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginSuccessfully returns the old "login_successfully" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLoginSuccessfully(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginSuccessfully is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginSuccessfully requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginSuccessfully: %w", err)
	}
	return oldValue.LoginSuccessfully, nil
}

// ResetLoginSuccessfully resets all changes to the "login_successfully" field.
func (m *LoginHistoryMutation) ResetLoginSuccessfully() {
	m.login_successfully = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *LoginHistoryMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *LoginHistoryMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldFailureReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *LoginHistoryMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[loginhistory.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *LoginHistoryMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *LoginHistoryMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, loginhistory.FieldFailureReason)
}

// SetLoginPortal sets the "login_portal" field.
func (m *LoginHistoryMutation) SetLoginPortal(s string) {
	m.login_portal = &s
}

// LoginPortal returns the value of the "login_portal" field in the mutation.
func (m *LoginHistoryMutation) LoginPortal() (r string, exists bool) {
	v := m.login_portal
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginPortal returns the old "login_portal" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLoginPortal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginPortal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginPortal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginPortal: %w", err)
	}
	return oldValue.LoginPortal, nil
}

// ClearLoginPortal clears the value of the "login_portal" field.
func (m *LoginHistoryMutation) ClearLoginPortal() {
	m.login_portal = nil
	m.clearedFields[loginhistory.FieldLoginPortal] = struct{}{}
}

// LoginPortalCleared returns if the "login_portal" field was cleared in this mutation.
func (m *LoginHistoryMutation) LoginPortalCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldLoginPortal]
	return ok
}

// ResetLoginPortal resets all changes to the "login_portal" field.
func (m *LoginHistoryMutation) ResetLoginPortal() {
	m.login_portal = nil
	delete(m.clearedFields, loginhistory.FieldLoginPortal)
}

// SetToken sets the "token" field.
func (m *LoginHistoryMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *LoginHistoryMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *LoginHistoryMutation) ClearToken() {
	m.token = nil
	m.clearedFields[loginhistory.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *LoginHistoryMutation) TokenCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *LoginHistoryMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, loginhistory.FieldToken)
}

// Where appends a list predicates to the LoginHistoryMutation builder.
func (m *LoginHistoryMutation) Where(ps ...predicate.LoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginHistory).
func (m *LoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.username != nil {
		fields = append(fields, loginhistory.FieldUsername)
	}
	if m.login_time != nil {
		fields = append(fields, loginhistory.FieldLoginTime)
	}
	if m.login_ip != nil {
		fields = append(fields, loginhistory.FieldLoginIP)
	}
	if m.login_successfully != nil {
		fields = append(fields, loginhistory.FieldLoginSuccessfully)
	}
	if m.failure_reason != nil {
		fields = append(fields, loginhistory.FieldFailureReason)
	}
	if m.login_portal != nil {
		fields = append(fields, loginhistory.FieldLoginPortal)
	}
	if m.token != nil {
		fields = append(fields, loginhistory.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldUsername:
		return m.Username()
	case loginhistory.FieldLoginTime:
		return m.LoginTime()
	case loginhistory.FieldLoginIP:
		return m.LoginIP()
	case loginhistory.FieldLoginSuccessfully:
		return m.LoginSuccessfully()
	case loginhistory.FieldFailureReason:
		return m.FailureReason()
	case loginhistory.FieldLoginPortal:
		return m.LoginPortal()
	case loginhistory.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginhistory.FieldUsername:
		return m.OldUsername(ctx)
	case loginhistory.FieldLoginTime:
		return m.OldLoginTime(ctx)
	case loginhistory.FieldLoginIP:
		return m.OldLoginIP(ctx)
	case loginhistory.FieldLoginSuccessfully:
		return m.OldLoginSuccessfully(ctx)
	case loginhistory.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case loginhistory.FieldLoginPortal:
		return m.OldLoginPortal(ctx)
	case loginhistory.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown LoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case loginhistory.FieldLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTime(v)
		return nil
	case loginhistory.FieldLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginIP(v)
		return nil
	case loginhistory.FieldLoginSuccessfully:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginSuccessfully(v)
		return nil
	case loginhistory.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case loginhistory.FieldLoginPortal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginPortal(v)
		return nil
	case loginhistory.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginhistory.FieldFailureReason) {
		fields = append(fields, loginhistory.FieldFailureReason)
	}
	if m.FieldCleared(loginhistory.FieldLoginPortal) {
		fields = append(fields, loginhistory.FieldLoginPortal)
	}
	if m.FieldCleared(loginhistory.FieldToken) {
		fields = append(fields, loginhistory.FieldToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ClearField(name string) error {
	switch name {
	case loginhistory.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case loginhistory.FieldLoginPortal:
		m.ClearLoginPortal()
		return nil
	case loginhistory.FieldToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ResetField(name string) error {
	switch name {
	case loginhistory.FieldUsername:
		m.ResetUsername()
		return nil
	case loginhistory.FieldLoginTime:
		m.ResetLoginTime()
		return nil
	case loginhistory.FieldLoginIP:
		m.ResetLoginIP()
		return nil
	case loginhistory.FieldLoginSuccessfully:
		m.ResetLoginSuccessfully()
		return nil
	case loginhistory.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case loginhistory.FieldLoginPortal:
		m.ResetLoginPortal()
		return nil
	case loginhistory.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory edge %s", name)
}

// OrderFlagMutation represents an operation that mutates the OrderFlag nodes in the graph.
type OrderFlagMutation struct {
	config
	op                                              Op
	typ                                             string
	id                                              *int
	order_flag_name                                 *string
	order_flag_description                          *string
	order_flag_display_name                         *string
	order_flag_is_active                            *bool
	order_flag_created_at                           *time.Time
	order_flag_color                                *string
	order_flaged_by                                 *string
	order_flag_allow_duplicates_under_same_category *bool
	order_flag_category                             *string
	order_flag_level                                *int
	addorder_flag_level                             *int
	clearedFields                                   map[string]struct{}
	flagged_orders                                  map[int]struct{}
	removedflagged_orders                           map[int]struct{}
	clearedflagged_orders                           bool
	done                                            bool
	oldValue                                        func(context.Context) (*OrderFlag, error)
	predicates                                      []predicate.OrderFlag
}

var _ ent.Mutation = (*OrderFlagMutation)(nil)

// orderflagOption allows management of the mutation configuration using functional options.
type orderflagOption func(*OrderFlagMutation)

// newOrderFlagMutation creates new mutation for the OrderFlag entity.
func newOrderFlagMutation(c config, op Op, opts ...orderflagOption) *OrderFlagMutation {
	m := &OrderFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderFlagID sets the ID field of the mutation.
func withOrderFlagID(id int) orderflagOption {
	return func(m *OrderFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderFlag
		)
		m.oldValue = func(ctx context.Context) (*OrderFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderFlag sets the old OrderFlag of the mutation.
func withOrderFlag(node *OrderFlag) orderflagOption {
	return func(m *OrderFlagMutation) {
		m.oldValue = func(context.Context) (*OrderFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderFlag entities.
func (m *OrderFlagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderFlagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderFlagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderFlagName sets the "order_flag_name" field.
func (m *OrderFlagMutation) SetOrderFlagName(s string) {
	m.order_flag_name = &s
}

// OrderFlagName returns the value of the "order_flag_name" field in the mutation.
func (m *OrderFlagMutation) OrderFlagName() (r string, exists bool) {
	v := m.order_flag_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagName returns the old "order_flag_name" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagName: %w", err)
	}
	return oldValue.OrderFlagName, nil
}

// ResetOrderFlagName resets all changes to the "order_flag_name" field.
func (m *OrderFlagMutation) ResetOrderFlagName() {
	m.order_flag_name = nil
}

// SetOrderFlagDescription sets the "order_flag_description" field.
func (m *OrderFlagMutation) SetOrderFlagDescription(s string) {
	m.order_flag_description = &s
}

// OrderFlagDescription returns the value of the "order_flag_description" field in the mutation.
func (m *OrderFlagMutation) OrderFlagDescription() (r string, exists bool) {
	v := m.order_flag_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagDescription returns the old "order_flag_description" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagDescription: %w", err)
	}
	return oldValue.OrderFlagDescription, nil
}

// ClearOrderFlagDescription clears the value of the "order_flag_description" field.
func (m *OrderFlagMutation) ClearOrderFlagDescription() {
	m.order_flag_description = nil
	m.clearedFields[orderflag.FieldOrderFlagDescription] = struct{}{}
}

// OrderFlagDescriptionCleared returns if the "order_flag_description" field was cleared in this mutation.
func (m *OrderFlagMutation) OrderFlagDescriptionCleared() bool {
	_, ok := m.clearedFields[orderflag.FieldOrderFlagDescription]
	return ok
}

// ResetOrderFlagDescription resets all changes to the "order_flag_description" field.
func (m *OrderFlagMutation) ResetOrderFlagDescription() {
	m.order_flag_description = nil
	delete(m.clearedFields, orderflag.FieldOrderFlagDescription)
}

// SetOrderFlagDisplayName sets the "order_flag_display_name" field.
func (m *OrderFlagMutation) SetOrderFlagDisplayName(s string) {
	m.order_flag_display_name = &s
}

// OrderFlagDisplayName returns the value of the "order_flag_display_name" field in the mutation.
func (m *OrderFlagMutation) OrderFlagDisplayName() (r string, exists bool) {
	v := m.order_flag_display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagDisplayName returns the old "order_flag_display_name" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagDisplayName: %w", err)
	}
	return oldValue.OrderFlagDisplayName, nil
}

// ClearOrderFlagDisplayName clears the value of the "order_flag_display_name" field.
func (m *OrderFlagMutation) ClearOrderFlagDisplayName() {
	m.order_flag_display_name = nil
	m.clearedFields[orderflag.FieldOrderFlagDisplayName] = struct{}{}
}

// OrderFlagDisplayNameCleared returns if the "order_flag_display_name" field was cleared in this mutation.
func (m *OrderFlagMutation) OrderFlagDisplayNameCleared() bool {
	_, ok := m.clearedFields[orderflag.FieldOrderFlagDisplayName]
	return ok
}

// ResetOrderFlagDisplayName resets all changes to the "order_flag_display_name" field.
func (m *OrderFlagMutation) ResetOrderFlagDisplayName() {
	m.order_flag_display_name = nil
	delete(m.clearedFields, orderflag.FieldOrderFlagDisplayName)
}

// SetOrderFlagIsActive sets the "order_flag_is_active" field.
func (m *OrderFlagMutation) SetOrderFlagIsActive(b bool) {
	m.order_flag_is_active = &b
}

// OrderFlagIsActive returns the value of the "order_flag_is_active" field in the mutation.
func (m *OrderFlagMutation) OrderFlagIsActive() (r bool, exists bool) {
	v := m.order_flag_is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagIsActive returns the old "order_flag_is_active" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagIsActive: %w", err)
	}
	return oldValue.OrderFlagIsActive, nil
}

// ResetOrderFlagIsActive resets all changes to the "order_flag_is_active" field.
func (m *OrderFlagMutation) ResetOrderFlagIsActive() {
	m.order_flag_is_active = nil
}

// SetOrderFlagCreatedAt sets the "order_flag_created_at" field.
func (m *OrderFlagMutation) SetOrderFlagCreatedAt(t time.Time) {
	m.order_flag_created_at = &t
}

// OrderFlagCreatedAt returns the value of the "order_flag_created_at" field in the mutation.
func (m *OrderFlagMutation) OrderFlagCreatedAt() (r time.Time, exists bool) {
	v := m.order_flag_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagCreatedAt returns the old "order_flag_created_at" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagCreatedAt: %w", err)
	}
	return oldValue.OrderFlagCreatedAt, nil
}

// ResetOrderFlagCreatedAt resets all changes to the "order_flag_created_at" field.
func (m *OrderFlagMutation) ResetOrderFlagCreatedAt() {
	m.order_flag_created_at = nil
}

// SetOrderFlagColor sets the "order_flag_color" field.
func (m *OrderFlagMutation) SetOrderFlagColor(s string) {
	m.order_flag_color = &s
}

// OrderFlagColor returns the value of the "order_flag_color" field in the mutation.
func (m *OrderFlagMutation) OrderFlagColor() (r string, exists bool) {
	v := m.order_flag_color
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagColor returns the old "order_flag_color" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagColor: %w", err)
	}
	return oldValue.OrderFlagColor, nil
}

// ClearOrderFlagColor clears the value of the "order_flag_color" field.
func (m *OrderFlagMutation) ClearOrderFlagColor() {
	m.order_flag_color = nil
	m.clearedFields[orderflag.FieldOrderFlagColor] = struct{}{}
}

// OrderFlagColorCleared returns if the "order_flag_color" field was cleared in this mutation.
func (m *OrderFlagMutation) OrderFlagColorCleared() bool {
	_, ok := m.clearedFields[orderflag.FieldOrderFlagColor]
	return ok
}

// ResetOrderFlagColor resets all changes to the "order_flag_color" field.
func (m *OrderFlagMutation) ResetOrderFlagColor() {
	m.order_flag_color = nil
	delete(m.clearedFields, orderflag.FieldOrderFlagColor)
}

// SetOrderFlagedBy sets the "order_flaged_by" field.
func (m *OrderFlagMutation) SetOrderFlagedBy(s string) {
	m.order_flaged_by = &s
}

// OrderFlagedBy returns the value of the "order_flaged_by" field in the mutation.
func (m *OrderFlagMutation) OrderFlagedBy() (r string, exists bool) {
	v := m.order_flaged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagedBy returns the old "order_flaged_by" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagedBy: %w", err)
	}
	return oldValue.OrderFlagedBy, nil
}

// ClearOrderFlagedBy clears the value of the "order_flaged_by" field.
func (m *OrderFlagMutation) ClearOrderFlagedBy() {
	m.order_flaged_by = nil
	m.clearedFields[orderflag.FieldOrderFlagedBy] = struct{}{}
}

// OrderFlagedByCleared returns if the "order_flaged_by" field was cleared in this mutation.
func (m *OrderFlagMutation) OrderFlagedByCleared() bool {
	_, ok := m.clearedFields[orderflag.FieldOrderFlagedBy]
	return ok
}

// ResetOrderFlagedBy resets all changes to the "order_flaged_by" field.
func (m *OrderFlagMutation) ResetOrderFlagedBy() {
	m.order_flaged_by = nil
	delete(m.clearedFields, orderflag.FieldOrderFlagedBy)
}

// SetOrderFlagAllowDuplicatesUnderSameCategory sets the "order_flag_allow_duplicates_under_same_category" field.
func (m *OrderFlagMutation) SetOrderFlagAllowDuplicatesUnderSameCategory(b bool) {
	m.order_flag_allow_duplicates_under_same_category = &b
}

// OrderFlagAllowDuplicatesUnderSameCategory returns the value of the "order_flag_allow_duplicates_under_same_category" field in the mutation.
func (m *OrderFlagMutation) OrderFlagAllowDuplicatesUnderSameCategory() (r bool, exists bool) {
	v := m.order_flag_allow_duplicates_under_same_category
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagAllowDuplicatesUnderSameCategory returns the old "order_flag_allow_duplicates_under_same_category" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagAllowDuplicatesUnderSameCategory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagAllowDuplicatesUnderSameCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagAllowDuplicatesUnderSameCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagAllowDuplicatesUnderSameCategory: %w", err)
	}
	return oldValue.OrderFlagAllowDuplicatesUnderSameCategory, nil
}

// ResetOrderFlagAllowDuplicatesUnderSameCategory resets all changes to the "order_flag_allow_duplicates_under_same_category" field.
func (m *OrderFlagMutation) ResetOrderFlagAllowDuplicatesUnderSameCategory() {
	m.order_flag_allow_duplicates_under_same_category = nil
}

// SetOrderFlagCategory sets the "order_flag_category" field.
func (m *OrderFlagMutation) SetOrderFlagCategory(s string) {
	m.order_flag_category = &s
}

// OrderFlagCategory returns the value of the "order_flag_category" field in the mutation.
func (m *OrderFlagMutation) OrderFlagCategory() (r string, exists bool) {
	v := m.order_flag_category
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagCategory returns the old "order_flag_category" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagCategory: %w", err)
	}
	return oldValue.OrderFlagCategory, nil
}

// ClearOrderFlagCategory clears the value of the "order_flag_category" field.
func (m *OrderFlagMutation) ClearOrderFlagCategory() {
	m.order_flag_category = nil
	m.clearedFields[orderflag.FieldOrderFlagCategory] = struct{}{}
}

// OrderFlagCategoryCleared returns if the "order_flag_category" field was cleared in this mutation.
func (m *OrderFlagMutation) OrderFlagCategoryCleared() bool {
	_, ok := m.clearedFields[orderflag.FieldOrderFlagCategory]
	return ok
}

// ResetOrderFlagCategory resets all changes to the "order_flag_category" field.
func (m *OrderFlagMutation) ResetOrderFlagCategory() {
	m.order_flag_category = nil
	delete(m.clearedFields, orderflag.FieldOrderFlagCategory)
}

// SetOrderFlagLevel sets the "order_flag_level" field.
func (m *OrderFlagMutation) SetOrderFlagLevel(i int) {
	m.order_flag_level = &i
	m.addorder_flag_level = nil
}

// OrderFlagLevel returns the value of the "order_flag_level" field in the mutation.
func (m *OrderFlagMutation) OrderFlagLevel() (r int, exists bool) {
	v := m.order_flag_level
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagLevel returns the old "order_flag_level" field's value of the OrderFlag entity.
// If the OrderFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFlagMutation) OldOrderFlagLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagLevel: %w", err)
	}
	return oldValue.OrderFlagLevel, nil
}

// AddOrderFlagLevel adds i to the "order_flag_level" field.
func (m *OrderFlagMutation) AddOrderFlagLevel(i int) {
	if m.addorder_flag_level != nil {
		*m.addorder_flag_level += i
	} else {
		m.addorder_flag_level = &i
	}
}

// AddedOrderFlagLevel returns the value that was added to the "order_flag_level" field in this mutation.
func (m *OrderFlagMutation) AddedOrderFlagLevel() (r int, exists bool) {
	v := m.addorder_flag_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderFlagLevel resets all changes to the "order_flag_level" field.
func (m *OrderFlagMutation) ResetOrderFlagLevel() {
	m.order_flag_level = nil
	m.addorder_flag_level = nil
}

// AddFlaggedOrderIDs adds the "flagged_orders" edge to the OrderInfo entity by ids.
func (m *OrderFlagMutation) AddFlaggedOrderIDs(ids ...int) {
	if m.flagged_orders == nil {
		m.flagged_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.flagged_orders[ids[i]] = struct{}{}
	}
}

// ClearFlaggedOrders clears the "flagged_orders" edge to the OrderInfo entity.
func (m *OrderFlagMutation) ClearFlaggedOrders() {
	m.clearedflagged_orders = true
}

// FlaggedOrdersCleared reports if the "flagged_orders" edge to the OrderInfo entity was cleared.
func (m *OrderFlagMutation) FlaggedOrdersCleared() bool {
	return m.clearedflagged_orders
}

// RemoveFlaggedOrderIDs removes the "flagged_orders" edge to the OrderInfo entity by IDs.
func (m *OrderFlagMutation) RemoveFlaggedOrderIDs(ids ...int) {
	if m.removedflagged_orders == nil {
		m.removedflagged_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flagged_orders, ids[i])
		m.removedflagged_orders[ids[i]] = struct{}{}
	}
}

// RemovedFlaggedOrders returns the removed IDs of the "flagged_orders" edge to the OrderInfo entity.
func (m *OrderFlagMutation) RemovedFlaggedOrdersIDs() (ids []int) {
	for id := range m.removedflagged_orders {
		ids = append(ids, id)
	}
	return
}

// FlaggedOrdersIDs returns the "flagged_orders" edge IDs in the mutation.
func (m *OrderFlagMutation) FlaggedOrdersIDs() (ids []int) {
	for id := range m.flagged_orders {
		ids = append(ids, id)
	}
	return
}

// ResetFlaggedOrders resets all changes to the "flagged_orders" edge.
func (m *OrderFlagMutation) ResetFlaggedOrders() {
	m.flagged_orders = nil
	m.clearedflagged_orders = false
	m.removedflagged_orders = nil
}

// Where appends a list predicates to the OrderFlagMutation builder.
func (m *OrderFlagMutation) Where(ps ...predicate.OrderFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderFlag).
func (m *OrderFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderFlagMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.order_flag_name != nil {
		fields = append(fields, orderflag.FieldOrderFlagName)
	}
	if m.order_flag_description != nil {
		fields = append(fields, orderflag.FieldOrderFlagDescription)
	}
	if m.order_flag_display_name != nil {
		fields = append(fields, orderflag.FieldOrderFlagDisplayName)
	}
	if m.order_flag_is_active != nil {
		fields = append(fields, orderflag.FieldOrderFlagIsActive)
	}
	if m.order_flag_created_at != nil {
		fields = append(fields, orderflag.FieldOrderFlagCreatedAt)
	}
	if m.order_flag_color != nil {
		fields = append(fields, orderflag.FieldOrderFlagColor)
	}
	if m.order_flaged_by != nil {
		fields = append(fields, orderflag.FieldOrderFlagedBy)
	}
	if m.order_flag_allow_duplicates_under_same_category != nil {
		fields = append(fields, orderflag.FieldOrderFlagAllowDuplicatesUnderSameCategory)
	}
	if m.order_flag_category != nil {
		fields = append(fields, orderflag.FieldOrderFlagCategory)
	}
	if m.order_flag_level != nil {
		fields = append(fields, orderflag.FieldOrderFlagLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderflag.FieldOrderFlagName:
		return m.OrderFlagName()
	case orderflag.FieldOrderFlagDescription:
		return m.OrderFlagDescription()
	case orderflag.FieldOrderFlagDisplayName:
		return m.OrderFlagDisplayName()
	case orderflag.FieldOrderFlagIsActive:
		return m.OrderFlagIsActive()
	case orderflag.FieldOrderFlagCreatedAt:
		return m.OrderFlagCreatedAt()
	case orderflag.FieldOrderFlagColor:
		return m.OrderFlagColor()
	case orderflag.FieldOrderFlagedBy:
		return m.OrderFlagedBy()
	case orderflag.FieldOrderFlagAllowDuplicatesUnderSameCategory:
		return m.OrderFlagAllowDuplicatesUnderSameCategory()
	case orderflag.FieldOrderFlagCategory:
		return m.OrderFlagCategory()
	case orderflag.FieldOrderFlagLevel:
		return m.OrderFlagLevel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderflag.FieldOrderFlagName:
		return m.OldOrderFlagName(ctx)
	case orderflag.FieldOrderFlagDescription:
		return m.OldOrderFlagDescription(ctx)
	case orderflag.FieldOrderFlagDisplayName:
		return m.OldOrderFlagDisplayName(ctx)
	case orderflag.FieldOrderFlagIsActive:
		return m.OldOrderFlagIsActive(ctx)
	case orderflag.FieldOrderFlagCreatedAt:
		return m.OldOrderFlagCreatedAt(ctx)
	case orderflag.FieldOrderFlagColor:
		return m.OldOrderFlagColor(ctx)
	case orderflag.FieldOrderFlagedBy:
		return m.OldOrderFlagedBy(ctx)
	case orderflag.FieldOrderFlagAllowDuplicatesUnderSameCategory:
		return m.OldOrderFlagAllowDuplicatesUnderSameCategory(ctx)
	case orderflag.FieldOrderFlagCategory:
		return m.OldOrderFlagCategory(ctx)
	case orderflag.FieldOrderFlagLevel:
		return m.OldOrderFlagLevel(ctx)
	}
	return nil, fmt.Errorf("unknown OrderFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderflag.FieldOrderFlagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagName(v)
		return nil
	case orderflag.FieldOrderFlagDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagDescription(v)
		return nil
	case orderflag.FieldOrderFlagDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagDisplayName(v)
		return nil
	case orderflag.FieldOrderFlagIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagIsActive(v)
		return nil
	case orderflag.FieldOrderFlagCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagCreatedAt(v)
		return nil
	case orderflag.FieldOrderFlagColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagColor(v)
		return nil
	case orderflag.FieldOrderFlagedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagedBy(v)
		return nil
	case orderflag.FieldOrderFlagAllowDuplicatesUnderSameCategory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagAllowDuplicatesUnderSameCategory(v)
		return nil
	case orderflag.FieldOrderFlagCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagCategory(v)
		return nil
	case orderflag.FieldOrderFlagLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagLevel(v)
		return nil
	}
	return fmt.Errorf("unknown OrderFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderFlagMutation) AddedFields() []string {
	var fields []string
	if m.addorder_flag_level != nil {
		fields = append(fields, orderflag.FieldOrderFlagLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderFlagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderflag.FieldOrderFlagLevel:
		return m.AddedOrderFlagLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderflag.FieldOrderFlagLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderFlagLevel(v)
		return nil
	}
	return fmt.Errorf("unknown OrderFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderflag.FieldOrderFlagDescription) {
		fields = append(fields, orderflag.FieldOrderFlagDescription)
	}
	if m.FieldCleared(orderflag.FieldOrderFlagDisplayName) {
		fields = append(fields, orderflag.FieldOrderFlagDisplayName)
	}
	if m.FieldCleared(orderflag.FieldOrderFlagColor) {
		fields = append(fields, orderflag.FieldOrderFlagColor)
	}
	if m.FieldCleared(orderflag.FieldOrderFlagedBy) {
		fields = append(fields, orderflag.FieldOrderFlagedBy)
	}
	if m.FieldCleared(orderflag.FieldOrderFlagCategory) {
		fields = append(fields, orderflag.FieldOrderFlagCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderFlagMutation) ClearField(name string) error {
	switch name {
	case orderflag.FieldOrderFlagDescription:
		m.ClearOrderFlagDescription()
		return nil
	case orderflag.FieldOrderFlagDisplayName:
		m.ClearOrderFlagDisplayName()
		return nil
	case orderflag.FieldOrderFlagColor:
		m.ClearOrderFlagColor()
		return nil
	case orderflag.FieldOrderFlagedBy:
		m.ClearOrderFlagedBy()
		return nil
	case orderflag.FieldOrderFlagCategory:
		m.ClearOrderFlagCategory()
		return nil
	}
	return fmt.Errorf("unknown OrderFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderFlagMutation) ResetField(name string) error {
	switch name {
	case orderflag.FieldOrderFlagName:
		m.ResetOrderFlagName()
		return nil
	case orderflag.FieldOrderFlagDescription:
		m.ResetOrderFlagDescription()
		return nil
	case orderflag.FieldOrderFlagDisplayName:
		m.ResetOrderFlagDisplayName()
		return nil
	case orderflag.FieldOrderFlagIsActive:
		m.ResetOrderFlagIsActive()
		return nil
	case orderflag.FieldOrderFlagCreatedAt:
		m.ResetOrderFlagCreatedAt()
		return nil
	case orderflag.FieldOrderFlagColor:
		m.ResetOrderFlagColor()
		return nil
	case orderflag.FieldOrderFlagedBy:
		m.ResetOrderFlagedBy()
		return nil
	case orderflag.FieldOrderFlagAllowDuplicatesUnderSameCategory:
		m.ResetOrderFlagAllowDuplicatesUnderSameCategory()
		return nil
	case orderflag.FieldOrderFlagCategory:
		m.ResetOrderFlagCategory()
		return nil
	case orderflag.FieldOrderFlagLevel:
		m.ResetOrderFlagLevel()
		return nil
	}
	return fmt.Errorf("unknown OrderFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.flagged_orders != nil {
		edges = append(edges, orderflag.EdgeFlaggedOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderFlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderflag.EdgeFlaggedOrders:
		ids := make([]ent.Value, 0, len(m.flagged_orders))
		for id := range m.flagged_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedflagged_orders != nil {
		edges = append(edges, orderflag.EdgeFlaggedOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderFlagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderflag.EdgeFlaggedOrders:
		ids := make([]ent.Value, 0, len(m.removedflagged_orders))
		for id := range m.removedflagged_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedflagged_orders {
		edges = append(edges, orderflag.EdgeFlaggedOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderFlagMutation) EdgeCleared(name string) bool {
	switch name {
	case orderflag.EdgeFlaggedOrders:
		return m.clearedflagged_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderFlagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderFlagMutation) ResetEdge(name string) error {
	switch name {
	case orderflag.EdgeFlaggedOrders:
		m.ResetFlaggedOrders()
		return nil
	}
	return fmt.Errorf("unknown OrderFlag edge %s", name)
}

// OrderInfoMutation represents an operation that mutates the OrderInfo nodes in the graph.
type OrderInfoMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	order_title                                 *string
	order_type                                  *string
	order_description                           *string
	order_confirmation_number                   *string
	order_create_time                           *time.Time
	order_service_time                          *time.Time
	order_process_time                          *time.Time
	order_redraw_time                           *time.Time
	order_cancel_time                           *time.Time
	isActive                                    *bool
	has_order_setting                           *bool
	order_canceled                              *bool
	order_flagged                               *bool
	order_status                                *string
	order_major_status                          *string
	order_kit_status                            *string
	order_report_status                         *string
	order_tnp_issue_status                      *string
	order_billing_issue_status                  *string
	order_missing_info_issue_status             *string
	order_incomplete_questionnaire_issue_status *string
	order_ny_waive_form_issue_status            *string
	order_lab_issue_status                      *string
	order_processing_time                       *time.Time
	order_minor_status                          *string
	patient_first_name                          *string
	patient_last_name                           *string
	order_source                                *string
	order_charge_method                         *string
	order_placing_type                          *string
	billing_order_id                            *string
	clearedFields                               map[string]struct{}
	tests                                       map[int]struct{}
	removedtests                                map[int]struct{}
	clearedtests                                bool
	order_flags                                 map[int]struct{}
	removedorder_flags                          map[int]struct{}
	clearedorder_flags                          bool
	sample                                      *int
	clearedsample                               bool
	contact                                     *int
	clearedcontact                              bool
	address                                     *int
	clearedaddress                              bool
	clinic                                      *int
	clearedclinic                               bool
	customer_info                               *int
	clearedcustomer_info                        bool
	done                                        bool
	oldValue                                    func(context.Context) (*OrderInfo, error)
	predicates                                  []predicate.OrderInfo
}

var _ ent.Mutation = (*OrderInfoMutation)(nil)

// orderinfoOption allows management of the mutation configuration using functional options.
type orderinfoOption func(*OrderInfoMutation)

// newOrderInfoMutation creates new mutation for the OrderInfo entity.
func newOrderInfoMutation(c config, op Op, opts ...orderinfoOption) *OrderInfoMutation {
	m := &OrderInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderInfoID sets the ID field of the mutation.
func withOrderInfoID(id int) orderinfoOption {
	return func(m *OrderInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderInfo
		)
		m.oldValue = func(ctx context.Context) (*OrderInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderInfo sets the old OrderInfo of the mutation.
func withOrderInfo(node *OrderInfo) orderinfoOption {
	return func(m *OrderInfoMutation) {
		m.oldValue = func(context.Context) (*OrderInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderInfo entities.
func (m *OrderInfoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderTitle sets the "order_title" field.
func (m *OrderInfoMutation) SetOrderTitle(s string) {
	m.order_title = &s
}

// OrderTitle returns the value of the "order_title" field in the mutation.
func (m *OrderInfoMutation) OrderTitle() (r string, exists bool) {
	v := m.order_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderTitle returns the old "order_title" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderTitle: %w", err)
	}
	return oldValue.OrderTitle, nil
}

// ResetOrderTitle resets all changes to the "order_title" field.
func (m *OrderInfoMutation) ResetOrderTitle() {
	m.order_title = nil
}

// SetOrderType sets the "order_type" field.
func (m *OrderInfoMutation) SetOrderType(s string) {
	m.order_type = &s
}

// OrderType returns the value of the "order_type" field in the mutation.
func (m *OrderInfoMutation) OrderType() (r string, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderType returns the old "order_type" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderType: %w", err)
	}
	return oldValue.OrderType, nil
}

// ResetOrderType resets all changes to the "order_type" field.
func (m *OrderInfoMutation) ResetOrderType() {
	m.order_type = nil
}

// SetOrderDescription sets the "order_description" field.
func (m *OrderInfoMutation) SetOrderDescription(s string) {
	m.order_description = &s
}

// OrderDescription returns the value of the "order_description" field in the mutation.
func (m *OrderInfoMutation) OrderDescription() (r string, exists bool) {
	v := m.order_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDescription returns the old "order_description" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDescription: %w", err)
	}
	return oldValue.OrderDescription, nil
}

// ResetOrderDescription resets all changes to the "order_description" field.
func (m *OrderInfoMutation) ResetOrderDescription() {
	m.order_description = nil
}

// SetOrderConfirmationNumber sets the "order_confirmation_number" field.
func (m *OrderInfoMutation) SetOrderConfirmationNumber(s string) {
	m.order_confirmation_number = &s
}

// OrderConfirmationNumber returns the value of the "order_confirmation_number" field in the mutation.
func (m *OrderInfoMutation) OrderConfirmationNumber() (r string, exists bool) {
	v := m.order_confirmation_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderConfirmationNumber returns the old "order_confirmation_number" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderConfirmationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderConfirmationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderConfirmationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderConfirmationNumber: %w", err)
	}
	return oldValue.OrderConfirmationNumber, nil
}

// ResetOrderConfirmationNumber resets all changes to the "order_confirmation_number" field.
func (m *OrderInfoMutation) ResetOrderConfirmationNumber() {
	m.order_confirmation_number = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *OrderInfoMutation) SetClinicID(i int) {
	m.clinic = &i
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *OrderInfoMutation) ClinicID() (r int, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldClinicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ClearClinicID clears the value of the "clinic_id" field.
func (m *OrderInfoMutation) ClearClinicID() {
	m.clinic = nil
	m.clearedFields[orderinfo.FieldClinicID] = struct{}{}
}

// ClinicIDCleared returns if the "clinic_id" field was cleared in this mutation.
func (m *OrderInfoMutation) ClinicIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldClinicID]
	return ok
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *OrderInfoMutation) ResetClinicID() {
	m.clinic = nil
	delete(m.clearedFields, orderinfo.FieldClinicID)
}

// SetCustomerID sets the "customer_id" field.
func (m *OrderInfoMutation) SetCustomerID(i int) {
	m.customer_info = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *OrderInfoMutation) CustomerID() (r int, exists bool) {
	v := m.customer_info
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *OrderInfoMutation) ClearCustomerID() {
	m.customer_info = nil
	m.clearedFields[orderinfo.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *OrderInfoMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *OrderInfoMutation) ResetCustomerID() {
	m.customer_info = nil
	delete(m.clearedFields, orderinfo.FieldCustomerID)
}

// SetOrderCreateTime sets the "order_create_time" field.
func (m *OrderInfoMutation) SetOrderCreateTime(t time.Time) {
	m.order_create_time = &t
}

// OrderCreateTime returns the value of the "order_create_time" field in the mutation.
func (m *OrderInfoMutation) OrderCreateTime() (r time.Time, exists bool) {
	v := m.order_create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCreateTime returns the old "order_create_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCreateTime: %w", err)
	}
	return oldValue.OrderCreateTime, nil
}

// ResetOrderCreateTime resets all changes to the "order_create_time" field.
func (m *OrderInfoMutation) ResetOrderCreateTime() {
	m.order_create_time = nil
}

// SetOrderServiceTime sets the "order_service_time" field.
func (m *OrderInfoMutation) SetOrderServiceTime(t time.Time) {
	m.order_service_time = &t
}

// OrderServiceTime returns the value of the "order_service_time" field in the mutation.
func (m *OrderInfoMutation) OrderServiceTime() (r time.Time, exists bool) {
	v := m.order_service_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderServiceTime returns the old "order_service_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderServiceTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderServiceTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderServiceTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderServiceTime: %w", err)
	}
	return oldValue.OrderServiceTime, nil
}

// ClearOrderServiceTime clears the value of the "order_service_time" field.
func (m *OrderInfoMutation) ClearOrderServiceTime() {
	m.order_service_time = nil
	m.clearedFields[orderinfo.FieldOrderServiceTime] = struct{}{}
}

// OrderServiceTimeCleared returns if the "order_service_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderServiceTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderServiceTime]
	return ok
}

// ResetOrderServiceTime resets all changes to the "order_service_time" field.
func (m *OrderInfoMutation) ResetOrderServiceTime() {
	m.order_service_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderServiceTime)
}

// SetOrderProcessTime sets the "order_process_time" field.
func (m *OrderInfoMutation) SetOrderProcessTime(t time.Time) {
	m.order_process_time = &t
}

// OrderProcessTime returns the value of the "order_process_time" field in the mutation.
func (m *OrderInfoMutation) OrderProcessTime() (r time.Time, exists bool) {
	v := m.order_process_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderProcessTime returns the old "order_process_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderProcessTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderProcessTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderProcessTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderProcessTime: %w", err)
	}
	return oldValue.OrderProcessTime, nil
}

// ClearOrderProcessTime clears the value of the "order_process_time" field.
func (m *OrderInfoMutation) ClearOrderProcessTime() {
	m.order_process_time = nil
	m.clearedFields[orderinfo.FieldOrderProcessTime] = struct{}{}
}

// OrderProcessTimeCleared returns if the "order_process_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderProcessTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderProcessTime]
	return ok
}

// ResetOrderProcessTime resets all changes to the "order_process_time" field.
func (m *OrderInfoMutation) ResetOrderProcessTime() {
	m.order_process_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderProcessTime)
}

// SetOrderRedrawTime sets the "order_redraw_time" field.
func (m *OrderInfoMutation) SetOrderRedrawTime(t time.Time) {
	m.order_redraw_time = &t
}

// OrderRedrawTime returns the value of the "order_redraw_time" field in the mutation.
func (m *OrderInfoMutation) OrderRedrawTime() (r time.Time, exists bool) {
	v := m.order_redraw_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderRedrawTime returns the old "order_redraw_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderRedrawTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderRedrawTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderRedrawTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderRedrawTime: %w", err)
	}
	return oldValue.OrderRedrawTime, nil
}

// ClearOrderRedrawTime clears the value of the "order_redraw_time" field.
func (m *OrderInfoMutation) ClearOrderRedrawTime() {
	m.order_redraw_time = nil
	m.clearedFields[orderinfo.FieldOrderRedrawTime] = struct{}{}
}

// OrderRedrawTimeCleared returns if the "order_redraw_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderRedrawTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderRedrawTime]
	return ok
}

// ResetOrderRedrawTime resets all changes to the "order_redraw_time" field.
func (m *OrderInfoMutation) ResetOrderRedrawTime() {
	m.order_redraw_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderRedrawTime)
}

// SetOrderCancelTime sets the "order_cancel_time" field.
func (m *OrderInfoMutation) SetOrderCancelTime(t time.Time) {
	m.order_cancel_time = &t
}

// OrderCancelTime returns the value of the "order_cancel_time" field in the mutation.
func (m *OrderInfoMutation) OrderCancelTime() (r time.Time, exists bool) {
	v := m.order_cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCancelTime returns the old "order_cancel_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderCancelTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCancelTime: %w", err)
	}
	return oldValue.OrderCancelTime, nil
}

// ClearOrderCancelTime clears the value of the "order_cancel_time" field.
func (m *OrderInfoMutation) ClearOrderCancelTime() {
	m.order_cancel_time = nil
	m.clearedFields[orderinfo.FieldOrderCancelTime] = struct{}{}
}

// OrderCancelTimeCleared returns if the "order_cancel_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderCancelTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderCancelTime]
	return ok
}

// ResetOrderCancelTime resets all changes to the "order_cancel_time" field.
func (m *OrderInfoMutation) ResetOrderCancelTime() {
	m.order_cancel_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderCancelTime)
}

// SetIsActive sets the "isActive" field.
func (m *OrderInfoMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *OrderInfoMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *OrderInfoMutation) ResetIsActive() {
	m.isActive = nil
}

// SetHasOrderSetting sets the "has_order_setting" field.
func (m *OrderInfoMutation) SetHasOrderSetting(b bool) {
	m.has_order_setting = &b
}

// HasOrderSetting returns the value of the "has_order_setting" field in the mutation.
func (m *OrderInfoMutation) HasOrderSetting() (r bool, exists bool) {
	v := m.has_order_setting
	if v == nil {
		return
	}
	return *v, true
}

// OldHasOrderSetting returns the old "has_order_setting" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldHasOrderSetting(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasOrderSetting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasOrderSetting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasOrderSetting: %w", err)
	}
	return oldValue.HasOrderSetting, nil
}

// ResetHasOrderSetting resets all changes to the "has_order_setting" field.
func (m *OrderInfoMutation) ResetHasOrderSetting() {
	m.has_order_setting = nil
}

// SetOrderCanceled sets the "order_canceled" field.
func (m *OrderInfoMutation) SetOrderCanceled(b bool) {
	m.order_canceled = &b
}

// OrderCanceled returns the value of the "order_canceled" field in the mutation.
func (m *OrderInfoMutation) OrderCanceled() (r bool, exists bool) {
	v := m.order_canceled
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCanceled returns the old "order_canceled" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderCanceled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCanceled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCanceled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCanceled: %w", err)
	}
	return oldValue.OrderCanceled, nil
}

// ResetOrderCanceled resets all changes to the "order_canceled" field.
func (m *OrderInfoMutation) ResetOrderCanceled() {
	m.order_canceled = nil
}

// SetOrderFlagged sets the "order_flagged" field.
func (m *OrderInfoMutation) SetOrderFlagged(b bool) {
	m.order_flagged = &b
}

// OrderFlagged returns the value of the "order_flagged" field in the mutation.
func (m *OrderInfoMutation) OrderFlagged() (r bool, exists bool) {
	v := m.order_flagged
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlagged returns the old "order_flagged" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderFlagged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlagged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlagged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlagged: %w", err)
	}
	return oldValue.OrderFlagged, nil
}

// ResetOrderFlagged resets all changes to the "order_flagged" field.
func (m *OrderInfoMutation) ResetOrderFlagged() {
	m.order_flagged = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *OrderInfoMutation) SetOrderStatus(s string) {
	m.order_status = &s
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *OrderInfoMutation) OrderStatus() (r string, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ClearOrderStatus clears the value of the "order_status" field.
func (m *OrderInfoMutation) ClearOrderStatus() {
	m.order_status = nil
	m.clearedFields[orderinfo.FieldOrderStatus] = struct{}{}
}

// OrderStatusCleared returns if the "order_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderStatus]
	return ok
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *OrderInfoMutation) ResetOrderStatus() {
	m.order_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderStatus)
}

// SetOrderMajorStatus sets the "order_major_status" field.
func (m *OrderInfoMutation) SetOrderMajorStatus(s string) {
	m.order_major_status = &s
}

// OrderMajorStatus returns the value of the "order_major_status" field in the mutation.
func (m *OrderInfoMutation) OrderMajorStatus() (r string, exists bool) {
	v := m.order_major_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMajorStatus returns the old "order_major_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderMajorStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMajorStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMajorStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMajorStatus: %w", err)
	}
	return oldValue.OrderMajorStatus, nil
}

// ClearOrderMajorStatus clears the value of the "order_major_status" field.
func (m *OrderInfoMutation) ClearOrderMajorStatus() {
	m.order_major_status = nil
	m.clearedFields[orderinfo.FieldOrderMajorStatus] = struct{}{}
}

// OrderMajorStatusCleared returns if the "order_major_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderMajorStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderMajorStatus]
	return ok
}

// ResetOrderMajorStatus resets all changes to the "order_major_status" field.
func (m *OrderInfoMutation) ResetOrderMajorStatus() {
	m.order_major_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderMajorStatus)
}

// SetOrderKitStatus sets the "order_kit_status" field.
func (m *OrderInfoMutation) SetOrderKitStatus(s string) {
	m.order_kit_status = &s
}

// OrderKitStatus returns the value of the "order_kit_status" field in the mutation.
func (m *OrderInfoMutation) OrderKitStatus() (r string, exists bool) {
	v := m.order_kit_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderKitStatus returns the old "order_kit_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderKitStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderKitStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderKitStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderKitStatus: %w", err)
	}
	return oldValue.OrderKitStatus, nil
}

// ClearOrderKitStatus clears the value of the "order_kit_status" field.
func (m *OrderInfoMutation) ClearOrderKitStatus() {
	m.order_kit_status = nil
	m.clearedFields[orderinfo.FieldOrderKitStatus] = struct{}{}
}

// OrderKitStatusCleared returns if the "order_kit_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderKitStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderKitStatus]
	return ok
}

// ResetOrderKitStatus resets all changes to the "order_kit_status" field.
func (m *OrderInfoMutation) ResetOrderKitStatus() {
	m.order_kit_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderKitStatus)
}

// SetOrderReportStatus sets the "order_report_status" field.
func (m *OrderInfoMutation) SetOrderReportStatus(s string) {
	m.order_report_status = &s
}

// OrderReportStatus returns the value of the "order_report_status" field in the mutation.
func (m *OrderInfoMutation) OrderReportStatus() (r string, exists bool) {
	v := m.order_report_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderReportStatus returns the old "order_report_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderReportStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderReportStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderReportStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderReportStatus: %w", err)
	}
	return oldValue.OrderReportStatus, nil
}

// ClearOrderReportStatus clears the value of the "order_report_status" field.
func (m *OrderInfoMutation) ClearOrderReportStatus() {
	m.order_report_status = nil
	m.clearedFields[orderinfo.FieldOrderReportStatus] = struct{}{}
}

// OrderReportStatusCleared returns if the "order_report_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderReportStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderReportStatus]
	return ok
}

// ResetOrderReportStatus resets all changes to the "order_report_status" field.
func (m *OrderInfoMutation) ResetOrderReportStatus() {
	m.order_report_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderReportStatus)
}

// SetOrderTnpIssueStatus sets the "order_tnp_issue_status" field.
func (m *OrderInfoMutation) SetOrderTnpIssueStatus(s string) {
	m.order_tnp_issue_status = &s
}

// OrderTnpIssueStatus returns the value of the "order_tnp_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderTnpIssueStatus() (r string, exists bool) {
	v := m.order_tnp_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderTnpIssueStatus returns the old "order_tnp_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderTnpIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderTnpIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderTnpIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderTnpIssueStatus: %w", err)
	}
	return oldValue.OrderTnpIssueStatus, nil
}

// ClearOrderTnpIssueStatus clears the value of the "order_tnp_issue_status" field.
func (m *OrderInfoMutation) ClearOrderTnpIssueStatus() {
	m.order_tnp_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderTnpIssueStatus] = struct{}{}
}

// OrderTnpIssueStatusCleared returns if the "order_tnp_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderTnpIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderTnpIssueStatus]
	return ok
}

// ResetOrderTnpIssueStatus resets all changes to the "order_tnp_issue_status" field.
func (m *OrderInfoMutation) ResetOrderTnpIssueStatus() {
	m.order_tnp_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderTnpIssueStatus)
}

// SetOrderBillingIssueStatus sets the "order_billing_issue_status" field.
func (m *OrderInfoMutation) SetOrderBillingIssueStatus(s string) {
	m.order_billing_issue_status = &s
}

// OrderBillingIssueStatus returns the value of the "order_billing_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderBillingIssueStatus() (r string, exists bool) {
	v := m.order_billing_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderBillingIssueStatus returns the old "order_billing_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderBillingIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderBillingIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderBillingIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderBillingIssueStatus: %w", err)
	}
	return oldValue.OrderBillingIssueStatus, nil
}

// ClearOrderBillingIssueStatus clears the value of the "order_billing_issue_status" field.
func (m *OrderInfoMutation) ClearOrderBillingIssueStatus() {
	m.order_billing_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderBillingIssueStatus] = struct{}{}
}

// OrderBillingIssueStatusCleared returns if the "order_billing_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderBillingIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderBillingIssueStatus]
	return ok
}

// ResetOrderBillingIssueStatus resets all changes to the "order_billing_issue_status" field.
func (m *OrderInfoMutation) ResetOrderBillingIssueStatus() {
	m.order_billing_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderBillingIssueStatus)
}

// SetOrderMissingInfoIssueStatus sets the "order_missing_info_issue_status" field.
func (m *OrderInfoMutation) SetOrderMissingInfoIssueStatus(s string) {
	m.order_missing_info_issue_status = &s
}

// OrderMissingInfoIssueStatus returns the value of the "order_missing_info_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderMissingInfoIssueStatus() (r string, exists bool) {
	v := m.order_missing_info_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMissingInfoIssueStatus returns the old "order_missing_info_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderMissingInfoIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMissingInfoIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMissingInfoIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMissingInfoIssueStatus: %w", err)
	}
	return oldValue.OrderMissingInfoIssueStatus, nil
}

// ClearOrderMissingInfoIssueStatus clears the value of the "order_missing_info_issue_status" field.
func (m *OrderInfoMutation) ClearOrderMissingInfoIssueStatus() {
	m.order_missing_info_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderMissingInfoIssueStatus] = struct{}{}
}

// OrderMissingInfoIssueStatusCleared returns if the "order_missing_info_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderMissingInfoIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderMissingInfoIssueStatus]
	return ok
}

// ResetOrderMissingInfoIssueStatus resets all changes to the "order_missing_info_issue_status" field.
func (m *OrderInfoMutation) ResetOrderMissingInfoIssueStatus() {
	m.order_missing_info_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderMissingInfoIssueStatus)
}

// SetOrderIncompleteQuestionnaireIssueStatus sets the "order_incomplete_questionnaire_issue_status" field.
func (m *OrderInfoMutation) SetOrderIncompleteQuestionnaireIssueStatus(s string) {
	m.order_incomplete_questionnaire_issue_status = &s
}

// OrderIncompleteQuestionnaireIssueStatus returns the value of the "order_incomplete_questionnaire_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderIncompleteQuestionnaireIssueStatus() (r string, exists bool) {
	v := m.order_incomplete_questionnaire_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderIncompleteQuestionnaireIssueStatus returns the old "order_incomplete_questionnaire_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderIncompleteQuestionnaireIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderIncompleteQuestionnaireIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderIncompleteQuestionnaireIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderIncompleteQuestionnaireIssueStatus: %w", err)
	}
	return oldValue.OrderIncompleteQuestionnaireIssueStatus, nil
}

// ClearOrderIncompleteQuestionnaireIssueStatus clears the value of the "order_incomplete_questionnaire_issue_status" field.
func (m *OrderInfoMutation) ClearOrderIncompleteQuestionnaireIssueStatus() {
	m.order_incomplete_questionnaire_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus] = struct{}{}
}

// OrderIncompleteQuestionnaireIssueStatusCleared returns if the "order_incomplete_questionnaire_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderIncompleteQuestionnaireIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus]
	return ok
}

// ResetOrderIncompleteQuestionnaireIssueStatus resets all changes to the "order_incomplete_questionnaire_issue_status" field.
func (m *OrderInfoMutation) ResetOrderIncompleteQuestionnaireIssueStatus() {
	m.order_incomplete_questionnaire_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus)
}

// SetOrderNyWaiveFormIssueStatus sets the "order_ny_waive_form_issue_status" field.
func (m *OrderInfoMutation) SetOrderNyWaiveFormIssueStatus(s string) {
	m.order_ny_waive_form_issue_status = &s
}

// OrderNyWaiveFormIssueStatus returns the value of the "order_ny_waive_form_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderNyWaiveFormIssueStatus() (r string, exists bool) {
	v := m.order_ny_waive_form_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNyWaiveFormIssueStatus returns the old "order_ny_waive_form_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderNyWaiveFormIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNyWaiveFormIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNyWaiveFormIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNyWaiveFormIssueStatus: %w", err)
	}
	return oldValue.OrderNyWaiveFormIssueStatus, nil
}

// ClearOrderNyWaiveFormIssueStatus clears the value of the "order_ny_waive_form_issue_status" field.
func (m *OrderInfoMutation) ClearOrderNyWaiveFormIssueStatus() {
	m.order_ny_waive_form_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderNyWaiveFormIssueStatus] = struct{}{}
}

// OrderNyWaiveFormIssueStatusCleared returns if the "order_ny_waive_form_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderNyWaiveFormIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderNyWaiveFormIssueStatus]
	return ok
}

// ResetOrderNyWaiveFormIssueStatus resets all changes to the "order_ny_waive_form_issue_status" field.
func (m *OrderInfoMutation) ResetOrderNyWaiveFormIssueStatus() {
	m.order_ny_waive_form_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderNyWaiveFormIssueStatus)
}

// SetOrderLabIssueStatus sets the "order_lab_issue_status" field.
func (m *OrderInfoMutation) SetOrderLabIssueStatus(s string) {
	m.order_lab_issue_status = &s
}

// OrderLabIssueStatus returns the value of the "order_lab_issue_status" field in the mutation.
func (m *OrderInfoMutation) OrderLabIssueStatus() (r string, exists bool) {
	v := m.order_lab_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderLabIssueStatus returns the old "order_lab_issue_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderLabIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderLabIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderLabIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderLabIssueStatus: %w", err)
	}
	return oldValue.OrderLabIssueStatus, nil
}

// ClearOrderLabIssueStatus clears the value of the "order_lab_issue_status" field.
func (m *OrderInfoMutation) ClearOrderLabIssueStatus() {
	m.order_lab_issue_status = nil
	m.clearedFields[orderinfo.FieldOrderLabIssueStatus] = struct{}{}
}

// OrderLabIssueStatusCleared returns if the "order_lab_issue_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderLabIssueStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderLabIssueStatus]
	return ok
}

// ResetOrderLabIssueStatus resets all changes to the "order_lab_issue_status" field.
func (m *OrderInfoMutation) ResetOrderLabIssueStatus() {
	m.order_lab_issue_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderLabIssueStatus)
}

// SetOrderProcessingTime sets the "order_processing_time" field.
func (m *OrderInfoMutation) SetOrderProcessingTime(t time.Time) {
	m.order_processing_time = &t
}

// OrderProcessingTime returns the value of the "order_processing_time" field in the mutation.
func (m *OrderInfoMutation) OrderProcessingTime() (r time.Time, exists bool) {
	v := m.order_processing_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderProcessingTime returns the old "order_processing_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderProcessingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderProcessingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderProcessingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderProcessingTime: %w", err)
	}
	return oldValue.OrderProcessingTime, nil
}

// ClearOrderProcessingTime clears the value of the "order_processing_time" field.
func (m *OrderInfoMutation) ClearOrderProcessingTime() {
	m.order_processing_time = nil
	m.clearedFields[orderinfo.FieldOrderProcessingTime] = struct{}{}
}

// OrderProcessingTimeCleared returns if the "order_processing_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderProcessingTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderProcessingTime]
	return ok
}

// ResetOrderProcessingTime resets all changes to the "order_processing_time" field.
func (m *OrderInfoMutation) ResetOrderProcessingTime() {
	m.order_processing_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderProcessingTime)
}

// SetOrderMinorStatus sets the "order_minor_status" field.
func (m *OrderInfoMutation) SetOrderMinorStatus(s string) {
	m.order_minor_status = &s
}

// OrderMinorStatus returns the value of the "order_minor_status" field in the mutation.
func (m *OrderInfoMutation) OrderMinorStatus() (r string, exists bool) {
	v := m.order_minor_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMinorStatus returns the old "order_minor_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderMinorStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMinorStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMinorStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMinorStatus: %w", err)
	}
	return oldValue.OrderMinorStatus, nil
}

// ClearOrderMinorStatus clears the value of the "order_minor_status" field.
func (m *OrderInfoMutation) ClearOrderMinorStatus() {
	m.order_minor_status = nil
	m.clearedFields[orderinfo.FieldOrderMinorStatus] = struct{}{}
}

// OrderMinorStatusCleared returns if the "order_minor_status" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderMinorStatusCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderMinorStatus]
	return ok
}

// ResetOrderMinorStatus resets all changes to the "order_minor_status" field.
func (m *OrderInfoMutation) ResetOrderMinorStatus() {
	m.order_minor_status = nil
	delete(m.clearedFields, orderinfo.FieldOrderMinorStatus)
}

// SetPatientFirstName sets the "patient_first_name" field.
func (m *OrderInfoMutation) SetPatientFirstName(s string) {
	m.patient_first_name = &s
}

// PatientFirstName returns the value of the "patient_first_name" field in the mutation.
func (m *OrderInfoMutation) PatientFirstName() (r string, exists bool) {
	v := m.patient_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFirstName returns the old "patient_first_name" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPatientFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFirstName: %w", err)
	}
	return oldValue.PatientFirstName, nil
}

// ClearPatientFirstName clears the value of the "patient_first_name" field.
func (m *OrderInfoMutation) ClearPatientFirstName() {
	m.patient_first_name = nil
	m.clearedFields[orderinfo.FieldPatientFirstName] = struct{}{}
}

// PatientFirstNameCleared returns if the "patient_first_name" field was cleared in this mutation.
func (m *OrderInfoMutation) PatientFirstNameCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldPatientFirstName]
	return ok
}

// ResetPatientFirstName resets all changes to the "patient_first_name" field.
func (m *OrderInfoMutation) ResetPatientFirstName() {
	m.patient_first_name = nil
	delete(m.clearedFields, orderinfo.FieldPatientFirstName)
}

// SetPatientLastName sets the "patient_last_name" field.
func (m *OrderInfoMutation) SetPatientLastName(s string) {
	m.patient_last_name = &s
}

// PatientLastName returns the value of the "patient_last_name" field in the mutation.
func (m *OrderInfoMutation) PatientLastName() (r string, exists bool) {
	v := m.patient_last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientLastName returns the old "patient_last_name" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPatientLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientLastName: %w", err)
	}
	return oldValue.PatientLastName, nil
}

// ClearPatientLastName clears the value of the "patient_last_name" field.
func (m *OrderInfoMutation) ClearPatientLastName() {
	m.patient_last_name = nil
	m.clearedFields[orderinfo.FieldPatientLastName] = struct{}{}
}

// PatientLastNameCleared returns if the "patient_last_name" field was cleared in this mutation.
func (m *OrderInfoMutation) PatientLastNameCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldPatientLastName]
	return ok
}

// ResetPatientLastName resets all changes to the "patient_last_name" field.
func (m *OrderInfoMutation) ResetPatientLastName() {
	m.patient_last_name = nil
	delete(m.clearedFields, orderinfo.FieldPatientLastName)
}

// SetOrderSource sets the "order_source" field.
func (m *OrderInfoMutation) SetOrderSource(s string) {
	m.order_source = &s
}

// OrderSource returns the value of the "order_source" field in the mutation.
func (m *OrderInfoMutation) OrderSource() (r string, exists bool) {
	v := m.order_source
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSource returns the old "order_source" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSource: %w", err)
	}
	return oldValue.OrderSource, nil
}

// ClearOrderSource clears the value of the "order_source" field.
func (m *OrderInfoMutation) ClearOrderSource() {
	m.order_source = nil
	m.clearedFields[orderinfo.FieldOrderSource] = struct{}{}
}

// OrderSourceCleared returns if the "order_source" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderSourceCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderSource]
	return ok
}

// ResetOrderSource resets all changes to the "order_source" field.
func (m *OrderInfoMutation) ResetOrderSource() {
	m.order_source = nil
	delete(m.clearedFields, orderinfo.FieldOrderSource)
}

// SetOrderChargeMethod sets the "order_charge_method" field.
func (m *OrderInfoMutation) SetOrderChargeMethod(s string) {
	m.order_charge_method = &s
}

// OrderChargeMethod returns the value of the "order_charge_method" field in the mutation.
func (m *OrderInfoMutation) OrderChargeMethod() (r string, exists bool) {
	v := m.order_charge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderChargeMethod returns the old "order_charge_method" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderChargeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderChargeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderChargeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderChargeMethod: %w", err)
	}
	return oldValue.OrderChargeMethod, nil
}

// ClearOrderChargeMethod clears the value of the "order_charge_method" field.
func (m *OrderInfoMutation) ClearOrderChargeMethod() {
	m.order_charge_method = nil
	m.clearedFields[orderinfo.FieldOrderChargeMethod] = struct{}{}
}

// OrderChargeMethodCleared returns if the "order_charge_method" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderChargeMethodCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderChargeMethod]
	return ok
}

// ResetOrderChargeMethod resets all changes to the "order_charge_method" field.
func (m *OrderInfoMutation) ResetOrderChargeMethod() {
	m.order_charge_method = nil
	delete(m.clearedFields, orderinfo.FieldOrderChargeMethod)
}

// SetOrderPlacingType sets the "order_placing_type" field.
func (m *OrderInfoMutation) SetOrderPlacingType(s string) {
	m.order_placing_type = &s
}

// OrderPlacingType returns the value of the "order_placing_type" field in the mutation.
func (m *OrderInfoMutation) OrderPlacingType() (r string, exists bool) {
	v := m.order_placing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPlacingType returns the old "order_placing_type" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderPlacingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderPlacingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderPlacingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPlacingType: %w", err)
	}
	return oldValue.OrderPlacingType, nil
}

// ClearOrderPlacingType clears the value of the "order_placing_type" field.
func (m *OrderInfoMutation) ClearOrderPlacingType() {
	m.order_placing_type = nil
	m.clearedFields[orderinfo.FieldOrderPlacingType] = struct{}{}
}

// OrderPlacingTypeCleared returns if the "order_placing_type" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderPlacingTypeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderPlacingType]
	return ok
}

// ResetOrderPlacingType resets all changes to the "order_placing_type" field.
func (m *OrderInfoMutation) ResetOrderPlacingType() {
	m.order_placing_type = nil
	delete(m.clearedFields, orderinfo.FieldOrderPlacingType)
}

// SetBillingOrderID sets the "billing_order_id" field.
func (m *OrderInfoMutation) SetBillingOrderID(s string) {
	m.billing_order_id = &s
}

// BillingOrderID returns the value of the "billing_order_id" field in the mutation.
func (m *OrderInfoMutation) BillingOrderID() (r string, exists bool) {
	v := m.billing_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingOrderID returns the old "billing_order_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldBillingOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingOrderID: %w", err)
	}
	return oldValue.BillingOrderID, nil
}

// ClearBillingOrderID clears the value of the "billing_order_id" field.
func (m *OrderInfoMutation) ClearBillingOrderID() {
	m.billing_order_id = nil
	m.clearedFields[orderinfo.FieldBillingOrderID] = struct{}{}
}

// BillingOrderIDCleared returns if the "billing_order_id" field was cleared in this mutation.
func (m *OrderInfoMutation) BillingOrderIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldBillingOrderID]
	return ok
}

// ResetBillingOrderID resets all changes to the "billing_order_id" field.
func (m *OrderInfoMutation) ResetBillingOrderID() {
	m.billing_order_id = nil
	delete(m.clearedFields, orderinfo.FieldBillingOrderID)
}

// SetContactID sets the "contact_id" field.
func (m *OrderInfoMutation) SetContactID(i int) {
	m.contact = &i
}

// ContactID returns the value of the "contact_id" field in the mutation.
func (m *OrderInfoMutation) ContactID() (r int, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContactID returns the old "contact_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldContactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactID: %w", err)
	}
	return oldValue.ContactID, nil
}

// ClearContactID clears the value of the "contact_id" field.
func (m *OrderInfoMutation) ClearContactID() {
	m.contact = nil
	m.clearedFields[orderinfo.FieldContactID] = struct{}{}
}

// ContactIDCleared returns if the "contact_id" field was cleared in this mutation.
func (m *OrderInfoMutation) ContactIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldContactID]
	return ok
}

// ResetContactID resets all changes to the "contact_id" field.
func (m *OrderInfoMutation) ResetContactID() {
	m.contact = nil
	delete(m.clearedFields, orderinfo.FieldContactID)
}

// SetAddressID sets the "address_id" field.
func (m *OrderInfoMutation) SetAddressID(i int) {
	m.address = &i
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *OrderInfoMutation) AddressID() (r int, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldAddressID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ClearAddressID clears the value of the "address_id" field.
func (m *OrderInfoMutation) ClearAddressID() {
	m.address = nil
	m.clearedFields[orderinfo.FieldAddressID] = struct{}{}
}

// AddressIDCleared returns if the "address_id" field was cleared in this mutation.
func (m *OrderInfoMutation) AddressIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldAddressID]
	return ok
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *OrderInfoMutation) ResetAddressID() {
	m.address = nil
	delete(m.clearedFields, orderinfo.FieldAddressID)
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *OrderInfoMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *OrderInfoMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *OrderInfoMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *OrderInfoMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *OrderInfoMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *OrderInfoMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *OrderInfoMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// AddOrderFlagIDs adds the "order_flags" edge to the OrderFlag entity by ids.
func (m *OrderInfoMutation) AddOrderFlagIDs(ids ...int) {
	if m.order_flags == nil {
		m.order_flags = make(map[int]struct{})
	}
	for i := range ids {
		m.order_flags[ids[i]] = struct{}{}
	}
}

// ClearOrderFlags clears the "order_flags" edge to the OrderFlag entity.
func (m *OrderInfoMutation) ClearOrderFlags() {
	m.clearedorder_flags = true
}

// OrderFlagsCleared reports if the "order_flags" edge to the OrderFlag entity was cleared.
func (m *OrderInfoMutation) OrderFlagsCleared() bool {
	return m.clearedorder_flags
}

// RemoveOrderFlagIDs removes the "order_flags" edge to the OrderFlag entity by IDs.
func (m *OrderInfoMutation) RemoveOrderFlagIDs(ids ...int) {
	if m.removedorder_flags == nil {
		m.removedorder_flags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_flags, ids[i])
		m.removedorder_flags[ids[i]] = struct{}{}
	}
}

// RemovedOrderFlags returns the removed IDs of the "order_flags" edge to the OrderFlag entity.
func (m *OrderInfoMutation) RemovedOrderFlagsIDs() (ids []int) {
	for id := range m.removedorder_flags {
		ids = append(ids, id)
	}
	return
}

// OrderFlagsIDs returns the "order_flags" edge IDs in the mutation.
func (m *OrderInfoMutation) OrderFlagsIDs() (ids []int) {
	for id := range m.order_flags {
		ids = append(ids, id)
	}
	return
}

// ResetOrderFlags resets all changes to the "order_flags" edge.
func (m *OrderInfoMutation) ResetOrderFlags() {
	m.order_flags = nil
	m.clearedorder_flags = false
	m.removedorder_flags = nil
}

// SetSampleID sets the "sample" edge to the Sample entity by id.
func (m *OrderInfoMutation) SetSampleID(id int) {
	m.sample = &id
}

// ClearSample clears the "sample" edge to the Sample entity.
func (m *OrderInfoMutation) ClearSample() {
	m.clearedsample = true
}

// SampleCleared reports if the "sample" edge to the Sample entity was cleared.
func (m *OrderInfoMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleID returns the "sample" edge ID in the mutation.
func (m *OrderInfoMutation) SampleID() (id int, exists bool) {
	if m.sample != nil {
		return *m.sample, true
	}
	return
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) SampleIDs() (ids []int) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *OrderInfoMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// ClearContact clears the "contact" edge to the Contact entity.
func (m *OrderInfoMutation) ClearContact() {
	m.clearedcontact = true
	m.clearedFields[orderinfo.FieldContactID] = struct{}{}
}

// ContactCleared reports if the "contact" edge to the Contact entity was cleared.
func (m *OrderInfoMutation) ContactCleared() bool {
	return m.ContactIDCleared() || m.clearedcontact
}

// ContactIDs returns the "contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContactID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) ContactIDs() (ids []int) {
	if id := m.contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *OrderInfoMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *OrderInfoMutation) ClearAddress() {
	m.clearedaddress = true
	m.clearedFields[orderinfo.FieldAddressID] = struct{}{}
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *OrderInfoMutation) AddressCleared() bool {
	return m.AddressIDCleared() || m.clearedaddress
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) AddressIDs() (ids []int) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *OrderInfoMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *OrderInfoMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[orderinfo.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *OrderInfoMutation) ClinicCleared() bool {
	return m.ClinicIDCleared() || m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) ClinicIDs() (ids []int) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *OrderInfoMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// SetCustomerInfoID sets the "customer_info" edge to the Customer entity by id.
func (m *OrderInfoMutation) SetCustomerInfoID(id int) {
	m.customer_info = &id
}

// ClearCustomerInfo clears the "customer_info" edge to the Customer entity.
func (m *OrderInfoMutation) ClearCustomerInfo() {
	m.clearedcustomer_info = true
	m.clearedFields[orderinfo.FieldCustomerID] = struct{}{}
}

// CustomerInfoCleared reports if the "customer_info" edge to the Customer entity was cleared.
func (m *OrderInfoMutation) CustomerInfoCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer_info
}

// CustomerInfoID returns the "customer_info" edge ID in the mutation.
func (m *OrderInfoMutation) CustomerInfoID() (id int, exists bool) {
	if m.customer_info != nil {
		return *m.customer_info, true
	}
	return
}

// CustomerInfoIDs returns the "customer_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerInfoID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) CustomerInfoIDs() (ids []int) {
	if id := m.customer_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomerInfo resets all changes to the "customer_info" edge.
func (m *OrderInfoMutation) ResetCustomerInfo() {
	m.customer_info = nil
	m.clearedcustomer_info = false
}

// Where appends a list predicates to the OrderInfoMutation builder.
func (m *OrderInfoMutation) Where(ps ...predicate.OrderInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderInfo).
func (m *OrderInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderInfoMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m.order_title != nil {
		fields = append(fields, orderinfo.FieldOrderTitle)
	}
	if m.order_type != nil {
		fields = append(fields, orderinfo.FieldOrderType)
	}
	if m.order_description != nil {
		fields = append(fields, orderinfo.FieldOrderDescription)
	}
	if m.order_confirmation_number != nil {
		fields = append(fields, orderinfo.FieldOrderConfirmationNumber)
	}
	if m.clinic != nil {
		fields = append(fields, orderinfo.FieldClinicID)
	}
	if m.customer_info != nil {
		fields = append(fields, orderinfo.FieldCustomerID)
	}
	if m.order_create_time != nil {
		fields = append(fields, orderinfo.FieldOrderCreateTime)
	}
	if m.order_service_time != nil {
		fields = append(fields, orderinfo.FieldOrderServiceTime)
	}
	if m.order_process_time != nil {
		fields = append(fields, orderinfo.FieldOrderProcessTime)
	}
	if m.order_redraw_time != nil {
		fields = append(fields, orderinfo.FieldOrderRedrawTime)
	}
	if m.order_cancel_time != nil {
		fields = append(fields, orderinfo.FieldOrderCancelTime)
	}
	if m.isActive != nil {
		fields = append(fields, orderinfo.FieldIsActive)
	}
	if m.has_order_setting != nil {
		fields = append(fields, orderinfo.FieldHasOrderSetting)
	}
	if m.order_canceled != nil {
		fields = append(fields, orderinfo.FieldOrderCanceled)
	}
	if m.order_flagged != nil {
		fields = append(fields, orderinfo.FieldOrderFlagged)
	}
	if m.order_status != nil {
		fields = append(fields, orderinfo.FieldOrderStatus)
	}
	if m.order_major_status != nil {
		fields = append(fields, orderinfo.FieldOrderMajorStatus)
	}
	if m.order_kit_status != nil {
		fields = append(fields, orderinfo.FieldOrderKitStatus)
	}
	if m.order_report_status != nil {
		fields = append(fields, orderinfo.FieldOrderReportStatus)
	}
	if m.order_tnp_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderTnpIssueStatus)
	}
	if m.order_billing_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderBillingIssueStatus)
	}
	if m.order_missing_info_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderMissingInfoIssueStatus)
	}
	if m.order_incomplete_questionnaire_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus)
	}
	if m.order_ny_waive_form_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderNyWaiveFormIssueStatus)
	}
	if m.order_lab_issue_status != nil {
		fields = append(fields, orderinfo.FieldOrderLabIssueStatus)
	}
	if m.order_processing_time != nil {
		fields = append(fields, orderinfo.FieldOrderProcessingTime)
	}
	if m.order_minor_status != nil {
		fields = append(fields, orderinfo.FieldOrderMinorStatus)
	}
	if m.patient_first_name != nil {
		fields = append(fields, orderinfo.FieldPatientFirstName)
	}
	if m.patient_last_name != nil {
		fields = append(fields, orderinfo.FieldPatientLastName)
	}
	if m.order_source != nil {
		fields = append(fields, orderinfo.FieldOrderSource)
	}
	if m.order_charge_method != nil {
		fields = append(fields, orderinfo.FieldOrderChargeMethod)
	}
	if m.order_placing_type != nil {
		fields = append(fields, orderinfo.FieldOrderPlacingType)
	}
	if m.billing_order_id != nil {
		fields = append(fields, orderinfo.FieldBillingOrderID)
	}
	if m.contact != nil {
		fields = append(fields, orderinfo.FieldContactID)
	}
	if m.address != nil {
		fields = append(fields, orderinfo.FieldAddressID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderinfo.FieldOrderTitle:
		return m.OrderTitle()
	case orderinfo.FieldOrderType:
		return m.OrderType()
	case orderinfo.FieldOrderDescription:
		return m.OrderDescription()
	case orderinfo.FieldOrderConfirmationNumber:
		return m.OrderConfirmationNumber()
	case orderinfo.FieldClinicID:
		return m.ClinicID()
	case orderinfo.FieldCustomerID:
		return m.CustomerID()
	case orderinfo.FieldOrderCreateTime:
		return m.OrderCreateTime()
	case orderinfo.FieldOrderServiceTime:
		return m.OrderServiceTime()
	case orderinfo.FieldOrderProcessTime:
		return m.OrderProcessTime()
	case orderinfo.FieldOrderRedrawTime:
		return m.OrderRedrawTime()
	case orderinfo.FieldOrderCancelTime:
		return m.OrderCancelTime()
	case orderinfo.FieldIsActive:
		return m.IsActive()
	case orderinfo.FieldHasOrderSetting:
		return m.HasOrderSetting()
	case orderinfo.FieldOrderCanceled:
		return m.OrderCanceled()
	case orderinfo.FieldOrderFlagged:
		return m.OrderFlagged()
	case orderinfo.FieldOrderStatus:
		return m.OrderStatus()
	case orderinfo.FieldOrderMajorStatus:
		return m.OrderMajorStatus()
	case orderinfo.FieldOrderKitStatus:
		return m.OrderKitStatus()
	case orderinfo.FieldOrderReportStatus:
		return m.OrderReportStatus()
	case orderinfo.FieldOrderTnpIssueStatus:
		return m.OrderTnpIssueStatus()
	case orderinfo.FieldOrderBillingIssueStatus:
		return m.OrderBillingIssueStatus()
	case orderinfo.FieldOrderMissingInfoIssueStatus:
		return m.OrderMissingInfoIssueStatus()
	case orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus:
		return m.OrderIncompleteQuestionnaireIssueStatus()
	case orderinfo.FieldOrderNyWaiveFormIssueStatus:
		return m.OrderNyWaiveFormIssueStatus()
	case orderinfo.FieldOrderLabIssueStatus:
		return m.OrderLabIssueStatus()
	case orderinfo.FieldOrderProcessingTime:
		return m.OrderProcessingTime()
	case orderinfo.FieldOrderMinorStatus:
		return m.OrderMinorStatus()
	case orderinfo.FieldPatientFirstName:
		return m.PatientFirstName()
	case orderinfo.FieldPatientLastName:
		return m.PatientLastName()
	case orderinfo.FieldOrderSource:
		return m.OrderSource()
	case orderinfo.FieldOrderChargeMethod:
		return m.OrderChargeMethod()
	case orderinfo.FieldOrderPlacingType:
		return m.OrderPlacingType()
	case orderinfo.FieldBillingOrderID:
		return m.BillingOrderID()
	case orderinfo.FieldContactID:
		return m.ContactID()
	case orderinfo.FieldAddressID:
		return m.AddressID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderinfo.FieldOrderTitle:
		return m.OldOrderTitle(ctx)
	case orderinfo.FieldOrderType:
		return m.OldOrderType(ctx)
	case orderinfo.FieldOrderDescription:
		return m.OldOrderDescription(ctx)
	case orderinfo.FieldOrderConfirmationNumber:
		return m.OldOrderConfirmationNumber(ctx)
	case orderinfo.FieldClinicID:
		return m.OldClinicID(ctx)
	case orderinfo.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case orderinfo.FieldOrderCreateTime:
		return m.OldOrderCreateTime(ctx)
	case orderinfo.FieldOrderServiceTime:
		return m.OldOrderServiceTime(ctx)
	case orderinfo.FieldOrderProcessTime:
		return m.OldOrderProcessTime(ctx)
	case orderinfo.FieldOrderRedrawTime:
		return m.OldOrderRedrawTime(ctx)
	case orderinfo.FieldOrderCancelTime:
		return m.OldOrderCancelTime(ctx)
	case orderinfo.FieldIsActive:
		return m.OldIsActive(ctx)
	case orderinfo.FieldHasOrderSetting:
		return m.OldHasOrderSetting(ctx)
	case orderinfo.FieldOrderCanceled:
		return m.OldOrderCanceled(ctx)
	case orderinfo.FieldOrderFlagged:
		return m.OldOrderFlagged(ctx)
	case orderinfo.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	case orderinfo.FieldOrderMajorStatus:
		return m.OldOrderMajorStatus(ctx)
	case orderinfo.FieldOrderKitStatus:
		return m.OldOrderKitStatus(ctx)
	case orderinfo.FieldOrderReportStatus:
		return m.OldOrderReportStatus(ctx)
	case orderinfo.FieldOrderTnpIssueStatus:
		return m.OldOrderTnpIssueStatus(ctx)
	case orderinfo.FieldOrderBillingIssueStatus:
		return m.OldOrderBillingIssueStatus(ctx)
	case orderinfo.FieldOrderMissingInfoIssueStatus:
		return m.OldOrderMissingInfoIssueStatus(ctx)
	case orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus:
		return m.OldOrderIncompleteQuestionnaireIssueStatus(ctx)
	case orderinfo.FieldOrderNyWaiveFormIssueStatus:
		return m.OldOrderNyWaiveFormIssueStatus(ctx)
	case orderinfo.FieldOrderLabIssueStatus:
		return m.OldOrderLabIssueStatus(ctx)
	case orderinfo.FieldOrderProcessingTime:
		return m.OldOrderProcessingTime(ctx)
	case orderinfo.FieldOrderMinorStatus:
		return m.OldOrderMinorStatus(ctx)
	case orderinfo.FieldPatientFirstName:
		return m.OldPatientFirstName(ctx)
	case orderinfo.FieldPatientLastName:
		return m.OldPatientLastName(ctx)
	case orderinfo.FieldOrderSource:
		return m.OldOrderSource(ctx)
	case orderinfo.FieldOrderChargeMethod:
		return m.OldOrderChargeMethod(ctx)
	case orderinfo.FieldOrderPlacingType:
		return m.OldOrderPlacingType(ctx)
	case orderinfo.FieldBillingOrderID:
		return m.OldBillingOrderID(ctx)
	case orderinfo.FieldContactID:
		return m.OldContactID(ctx)
	case orderinfo.FieldAddressID:
		return m.OldAddressID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderinfo.FieldOrderTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderTitle(v)
		return nil
	case orderinfo.FieldOrderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderType(v)
		return nil
	case orderinfo.FieldOrderDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDescription(v)
		return nil
	case orderinfo.FieldOrderConfirmationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderConfirmationNumber(v)
		return nil
	case orderinfo.FieldClinicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case orderinfo.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case orderinfo.FieldOrderCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCreateTime(v)
		return nil
	case orderinfo.FieldOrderServiceTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderServiceTime(v)
		return nil
	case orderinfo.FieldOrderProcessTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderProcessTime(v)
		return nil
	case orderinfo.FieldOrderRedrawTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderRedrawTime(v)
		return nil
	case orderinfo.FieldOrderCancelTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCancelTime(v)
		return nil
	case orderinfo.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case orderinfo.FieldHasOrderSetting:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasOrderSetting(v)
		return nil
	case orderinfo.FieldOrderCanceled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCanceled(v)
		return nil
	case orderinfo.FieldOrderFlagged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlagged(v)
		return nil
	case orderinfo.FieldOrderStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	case orderinfo.FieldOrderMajorStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMajorStatus(v)
		return nil
	case orderinfo.FieldOrderKitStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderKitStatus(v)
		return nil
	case orderinfo.FieldOrderReportStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderReportStatus(v)
		return nil
	case orderinfo.FieldOrderTnpIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderTnpIssueStatus(v)
		return nil
	case orderinfo.FieldOrderBillingIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderBillingIssueStatus(v)
		return nil
	case orderinfo.FieldOrderMissingInfoIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMissingInfoIssueStatus(v)
		return nil
	case orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderIncompleteQuestionnaireIssueStatus(v)
		return nil
	case orderinfo.FieldOrderNyWaiveFormIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNyWaiveFormIssueStatus(v)
		return nil
	case orderinfo.FieldOrderLabIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderLabIssueStatus(v)
		return nil
	case orderinfo.FieldOrderProcessingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderProcessingTime(v)
		return nil
	case orderinfo.FieldOrderMinorStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMinorStatus(v)
		return nil
	case orderinfo.FieldPatientFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFirstName(v)
		return nil
	case orderinfo.FieldPatientLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientLastName(v)
		return nil
	case orderinfo.FieldOrderSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSource(v)
		return nil
	case orderinfo.FieldOrderChargeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderChargeMethod(v)
		return nil
	case orderinfo.FieldOrderPlacingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPlacingType(v)
		return nil
	case orderinfo.FieldBillingOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingOrderID(v)
		return nil
	case orderinfo.FieldContactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactID(v)
		return nil
	case orderinfo.FieldAddressID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderInfoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderinfo.FieldClinicID) {
		fields = append(fields, orderinfo.FieldClinicID)
	}
	if m.FieldCleared(orderinfo.FieldCustomerID) {
		fields = append(fields, orderinfo.FieldCustomerID)
	}
	if m.FieldCleared(orderinfo.FieldOrderServiceTime) {
		fields = append(fields, orderinfo.FieldOrderServiceTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderProcessTime) {
		fields = append(fields, orderinfo.FieldOrderProcessTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderRedrawTime) {
		fields = append(fields, orderinfo.FieldOrderRedrawTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderCancelTime) {
		fields = append(fields, orderinfo.FieldOrderCancelTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderStatus) {
		fields = append(fields, orderinfo.FieldOrderStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderMajorStatus) {
		fields = append(fields, orderinfo.FieldOrderMajorStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderKitStatus) {
		fields = append(fields, orderinfo.FieldOrderKitStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderReportStatus) {
		fields = append(fields, orderinfo.FieldOrderReportStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderTnpIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderTnpIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderBillingIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderBillingIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderMissingInfoIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderMissingInfoIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderNyWaiveFormIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderNyWaiveFormIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderLabIssueStatus) {
		fields = append(fields, orderinfo.FieldOrderLabIssueStatus)
	}
	if m.FieldCleared(orderinfo.FieldOrderProcessingTime) {
		fields = append(fields, orderinfo.FieldOrderProcessingTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderMinorStatus) {
		fields = append(fields, orderinfo.FieldOrderMinorStatus)
	}
	if m.FieldCleared(orderinfo.FieldPatientFirstName) {
		fields = append(fields, orderinfo.FieldPatientFirstName)
	}
	if m.FieldCleared(orderinfo.FieldPatientLastName) {
		fields = append(fields, orderinfo.FieldPatientLastName)
	}
	if m.FieldCleared(orderinfo.FieldOrderSource) {
		fields = append(fields, orderinfo.FieldOrderSource)
	}
	if m.FieldCleared(orderinfo.FieldOrderChargeMethod) {
		fields = append(fields, orderinfo.FieldOrderChargeMethod)
	}
	if m.FieldCleared(orderinfo.FieldOrderPlacingType) {
		fields = append(fields, orderinfo.FieldOrderPlacingType)
	}
	if m.FieldCleared(orderinfo.FieldBillingOrderID) {
		fields = append(fields, orderinfo.FieldBillingOrderID)
	}
	if m.FieldCleared(orderinfo.FieldContactID) {
		fields = append(fields, orderinfo.FieldContactID)
	}
	if m.FieldCleared(orderinfo.FieldAddressID) {
		fields = append(fields, orderinfo.FieldAddressID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderInfoMutation) ClearField(name string) error {
	switch name {
	case orderinfo.FieldClinicID:
		m.ClearClinicID()
		return nil
	case orderinfo.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case orderinfo.FieldOrderServiceTime:
		m.ClearOrderServiceTime()
		return nil
	case orderinfo.FieldOrderProcessTime:
		m.ClearOrderProcessTime()
		return nil
	case orderinfo.FieldOrderRedrawTime:
		m.ClearOrderRedrawTime()
		return nil
	case orderinfo.FieldOrderCancelTime:
		m.ClearOrderCancelTime()
		return nil
	case orderinfo.FieldOrderStatus:
		m.ClearOrderStatus()
		return nil
	case orderinfo.FieldOrderMajorStatus:
		m.ClearOrderMajorStatus()
		return nil
	case orderinfo.FieldOrderKitStatus:
		m.ClearOrderKitStatus()
		return nil
	case orderinfo.FieldOrderReportStatus:
		m.ClearOrderReportStatus()
		return nil
	case orderinfo.FieldOrderTnpIssueStatus:
		m.ClearOrderTnpIssueStatus()
		return nil
	case orderinfo.FieldOrderBillingIssueStatus:
		m.ClearOrderBillingIssueStatus()
		return nil
	case orderinfo.FieldOrderMissingInfoIssueStatus:
		m.ClearOrderMissingInfoIssueStatus()
		return nil
	case orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus:
		m.ClearOrderIncompleteQuestionnaireIssueStatus()
		return nil
	case orderinfo.FieldOrderNyWaiveFormIssueStatus:
		m.ClearOrderNyWaiveFormIssueStatus()
		return nil
	case orderinfo.FieldOrderLabIssueStatus:
		m.ClearOrderLabIssueStatus()
		return nil
	case orderinfo.FieldOrderProcessingTime:
		m.ClearOrderProcessingTime()
		return nil
	case orderinfo.FieldOrderMinorStatus:
		m.ClearOrderMinorStatus()
		return nil
	case orderinfo.FieldPatientFirstName:
		m.ClearPatientFirstName()
		return nil
	case orderinfo.FieldPatientLastName:
		m.ClearPatientLastName()
		return nil
	case orderinfo.FieldOrderSource:
		m.ClearOrderSource()
		return nil
	case orderinfo.FieldOrderChargeMethod:
		m.ClearOrderChargeMethod()
		return nil
	case orderinfo.FieldOrderPlacingType:
		m.ClearOrderPlacingType()
		return nil
	case orderinfo.FieldBillingOrderID:
		m.ClearBillingOrderID()
		return nil
	case orderinfo.FieldContactID:
		m.ClearContactID()
		return nil
	case orderinfo.FieldAddressID:
		m.ClearAddressID()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderInfoMutation) ResetField(name string) error {
	switch name {
	case orderinfo.FieldOrderTitle:
		m.ResetOrderTitle()
		return nil
	case orderinfo.FieldOrderType:
		m.ResetOrderType()
		return nil
	case orderinfo.FieldOrderDescription:
		m.ResetOrderDescription()
		return nil
	case orderinfo.FieldOrderConfirmationNumber:
		m.ResetOrderConfirmationNumber()
		return nil
	case orderinfo.FieldClinicID:
		m.ResetClinicID()
		return nil
	case orderinfo.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case orderinfo.FieldOrderCreateTime:
		m.ResetOrderCreateTime()
		return nil
	case orderinfo.FieldOrderServiceTime:
		m.ResetOrderServiceTime()
		return nil
	case orderinfo.FieldOrderProcessTime:
		m.ResetOrderProcessTime()
		return nil
	case orderinfo.FieldOrderRedrawTime:
		m.ResetOrderRedrawTime()
		return nil
	case orderinfo.FieldOrderCancelTime:
		m.ResetOrderCancelTime()
		return nil
	case orderinfo.FieldIsActive:
		m.ResetIsActive()
		return nil
	case orderinfo.FieldHasOrderSetting:
		m.ResetHasOrderSetting()
		return nil
	case orderinfo.FieldOrderCanceled:
		m.ResetOrderCanceled()
		return nil
	case orderinfo.FieldOrderFlagged:
		m.ResetOrderFlagged()
		return nil
	case orderinfo.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	case orderinfo.FieldOrderMajorStatus:
		m.ResetOrderMajorStatus()
		return nil
	case orderinfo.FieldOrderKitStatus:
		m.ResetOrderKitStatus()
		return nil
	case orderinfo.FieldOrderReportStatus:
		m.ResetOrderReportStatus()
		return nil
	case orderinfo.FieldOrderTnpIssueStatus:
		m.ResetOrderTnpIssueStatus()
		return nil
	case orderinfo.FieldOrderBillingIssueStatus:
		m.ResetOrderBillingIssueStatus()
		return nil
	case orderinfo.FieldOrderMissingInfoIssueStatus:
		m.ResetOrderMissingInfoIssueStatus()
		return nil
	case orderinfo.FieldOrderIncompleteQuestionnaireIssueStatus:
		m.ResetOrderIncompleteQuestionnaireIssueStatus()
		return nil
	case orderinfo.FieldOrderNyWaiveFormIssueStatus:
		m.ResetOrderNyWaiveFormIssueStatus()
		return nil
	case orderinfo.FieldOrderLabIssueStatus:
		m.ResetOrderLabIssueStatus()
		return nil
	case orderinfo.FieldOrderProcessingTime:
		m.ResetOrderProcessingTime()
		return nil
	case orderinfo.FieldOrderMinorStatus:
		m.ResetOrderMinorStatus()
		return nil
	case orderinfo.FieldPatientFirstName:
		m.ResetPatientFirstName()
		return nil
	case orderinfo.FieldPatientLastName:
		m.ResetPatientLastName()
		return nil
	case orderinfo.FieldOrderSource:
		m.ResetOrderSource()
		return nil
	case orderinfo.FieldOrderChargeMethod:
		m.ResetOrderChargeMethod()
		return nil
	case orderinfo.FieldOrderPlacingType:
		m.ResetOrderPlacingType()
		return nil
	case orderinfo.FieldBillingOrderID:
		m.ResetBillingOrderID()
		return nil
	case orderinfo.FieldContactID:
		m.ResetContactID()
		return nil
	case orderinfo.FieldAddressID:
		m.ResetAddressID()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.tests != nil {
		edges = append(edges, orderinfo.EdgeTests)
	}
	if m.order_flags != nil {
		edges = append(edges, orderinfo.EdgeOrderFlags)
	}
	if m.sample != nil {
		edges = append(edges, orderinfo.EdgeSample)
	}
	if m.contact != nil {
		edges = append(edges, orderinfo.EdgeContact)
	}
	if m.address != nil {
		edges = append(edges, orderinfo.EdgeAddress)
	}
	if m.clinic != nil {
		edges = append(edges, orderinfo.EdgeClinic)
	}
	if m.customer_info != nil {
		edges = append(edges, orderinfo.EdgeCustomerInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeOrderFlags:
		ids := make([]ent.Value, 0, len(m.order_flags))
		for id := range m.order_flags {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeContact:
		if id := m.contact; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeCustomerInfo:
		if id := m.customer_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedtests != nil {
		edges = append(edges, orderinfo.EdgeTests)
	}
	if m.removedorder_flags != nil {
		edges = append(edges, orderinfo.EdgeOrderFlags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeOrderFlags:
		ids := make([]ent.Value, 0, len(m.removedorder_flags))
		for id := range m.removedorder_flags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtests {
		edges = append(edges, orderinfo.EdgeTests)
	}
	if m.clearedorder_flags {
		edges = append(edges, orderinfo.EdgeOrderFlags)
	}
	if m.clearedsample {
		edges = append(edges, orderinfo.EdgeSample)
	}
	if m.clearedcontact {
		edges = append(edges, orderinfo.EdgeContact)
	}
	if m.clearedaddress {
		edges = append(edges, orderinfo.EdgeAddress)
	}
	if m.clearedclinic {
		edges = append(edges, orderinfo.EdgeClinic)
	}
	if m.clearedcustomer_info {
		edges = append(edges, orderinfo.EdgeCustomerInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case orderinfo.EdgeTests:
		return m.clearedtests
	case orderinfo.EdgeOrderFlags:
		return m.clearedorder_flags
	case orderinfo.EdgeSample:
		return m.clearedsample
	case orderinfo.EdgeContact:
		return m.clearedcontact
	case orderinfo.EdgeAddress:
		return m.clearedaddress
	case orderinfo.EdgeClinic:
		return m.clearedclinic
	case orderinfo.EdgeCustomerInfo:
		return m.clearedcustomer_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderInfoMutation) ClearEdge(name string) error {
	switch name {
	case orderinfo.EdgeSample:
		m.ClearSample()
		return nil
	case orderinfo.EdgeContact:
		m.ClearContact()
		return nil
	case orderinfo.EdgeAddress:
		m.ClearAddress()
		return nil
	case orderinfo.EdgeClinic:
		m.ClearClinic()
		return nil
	case orderinfo.EdgeCustomerInfo:
		m.ClearCustomerInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderInfoMutation) ResetEdge(name string) error {
	switch name {
	case orderinfo.EdgeTests:
		m.ResetTests()
		return nil
	case orderinfo.EdgeOrderFlags:
		m.ResetOrderFlags()
		return nil
	case orderinfo.EdgeSample:
		m.ResetSample()
		return nil
	case orderinfo.EdgeContact:
		m.ResetContact()
		return nil
	case orderinfo.EdgeAddress:
		m.ResetAddress()
		return nil
	case orderinfo.EdgeClinic:
		m.ResetClinic()
		return nil
	case orderinfo.EdgeCustomerInfo:
		m.ResetCustomerInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	patient_type                         *string
	original_patient_id                  *int
	addoriginal_patient_id               *int
	patient_gender                       *string
	patient_first_name                   *string
	patient_last_name                    *string
	patient_middle_name                  *string
	patient_medical_record_number        *string
	patient_legal_firstname              *string
	patient_legal_lastname               *string
	patient_honorific                    *string
	patient_suffix                       *string
	patient_marital                      *string
	patient_ethnicity                    *string
	patient_birthdate                    *string
	patient_ssn                          *string
	patient_height                       *string
	patient_weight                       *string
	officeally_id                        *int
	addofficeally_id                     *int
	patient_ny_waive_form_issue_status   *string
	patient_create_time                  *time.Time
	isActive                             *bool
	patient_flagged                      *bool
	patient_service_date                 *time.Time
	patient_description                  *string
	patient_language                     *string
	clearedFields                        map[string]struct{}
	current_customer                     *int
	clearedcurrent_customer              bool
	patient_customers                    map[int]struct{}
	removedpatient_customers             map[int]struct{}
	clearedpatient_customers             bool
	samples                              map[int]struct{}
	removedsamples                       map[int]struct{}
	clearedsamples                       bool
	patient_contacts                     map[int]struct{}
	removedpatient_contacts              map[int]struct{}
	clearedpatient_contacts              bool
	patient_addresses                    map[int]struct{}
	removedpatient_addresses             map[int]struct{}
	clearedpatient_addresses             bool
	patient_clinics                      map[int]struct{}
	removedpatient_clinics               map[int]struct{}
	clearedpatient_clinics               bool
	user                                 *int
	cleareduser                          bool
	patient_weight_height_history        map[int]struct{}
	removedpatient_weight_height_history map[int]struct{}
	clearedpatient_weight_height_history bool
	patient_settings                     map[int]struct{}
	removedpatient_settings              map[int]struct{}
	clearedpatient_settings              bool
	done                                 bool
	oldValue                             func(context.Context) (*Patient, error)
	predicates                           []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PatientMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PatientMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PatientMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[patient.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PatientMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[patient.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PatientMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, patient.FieldUserID)
}

// SetPatientType sets the "patient_type" field.
func (m *PatientMutation) SetPatientType(s string) {
	m.patient_type = &s
}

// PatientType returns the value of the "patient_type" field in the mutation.
func (m *PatientMutation) PatientType() (r string, exists bool) {
	v := m.patient_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientType returns the old "patient_type" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientType: %w", err)
	}
	return oldValue.PatientType, nil
}

// ResetPatientType resets all changes to the "patient_type" field.
func (m *PatientMutation) ResetPatientType() {
	m.patient_type = nil
}

// SetOriginalPatientID sets the "original_patient_id" field.
func (m *PatientMutation) SetOriginalPatientID(i int) {
	m.original_patient_id = &i
	m.addoriginal_patient_id = nil
}

// OriginalPatientID returns the value of the "original_patient_id" field in the mutation.
func (m *PatientMutation) OriginalPatientID() (r int, exists bool) {
	v := m.original_patient_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalPatientID returns the old "original_patient_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldOriginalPatientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalPatientID: %w", err)
	}
	return oldValue.OriginalPatientID, nil
}

// AddOriginalPatientID adds i to the "original_patient_id" field.
func (m *PatientMutation) AddOriginalPatientID(i int) {
	if m.addoriginal_patient_id != nil {
		*m.addoriginal_patient_id += i
	} else {
		m.addoriginal_patient_id = &i
	}
}

// AddedOriginalPatientID returns the value that was added to the "original_patient_id" field in this mutation.
func (m *PatientMutation) AddedOriginalPatientID() (r int, exists bool) {
	v := m.addoriginal_patient_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginalPatientID clears the value of the "original_patient_id" field.
func (m *PatientMutation) ClearOriginalPatientID() {
	m.original_patient_id = nil
	m.addoriginal_patient_id = nil
	m.clearedFields[patient.FieldOriginalPatientID] = struct{}{}
}

// OriginalPatientIDCleared returns if the "original_patient_id" field was cleared in this mutation.
func (m *PatientMutation) OriginalPatientIDCleared() bool {
	_, ok := m.clearedFields[patient.FieldOriginalPatientID]
	return ok
}

// ResetOriginalPatientID resets all changes to the "original_patient_id" field.
func (m *PatientMutation) ResetOriginalPatientID() {
	m.original_patient_id = nil
	m.addoriginal_patient_id = nil
	delete(m.clearedFields, patient.FieldOriginalPatientID)
}

// SetPatientGender sets the "patient_gender" field.
func (m *PatientMutation) SetPatientGender(s string) {
	m.patient_gender = &s
}

// PatientGender returns the value of the "patient_gender" field in the mutation.
func (m *PatientMutation) PatientGender() (r string, exists bool) {
	v := m.patient_gender
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientGender returns the old "patient_gender" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientGender: %w", err)
	}
	return oldValue.PatientGender, nil
}

// ClearPatientGender clears the value of the "patient_gender" field.
func (m *PatientMutation) ClearPatientGender() {
	m.patient_gender = nil
	m.clearedFields[patient.FieldPatientGender] = struct{}{}
}

// PatientGenderCleared returns if the "patient_gender" field was cleared in this mutation.
func (m *PatientMutation) PatientGenderCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientGender]
	return ok
}

// ResetPatientGender resets all changes to the "patient_gender" field.
func (m *PatientMutation) ResetPatientGender() {
	m.patient_gender = nil
	delete(m.clearedFields, patient.FieldPatientGender)
}

// SetPatientFirstName sets the "patient_first_name" field.
func (m *PatientMutation) SetPatientFirstName(s string) {
	m.patient_first_name = &s
}

// PatientFirstName returns the value of the "patient_first_name" field in the mutation.
func (m *PatientMutation) PatientFirstName() (r string, exists bool) {
	v := m.patient_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFirstName returns the old "patient_first_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFirstName: %w", err)
	}
	return oldValue.PatientFirstName, nil
}

// ClearPatientFirstName clears the value of the "patient_first_name" field.
func (m *PatientMutation) ClearPatientFirstName() {
	m.patient_first_name = nil
	m.clearedFields[patient.FieldPatientFirstName] = struct{}{}
}

// PatientFirstNameCleared returns if the "patient_first_name" field was cleared in this mutation.
func (m *PatientMutation) PatientFirstNameCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientFirstName]
	return ok
}

// ResetPatientFirstName resets all changes to the "patient_first_name" field.
func (m *PatientMutation) ResetPatientFirstName() {
	m.patient_first_name = nil
	delete(m.clearedFields, patient.FieldPatientFirstName)
}

// SetPatientLastName sets the "patient_last_name" field.
func (m *PatientMutation) SetPatientLastName(s string) {
	m.patient_last_name = &s
}

// PatientLastName returns the value of the "patient_last_name" field in the mutation.
func (m *PatientMutation) PatientLastName() (r string, exists bool) {
	v := m.patient_last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientLastName returns the old "patient_last_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientLastName: %w", err)
	}
	return oldValue.PatientLastName, nil
}

// ClearPatientLastName clears the value of the "patient_last_name" field.
func (m *PatientMutation) ClearPatientLastName() {
	m.patient_last_name = nil
	m.clearedFields[patient.FieldPatientLastName] = struct{}{}
}

// PatientLastNameCleared returns if the "patient_last_name" field was cleared in this mutation.
func (m *PatientMutation) PatientLastNameCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientLastName]
	return ok
}

// ResetPatientLastName resets all changes to the "patient_last_name" field.
func (m *PatientMutation) ResetPatientLastName() {
	m.patient_last_name = nil
	delete(m.clearedFields, patient.FieldPatientLastName)
}

// SetPatientMiddleName sets the "patient_middle_name" field.
func (m *PatientMutation) SetPatientMiddleName(s string) {
	m.patient_middle_name = &s
}

// PatientMiddleName returns the value of the "patient_middle_name" field in the mutation.
func (m *PatientMutation) PatientMiddleName() (r string, exists bool) {
	v := m.patient_middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientMiddleName returns the old "patient_middle_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientMiddleName: %w", err)
	}
	return oldValue.PatientMiddleName, nil
}

// ClearPatientMiddleName clears the value of the "patient_middle_name" field.
func (m *PatientMutation) ClearPatientMiddleName() {
	m.patient_middle_name = nil
	m.clearedFields[patient.FieldPatientMiddleName] = struct{}{}
}

// PatientMiddleNameCleared returns if the "patient_middle_name" field was cleared in this mutation.
func (m *PatientMutation) PatientMiddleNameCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientMiddleName]
	return ok
}

// ResetPatientMiddleName resets all changes to the "patient_middle_name" field.
func (m *PatientMutation) ResetPatientMiddleName() {
	m.patient_middle_name = nil
	delete(m.clearedFields, patient.FieldPatientMiddleName)
}

// SetPatientMedicalRecordNumber sets the "patient_medical_record_number" field.
func (m *PatientMutation) SetPatientMedicalRecordNumber(s string) {
	m.patient_medical_record_number = &s
}

// PatientMedicalRecordNumber returns the value of the "patient_medical_record_number" field in the mutation.
func (m *PatientMutation) PatientMedicalRecordNumber() (r string, exists bool) {
	v := m.patient_medical_record_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientMedicalRecordNumber returns the old "patient_medical_record_number" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientMedicalRecordNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientMedicalRecordNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientMedicalRecordNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientMedicalRecordNumber: %w", err)
	}
	return oldValue.PatientMedicalRecordNumber, nil
}

// ClearPatientMedicalRecordNumber clears the value of the "patient_medical_record_number" field.
func (m *PatientMutation) ClearPatientMedicalRecordNumber() {
	m.patient_medical_record_number = nil
	m.clearedFields[patient.FieldPatientMedicalRecordNumber] = struct{}{}
}

// PatientMedicalRecordNumberCleared returns if the "patient_medical_record_number" field was cleared in this mutation.
func (m *PatientMutation) PatientMedicalRecordNumberCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientMedicalRecordNumber]
	return ok
}

// ResetPatientMedicalRecordNumber resets all changes to the "patient_medical_record_number" field.
func (m *PatientMutation) ResetPatientMedicalRecordNumber() {
	m.patient_medical_record_number = nil
	delete(m.clearedFields, patient.FieldPatientMedicalRecordNumber)
}

// SetPatientLegalFirstname sets the "patient_legal_firstname" field.
func (m *PatientMutation) SetPatientLegalFirstname(s string) {
	m.patient_legal_firstname = &s
}

// PatientLegalFirstname returns the value of the "patient_legal_firstname" field in the mutation.
func (m *PatientMutation) PatientLegalFirstname() (r string, exists bool) {
	v := m.patient_legal_firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientLegalFirstname returns the old "patient_legal_firstname" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientLegalFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientLegalFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientLegalFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientLegalFirstname: %w", err)
	}
	return oldValue.PatientLegalFirstname, nil
}

// ClearPatientLegalFirstname clears the value of the "patient_legal_firstname" field.
func (m *PatientMutation) ClearPatientLegalFirstname() {
	m.patient_legal_firstname = nil
	m.clearedFields[patient.FieldPatientLegalFirstname] = struct{}{}
}

// PatientLegalFirstnameCleared returns if the "patient_legal_firstname" field was cleared in this mutation.
func (m *PatientMutation) PatientLegalFirstnameCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientLegalFirstname]
	return ok
}

// ResetPatientLegalFirstname resets all changes to the "patient_legal_firstname" field.
func (m *PatientMutation) ResetPatientLegalFirstname() {
	m.patient_legal_firstname = nil
	delete(m.clearedFields, patient.FieldPatientLegalFirstname)
}

// SetPatientLegalLastname sets the "patient_legal_lastname" field.
func (m *PatientMutation) SetPatientLegalLastname(s string) {
	m.patient_legal_lastname = &s
}

// PatientLegalLastname returns the value of the "patient_legal_lastname" field in the mutation.
func (m *PatientMutation) PatientLegalLastname() (r string, exists bool) {
	v := m.patient_legal_lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientLegalLastname returns the old "patient_legal_lastname" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientLegalLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientLegalLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientLegalLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientLegalLastname: %w", err)
	}
	return oldValue.PatientLegalLastname, nil
}

// ClearPatientLegalLastname clears the value of the "patient_legal_lastname" field.
func (m *PatientMutation) ClearPatientLegalLastname() {
	m.patient_legal_lastname = nil
	m.clearedFields[patient.FieldPatientLegalLastname] = struct{}{}
}

// PatientLegalLastnameCleared returns if the "patient_legal_lastname" field was cleared in this mutation.
func (m *PatientMutation) PatientLegalLastnameCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientLegalLastname]
	return ok
}

// ResetPatientLegalLastname resets all changes to the "patient_legal_lastname" field.
func (m *PatientMutation) ResetPatientLegalLastname() {
	m.patient_legal_lastname = nil
	delete(m.clearedFields, patient.FieldPatientLegalLastname)
}

// SetPatientHonorific sets the "patient_honorific" field.
func (m *PatientMutation) SetPatientHonorific(s string) {
	m.patient_honorific = &s
}

// PatientHonorific returns the value of the "patient_honorific" field in the mutation.
func (m *PatientMutation) PatientHonorific() (r string, exists bool) {
	v := m.patient_honorific
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientHonorific returns the old "patient_honorific" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientHonorific(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientHonorific is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientHonorific requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientHonorific: %w", err)
	}
	return oldValue.PatientHonorific, nil
}

// ClearPatientHonorific clears the value of the "patient_honorific" field.
func (m *PatientMutation) ClearPatientHonorific() {
	m.patient_honorific = nil
	m.clearedFields[patient.FieldPatientHonorific] = struct{}{}
}

// PatientHonorificCleared returns if the "patient_honorific" field was cleared in this mutation.
func (m *PatientMutation) PatientHonorificCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientHonorific]
	return ok
}

// ResetPatientHonorific resets all changes to the "patient_honorific" field.
func (m *PatientMutation) ResetPatientHonorific() {
	m.patient_honorific = nil
	delete(m.clearedFields, patient.FieldPatientHonorific)
}

// SetPatientSuffix sets the "patient_suffix" field.
func (m *PatientMutation) SetPatientSuffix(s string) {
	m.patient_suffix = &s
}

// PatientSuffix returns the value of the "patient_suffix" field in the mutation.
func (m *PatientMutation) PatientSuffix() (r string, exists bool) {
	v := m.patient_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientSuffix returns the old "patient_suffix" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientSuffix: %w", err)
	}
	return oldValue.PatientSuffix, nil
}

// ClearPatientSuffix clears the value of the "patient_suffix" field.
func (m *PatientMutation) ClearPatientSuffix() {
	m.patient_suffix = nil
	m.clearedFields[patient.FieldPatientSuffix] = struct{}{}
}

// PatientSuffixCleared returns if the "patient_suffix" field was cleared in this mutation.
func (m *PatientMutation) PatientSuffixCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientSuffix]
	return ok
}

// ResetPatientSuffix resets all changes to the "patient_suffix" field.
func (m *PatientMutation) ResetPatientSuffix() {
	m.patient_suffix = nil
	delete(m.clearedFields, patient.FieldPatientSuffix)
}

// SetPatientMarital sets the "patient_marital" field.
func (m *PatientMutation) SetPatientMarital(s string) {
	m.patient_marital = &s
}

// PatientMarital returns the value of the "patient_marital" field in the mutation.
func (m *PatientMutation) PatientMarital() (r string, exists bool) {
	v := m.patient_marital
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientMarital returns the old "patient_marital" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientMarital(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientMarital is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientMarital requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientMarital: %w", err)
	}
	return oldValue.PatientMarital, nil
}

// ClearPatientMarital clears the value of the "patient_marital" field.
func (m *PatientMutation) ClearPatientMarital() {
	m.patient_marital = nil
	m.clearedFields[patient.FieldPatientMarital] = struct{}{}
}

// PatientMaritalCleared returns if the "patient_marital" field was cleared in this mutation.
func (m *PatientMutation) PatientMaritalCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientMarital]
	return ok
}

// ResetPatientMarital resets all changes to the "patient_marital" field.
func (m *PatientMutation) ResetPatientMarital() {
	m.patient_marital = nil
	delete(m.clearedFields, patient.FieldPatientMarital)
}

// SetPatientEthnicity sets the "patient_ethnicity" field.
func (m *PatientMutation) SetPatientEthnicity(s string) {
	m.patient_ethnicity = &s
}

// PatientEthnicity returns the value of the "patient_ethnicity" field in the mutation.
func (m *PatientMutation) PatientEthnicity() (r string, exists bool) {
	v := m.patient_ethnicity
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientEthnicity returns the old "patient_ethnicity" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientEthnicity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientEthnicity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientEthnicity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientEthnicity: %w", err)
	}
	return oldValue.PatientEthnicity, nil
}

// ClearPatientEthnicity clears the value of the "patient_ethnicity" field.
func (m *PatientMutation) ClearPatientEthnicity() {
	m.patient_ethnicity = nil
	m.clearedFields[patient.FieldPatientEthnicity] = struct{}{}
}

// PatientEthnicityCleared returns if the "patient_ethnicity" field was cleared in this mutation.
func (m *PatientMutation) PatientEthnicityCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientEthnicity]
	return ok
}

// ResetPatientEthnicity resets all changes to the "patient_ethnicity" field.
func (m *PatientMutation) ResetPatientEthnicity() {
	m.patient_ethnicity = nil
	delete(m.clearedFields, patient.FieldPatientEthnicity)
}

// SetPatientBirthdate sets the "patient_birthdate" field.
func (m *PatientMutation) SetPatientBirthdate(s string) {
	m.patient_birthdate = &s
}

// PatientBirthdate returns the value of the "patient_birthdate" field in the mutation.
func (m *PatientMutation) PatientBirthdate() (r string, exists bool) {
	v := m.patient_birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientBirthdate returns the old "patient_birthdate" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientBirthdate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientBirthdate: %w", err)
	}
	return oldValue.PatientBirthdate, nil
}

// ClearPatientBirthdate clears the value of the "patient_birthdate" field.
func (m *PatientMutation) ClearPatientBirthdate() {
	m.patient_birthdate = nil
	m.clearedFields[patient.FieldPatientBirthdate] = struct{}{}
}

// PatientBirthdateCleared returns if the "patient_birthdate" field was cleared in this mutation.
func (m *PatientMutation) PatientBirthdateCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientBirthdate]
	return ok
}

// ResetPatientBirthdate resets all changes to the "patient_birthdate" field.
func (m *PatientMutation) ResetPatientBirthdate() {
	m.patient_birthdate = nil
	delete(m.clearedFields, patient.FieldPatientBirthdate)
}

// SetPatientSsn sets the "patient_ssn" field.
func (m *PatientMutation) SetPatientSsn(s string) {
	m.patient_ssn = &s
}

// PatientSsn returns the value of the "patient_ssn" field in the mutation.
func (m *PatientMutation) PatientSsn() (r string, exists bool) {
	v := m.patient_ssn
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientSsn returns the old "patient_ssn" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientSsn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientSsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientSsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientSsn: %w", err)
	}
	return oldValue.PatientSsn, nil
}

// ClearPatientSsn clears the value of the "patient_ssn" field.
func (m *PatientMutation) ClearPatientSsn() {
	m.patient_ssn = nil
	m.clearedFields[patient.FieldPatientSsn] = struct{}{}
}

// PatientSsnCleared returns if the "patient_ssn" field was cleared in this mutation.
func (m *PatientMutation) PatientSsnCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientSsn]
	return ok
}

// ResetPatientSsn resets all changes to the "patient_ssn" field.
func (m *PatientMutation) ResetPatientSsn() {
	m.patient_ssn = nil
	delete(m.clearedFields, patient.FieldPatientSsn)
}

// SetPatientHeight sets the "patient_height" field.
func (m *PatientMutation) SetPatientHeight(s string) {
	m.patient_height = &s
}

// PatientHeight returns the value of the "patient_height" field in the mutation.
func (m *PatientMutation) PatientHeight() (r string, exists bool) {
	v := m.patient_height
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientHeight returns the old "patient_height" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientHeight: %w", err)
	}
	return oldValue.PatientHeight, nil
}

// ClearPatientHeight clears the value of the "patient_height" field.
func (m *PatientMutation) ClearPatientHeight() {
	m.patient_height = nil
	m.clearedFields[patient.FieldPatientHeight] = struct{}{}
}

// PatientHeightCleared returns if the "patient_height" field was cleared in this mutation.
func (m *PatientMutation) PatientHeightCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientHeight]
	return ok
}

// ResetPatientHeight resets all changes to the "patient_height" field.
func (m *PatientMutation) ResetPatientHeight() {
	m.patient_height = nil
	delete(m.clearedFields, patient.FieldPatientHeight)
}

// SetPatientWeight sets the "patient_weight" field.
func (m *PatientMutation) SetPatientWeight(s string) {
	m.patient_weight = &s
}

// PatientWeight returns the value of the "patient_weight" field in the mutation.
func (m *PatientMutation) PatientWeight() (r string, exists bool) {
	v := m.patient_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientWeight returns the old "patient_weight" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientWeight: %w", err)
	}
	return oldValue.PatientWeight, nil
}

// ClearPatientWeight clears the value of the "patient_weight" field.
func (m *PatientMutation) ClearPatientWeight() {
	m.patient_weight = nil
	m.clearedFields[patient.FieldPatientWeight] = struct{}{}
}

// PatientWeightCleared returns if the "patient_weight" field was cleared in this mutation.
func (m *PatientMutation) PatientWeightCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientWeight]
	return ok
}

// ResetPatientWeight resets all changes to the "patient_weight" field.
func (m *PatientMutation) ResetPatientWeight() {
	m.patient_weight = nil
	delete(m.clearedFields, patient.FieldPatientWeight)
}

// SetOfficeallyID sets the "officeally_id" field.
func (m *PatientMutation) SetOfficeallyID(i int) {
	m.officeally_id = &i
	m.addofficeally_id = nil
}

// OfficeallyID returns the value of the "officeally_id" field in the mutation.
func (m *PatientMutation) OfficeallyID() (r int, exists bool) {
	v := m.officeally_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeallyID returns the old "officeally_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldOfficeallyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeallyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeallyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeallyID: %w", err)
	}
	return oldValue.OfficeallyID, nil
}

// AddOfficeallyID adds i to the "officeally_id" field.
func (m *PatientMutation) AddOfficeallyID(i int) {
	if m.addofficeally_id != nil {
		*m.addofficeally_id += i
	} else {
		m.addofficeally_id = &i
	}
}

// AddedOfficeallyID returns the value that was added to the "officeally_id" field in this mutation.
func (m *PatientMutation) AddedOfficeallyID() (r int, exists bool) {
	v := m.addofficeally_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfficeallyID clears the value of the "officeally_id" field.
func (m *PatientMutation) ClearOfficeallyID() {
	m.officeally_id = nil
	m.addofficeally_id = nil
	m.clearedFields[patient.FieldOfficeallyID] = struct{}{}
}

// OfficeallyIDCleared returns if the "officeally_id" field was cleared in this mutation.
func (m *PatientMutation) OfficeallyIDCleared() bool {
	_, ok := m.clearedFields[patient.FieldOfficeallyID]
	return ok
}

// ResetOfficeallyID resets all changes to the "officeally_id" field.
func (m *PatientMutation) ResetOfficeallyID() {
	m.officeally_id = nil
	m.addofficeally_id = nil
	delete(m.clearedFields, patient.FieldOfficeallyID)
}

// SetPatientNyWaiveFormIssueStatus sets the "patient_ny_waive_form_issue_status" field.
func (m *PatientMutation) SetPatientNyWaiveFormIssueStatus(s string) {
	m.patient_ny_waive_form_issue_status = &s
}

// PatientNyWaiveFormIssueStatus returns the value of the "patient_ny_waive_form_issue_status" field in the mutation.
func (m *PatientMutation) PatientNyWaiveFormIssueStatus() (r string, exists bool) {
	v := m.patient_ny_waive_form_issue_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientNyWaiveFormIssueStatus returns the old "patient_ny_waive_form_issue_status" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientNyWaiveFormIssueStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientNyWaiveFormIssueStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientNyWaiveFormIssueStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientNyWaiveFormIssueStatus: %w", err)
	}
	return oldValue.PatientNyWaiveFormIssueStatus, nil
}

// ResetPatientNyWaiveFormIssueStatus resets all changes to the "patient_ny_waive_form_issue_status" field.
func (m *PatientMutation) ResetPatientNyWaiveFormIssueStatus() {
	m.patient_ny_waive_form_issue_status = nil
}

// SetPatientCreateTime sets the "patient_create_time" field.
func (m *PatientMutation) SetPatientCreateTime(t time.Time) {
	m.patient_create_time = &t
}

// PatientCreateTime returns the value of the "patient_create_time" field in the mutation.
func (m *PatientMutation) PatientCreateTime() (r time.Time, exists bool) {
	v := m.patient_create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientCreateTime returns the old "patient_create_time" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientCreateTime: %w", err)
	}
	return oldValue.PatientCreateTime, nil
}

// ClearPatientCreateTime clears the value of the "patient_create_time" field.
func (m *PatientMutation) ClearPatientCreateTime() {
	m.patient_create_time = nil
	m.clearedFields[patient.FieldPatientCreateTime] = struct{}{}
}

// PatientCreateTimeCleared returns if the "patient_create_time" field was cleared in this mutation.
func (m *PatientMutation) PatientCreateTimeCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientCreateTime]
	return ok
}

// ResetPatientCreateTime resets all changes to the "patient_create_time" field.
func (m *PatientMutation) ResetPatientCreateTime() {
	m.patient_create_time = nil
	delete(m.clearedFields, patient.FieldPatientCreateTime)
}

// SetCustomerID sets the "customer_id" field.
func (m *PatientMutation) SetCustomerID(i int) {
	m.current_customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *PatientMutation) CustomerID() (r int, exists bool) {
	v := m.current_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *PatientMutation) ClearCustomerID() {
	m.current_customer = nil
	m.clearedFields[patient.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *PatientMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[patient.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *PatientMutation) ResetCustomerID() {
	m.current_customer = nil
	delete(m.clearedFields, patient.FieldCustomerID)
}

// SetIsActive sets the "isActive" field.
func (m *PatientMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *PatientMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *PatientMutation) ResetIsActive() {
	m.isActive = nil
}

// SetPatientFlagged sets the "patient_flagged" field.
func (m *PatientMutation) SetPatientFlagged(b bool) {
	m.patient_flagged = &b
}

// PatientFlagged returns the value of the "patient_flagged" field in the mutation.
func (m *PatientMutation) PatientFlagged() (r bool, exists bool) {
	v := m.patient_flagged
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagged returns the old "patient_flagged" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientFlagged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagged: %w", err)
	}
	return oldValue.PatientFlagged, nil
}

// ResetPatientFlagged resets all changes to the "patient_flagged" field.
func (m *PatientMutation) ResetPatientFlagged() {
	m.patient_flagged = nil
}

// SetPatientServiceDate sets the "patient_service_date" field.
func (m *PatientMutation) SetPatientServiceDate(t time.Time) {
	m.patient_service_date = &t
}

// PatientServiceDate returns the value of the "patient_service_date" field in the mutation.
func (m *PatientMutation) PatientServiceDate() (r time.Time, exists bool) {
	v := m.patient_service_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientServiceDate returns the old "patient_service_date" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientServiceDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientServiceDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientServiceDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientServiceDate: %w", err)
	}
	return oldValue.PatientServiceDate, nil
}

// ClearPatientServiceDate clears the value of the "patient_service_date" field.
func (m *PatientMutation) ClearPatientServiceDate() {
	m.patient_service_date = nil
	m.clearedFields[patient.FieldPatientServiceDate] = struct{}{}
}

// PatientServiceDateCleared returns if the "patient_service_date" field was cleared in this mutation.
func (m *PatientMutation) PatientServiceDateCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientServiceDate]
	return ok
}

// ResetPatientServiceDate resets all changes to the "patient_service_date" field.
func (m *PatientMutation) ResetPatientServiceDate() {
	m.patient_service_date = nil
	delete(m.clearedFields, patient.FieldPatientServiceDate)
}

// SetPatientDescription sets the "patient_description" field.
func (m *PatientMutation) SetPatientDescription(s string) {
	m.patient_description = &s
}

// PatientDescription returns the value of the "patient_description" field in the mutation.
func (m *PatientMutation) PatientDescription() (r string, exists bool) {
	v := m.patient_description
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientDescription returns the old "patient_description" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientDescription: %w", err)
	}
	return oldValue.PatientDescription, nil
}

// ClearPatientDescription clears the value of the "patient_description" field.
func (m *PatientMutation) ClearPatientDescription() {
	m.patient_description = nil
	m.clearedFields[patient.FieldPatientDescription] = struct{}{}
}

// PatientDescriptionCleared returns if the "patient_description" field was cleared in this mutation.
func (m *PatientMutation) PatientDescriptionCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientDescription]
	return ok
}

// ResetPatientDescription resets all changes to the "patient_description" field.
func (m *PatientMutation) ResetPatientDescription() {
	m.patient_description = nil
	delete(m.clearedFields, patient.FieldPatientDescription)
}

// SetPatientLanguage sets the "patient_language" field.
func (m *PatientMutation) SetPatientLanguage(s string) {
	m.patient_language = &s
}

// PatientLanguage returns the value of the "patient_language" field in the mutation.
func (m *PatientMutation) PatientLanguage() (r string, exists bool) {
	v := m.patient_language
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientLanguage returns the old "patient_language" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientLanguage: %w", err)
	}
	return oldValue.PatientLanguage, nil
}

// ClearPatientLanguage clears the value of the "patient_language" field.
func (m *PatientMutation) ClearPatientLanguage() {
	m.patient_language = nil
	m.clearedFields[patient.FieldPatientLanguage] = struct{}{}
}

// PatientLanguageCleared returns if the "patient_language" field was cleared in this mutation.
func (m *PatientMutation) PatientLanguageCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientLanguage]
	return ok
}

// ResetPatientLanguage resets all changes to the "patient_language" field.
func (m *PatientMutation) ResetPatientLanguage() {
	m.patient_language = nil
	delete(m.clearedFields, patient.FieldPatientLanguage)
}

// SetCurrentCustomerID sets the "current_customer" edge to the Customer entity by id.
func (m *PatientMutation) SetCurrentCustomerID(id int) {
	m.current_customer = &id
}

// ClearCurrentCustomer clears the "current_customer" edge to the Customer entity.
func (m *PatientMutation) ClearCurrentCustomer() {
	m.clearedcurrent_customer = true
	m.clearedFields[patient.FieldCustomerID] = struct{}{}
}

// CurrentCustomerCleared reports if the "current_customer" edge to the Customer entity was cleared.
func (m *PatientMutation) CurrentCustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcurrent_customer
}

// CurrentCustomerID returns the "current_customer" edge ID in the mutation.
func (m *PatientMutation) CurrentCustomerID() (id int, exists bool) {
	if m.current_customer != nil {
		return *m.current_customer, true
	}
	return
}

// CurrentCustomerIDs returns the "current_customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrentCustomerID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) CurrentCustomerIDs() (ids []int) {
	if id := m.current_customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentCustomer resets all changes to the "current_customer" edge.
func (m *PatientMutation) ResetCurrentCustomer() {
	m.current_customer = nil
	m.clearedcurrent_customer = false
}

// AddPatientCustomerIDs adds the "patient_customers" edge to the Customer entity by ids.
func (m *PatientMutation) AddPatientCustomerIDs(ids ...int) {
	if m.patient_customers == nil {
		m.patient_customers = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_customers[ids[i]] = struct{}{}
	}
}

// ClearPatientCustomers clears the "patient_customers" edge to the Customer entity.
func (m *PatientMutation) ClearPatientCustomers() {
	m.clearedpatient_customers = true
}

// PatientCustomersCleared reports if the "patient_customers" edge to the Customer entity was cleared.
func (m *PatientMutation) PatientCustomersCleared() bool {
	return m.clearedpatient_customers
}

// RemovePatientCustomerIDs removes the "patient_customers" edge to the Customer entity by IDs.
func (m *PatientMutation) RemovePatientCustomerIDs(ids ...int) {
	if m.removedpatient_customers == nil {
		m.removedpatient_customers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_customers, ids[i])
		m.removedpatient_customers[ids[i]] = struct{}{}
	}
}

// RemovedPatientCustomers returns the removed IDs of the "patient_customers" edge to the Customer entity.
func (m *PatientMutation) RemovedPatientCustomersIDs() (ids []int) {
	for id := range m.removedpatient_customers {
		ids = append(ids, id)
	}
	return
}

// PatientCustomersIDs returns the "patient_customers" edge IDs in the mutation.
func (m *PatientMutation) PatientCustomersIDs() (ids []int) {
	for id := range m.patient_customers {
		ids = append(ids, id)
	}
	return
}

// ResetPatientCustomers resets all changes to the "patient_customers" edge.
func (m *PatientMutation) ResetPatientCustomers() {
	m.patient_customers = nil
	m.clearedpatient_customers = false
	m.removedpatient_customers = nil
}

// AddSampleIDs adds the "samples" edge to the Sample entity by ids.
func (m *PatientMutation) AddSampleIDs(ids ...int) {
	if m.samples == nil {
		m.samples = make(map[int]struct{})
	}
	for i := range ids {
		m.samples[ids[i]] = struct{}{}
	}
}

// ClearSamples clears the "samples" edge to the Sample entity.
func (m *PatientMutation) ClearSamples() {
	m.clearedsamples = true
}

// SamplesCleared reports if the "samples" edge to the Sample entity was cleared.
func (m *PatientMutation) SamplesCleared() bool {
	return m.clearedsamples
}

// RemoveSampleIDs removes the "samples" edge to the Sample entity by IDs.
func (m *PatientMutation) RemoveSampleIDs(ids ...int) {
	if m.removedsamples == nil {
		m.removedsamples = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.samples, ids[i])
		m.removedsamples[ids[i]] = struct{}{}
	}
}

// RemovedSamples returns the removed IDs of the "samples" edge to the Sample entity.
func (m *PatientMutation) RemovedSamplesIDs() (ids []int) {
	for id := range m.removedsamples {
		ids = append(ids, id)
	}
	return
}

// SamplesIDs returns the "samples" edge IDs in the mutation.
func (m *PatientMutation) SamplesIDs() (ids []int) {
	for id := range m.samples {
		ids = append(ids, id)
	}
	return
}

// ResetSamples resets all changes to the "samples" edge.
func (m *PatientMutation) ResetSamples() {
	m.samples = nil
	m.clearedsamples = false
	m.removedsamples = nil
}

// AddPatientContactIDs adds the "patient_contacts" edge to the Contact entity by ids.
func (m *PatientMutation) AddPatientContactIDs(ids ...int) {
	if m.patient_contacts == nil {
		m.patient_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_contacts[ids[i]] = struct{}{}
	}
}

// ClearPatientContacts clears the "patient_contacts" edge to the Contact entity.
func (m *PatientMutation) ClearPatientContacts() {
	m.clearedpatient_contacts = true
}

// PatientContactsCleared reports if the "patient_contacts" edge to the Contact entity was cleared.
func (m *PatientMutation) PatientContactsCleared() bool {
	return m.clearedpatient_contacts
}

// RemovePatientContactIDs removes the "patient_contacts" edge to the Contact entity by IDs.
func (m *PatientMutation) RemovePatientContactIDs(ids ...int) {
	if m.removedpatient_contacts == nil {
		m.removedpatient_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_contacts, ids[i])
		m.removedpatient_contacts[ids[i]] = struct{}{}
	}
}

// RemovedPatientContacts returns the removed IDs of the "patient_contacts" edge to the Contact entity.
func (m *PatientMutation) RemovedPatientContactsIDs() (ids []int) {
	for id := range m.removedpatient_contacts {
		ids = append(ids, id)
	}
	return
}

// PatientContactsIDs returns the "patient_contacts" edge IDs in the mutation.
func (m *PatientMutation) PatientContactsIDs() (ids []int) {
	for id := range m.patient_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetPatientContacts resets all changes to the "patient_contacts" edge.
func (m *PatientMutation) ResetPatientContacts() {
	m.patient_contacts = nil
	m.clearedpatient_contacts = false
	m.removedpatient_contacts = nil
}

// AddPatientAddressIDs adds the "patient_addresses" edge to the Address entity by ids.
func (m *PatientMutation) AddPatientAddressIDs(ids ...int) {
	if m.patient_addresses == nil {
		m.patient_addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_addresses[ids[i]] = struct{}{}
	}
}

// ClearPatientAddresses clears the "patient_addresses" edge to the Address entity.
func (m *PatientMutation) ClearPatientAddresses() {
	m.clearedpatient_addresses = true
}

// PatientAddressesCleared reports if the "patient_addresses" edge to the Address entity was cleared.
func (m *PatientMutation) PatientAddressesCleared() bool {
	return m.clearedpatient_addresses
}

// RemovePatientAddressIDs removes the "patient_addresses" edge to the Address entity by IDs.
func (m *PatientMutation) RemovePatientAddressIDs(ids ...int) {
	if m.removedpatient_addresses == nil {
		m.removedpatient_addresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_addresses, ids[i])
		m.removedpatient_addresses[ids[i]] = struct{}{}
	}
}

// RemovedPatientAddresses returns the removed IDs of the "patient_addresses" edge to the Address entity.
func (m *PatientMutation) RemovedPatientAddressesIDs() (ids []int) {
	for id := range m.removedpatient_addresses {
		ids = append(ids, id)
	}
	return
}

// PatientAddressesIDs returns the "patient_addresses" edge IDs in the mutation.
func (m *PatientMutation) PatientAddressesIDs() (ids []int) {
	for id := range m.patient_addresses {
		ids = append(ids, id)
	}
	return
}

// ResetPatientAddresses resets all changes to the "patient_addresses" edge.
func (m *PatientMutation) ResetPatientAddresses() {
	m.patient_addresses = nil
	m.clearedpatient_addresses = false
	m.removedpatient_addresses = nil
}

// AddPatientClinicIDs adds the "patient_clinics" edge to the Clinic entity by ids.
func (m *PatientMutation) AddPatientClinicIDs(ids ...int) {
	if m.patient_clinics == nil {
		m.patient_clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_clinics[ids[i]] = struct{}{}
	}
}

// ClearPatientClinics clears the "patient_clinics" edge to the Clinic entity.
func (m *PatientMutation) ClearPatientClinics() {
	m.clearedpatient_clinics = true
}

// PatientClinicsCleared reports if the "patient_clinics" edge to the Clinic entity was cleared.
func (m *PatientMutation) PatientClinicsCleared() bool {
	return m.clearedpatient_clinics
}

// RemovePatientClinicIDs removes the "patient_clinics" edge to the Clinic entity by IDs.
func (m *PatientMutation) RemovePatientClinicIDs(ids ...int) {
	if m.removedpatient_clinics == nil {
		m.removedpatient_clinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_clinics, ids[i])
		m.removedpatient_clinics[ids[i]] = struct{}{}
	}
}

// RemovedPatientClinics returns the removed IDs of the "patient_clinics" edge to the Clinic entity.
func (m *PatientMutation) RemovedPatientClinicsIDs() (ids []int) {
	for id := range m.removedpatient_clinics {
		ids = append(ids, id)
	}
	return
}

// PatientClinicsIDs returns the "patient_clinics" edge IDs in the mutation.
func (m *PatientMutation) PatientClinicsIDs() (ids []int) {
	for id := range m.patient_clinics {
		ids = append(ids, id)
	}
	return
}

// ResetPatientClinics resets all changes to the "patient_clinics" edge.
func (m *PatientMutation) ResetPatientClinics() {
	m.patient_clinics = nil
	m.clearedpatient_clinics = false
	m.removedpatient_clinics = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PatientMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[patient.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PatientMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PatientMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPatientWeightHeightHistoryIDs adds the "patient_weight_height_history" edge to the PatientWeightHeight entity by ids.
func (m *PatientMutation) AddPatientWeightHeightHistoryIDs(ids ...int) {
	if m.patient_weight_height_history == nil {
		m.patient_weight_height_history = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_weight_height_history[ids[i]] = struct{}{}
	}
}

// ClearPatientWeightHeightHistory clears the "patient_weight_height_history" edge to the PatientWeightHeight entity.
func (m *PatientMutation) ClearPatientWeightHeightHistory() {
	m.clearedpatient_weight_height_history = true
}

// PatientWeightHeightHistoryCleared reports if the "patient_weight_height_history" edge to the PatientWeightHeight entity was cleared.
func (m *PatientMutation) PatientWeightHeightHistoryCleared() bool {
	return m.clearedpatient_weight_height_history
}

// RemovePatientWeightHeightHistoryIDs removes the "patient_weight_height_history" edge to the PatientWeightHeight entity by IDs.
func (m *PatientMutation) RemovePatientWeightHeightHistoryIDs(ids ...int) {
	if m.removedpatient_weight_height_history == nil {
		m.removedpatient_weight_height_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_weight_height_history, ids[i])
		m.removedpatient_weight_height_history[ids[i]] = struct{}{}
	}
}

// RemovedPatientWeightHeightHistory returns the removed IDs of the "patient_weight_height_history" edge to the PatientWeightHeight entity.
func (m *PatientMutation) RemovedPatientWeightHeightHistoryIDs() (ids []int) {
	for id := range m.removedpatient_weight_height_history {
		ids = append(ids, id)
	}
	return
}

// PatientWeightHeightHistoryIDs returns the "patient_weight_height_history" edge IDs in the mutation.
func (m *PatientMutation) PatientWeightHeightHistoryIDs() (ids []int) {
	for id := range m.patient_weight_height_history {
		ids = append(ids, id)
	}
	return
}

// ResetPatientWeightHeightHistory resets all changes to the "patient_weight_height_history" edge.
func (m *PatientMutation) ResetPatientWeightHeightHistory() {
	m.patient_weight_height_history = nil
	m.clearedpatient_weight_height_history = false
	m.removedpatient_weight_height_history = nil
}

// AddPatientSettingIDs adds the "patient_settings" edge to the Setting entity by ids.
func (m *PatientMutation) AddPatientSettingIDs(ids ...int) {
	if m.patient_settings == nil {
		m.patient_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_settings[ids[i]] = struct{}{}
	}
}

// ClearPatientSettings clears the "patient_settings" edge to the Setting entity.
func (m *PatientMutation) ClearPatientSettings() {
	m.clearedpatient_settings = true
}

// PatientSettingsCleared reports if the "patient_settings" edge to the Setting entity was cleared.
func (m *PatientMutation) PatientSettingsCleared() bool {
	return m.clearedpatient_settings
}

// RemovePatientSettingIDs removes the "patient_settings" edge to the Setting entity by IDs.
func (m *PatientMutation) RemovePatientSettingIDs(ids ...int) {
	if m.removedpatient_settings == nil {
		m.removedpatient_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient_settings, ids[i])
		m.removedpatient_settings[ids[i]] = struct{}{}
	}
}

// RemovedPatientSettings returns the removed IDs of the "patient_settings" edge to the Setting entity.
func (m *PatientMutation) RemovedPatientSettingsIDs() (ids []int) {
	for id := range m.removedpatient_settings {
		ids = append(ids, id)
	}
	return
}

// PatientSettingsIDs returns the "patient_settings" edge IDs in the mutation.
func (m *PatientMutation) PatientSettingsIDs() (ids []int) {
	for id := range m.patient_settings {
		ids = append(ids, id)
	}
	return
}

// ResetPatientSettings resets all changes to the "patient_settings" edge.
func (m *PatientMutation) ResetPatientSettings() {
	m.patient_settings = nil
	m.clearedpatient_settings = false
	m.removedpatient_settings = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.user != nil {
		fields = append(fields, patient.FieldUserID)
	}
	if m.patient_type != nil {
		fields = append(fields, patient.FieldPatientType)
	}
	if m.original_patient_id != nil {
		fields = append(fields, patient.FieldOriginalPatientID)
	}
	if m.patient_gender != nil {
		fields = append(fields, patient.FieldPatientGender)
	}
	if m.patient_first_name != nil {
		fields = append(fields, patient.FieldPatientFirstName)
	}
	if m.patient_last_name != nil {
		fields = append(fields, patient.FieldPatientLastName)
	}
	if m.patient_middle_name != nil {
		fields = append(fields, patient.FieldPatientMiddleName)
	}
	if m.patient_medical_record_number != nil {
		fields = append(fields, patient.FieldPatientMedicalRecordNumber)
	}
	if m.patient_legal_firstname != nil {
		fields = append(fields, patient.FieldPatientLegalFirstname)
	}
	if m.patient_legal_lastname != nil {
		fields = append(fields, patient.FieldPatientLegalLastname)
	}
	if m.patient_honorific != nil {
		fields = append(fields, patient.FieldPatientHonorific)
	}
	if m.patient_suffix != nil {
		fields = append(fields, patient.FieldPatientSuffix)
	}
	if m.patient_marital != nil {
		fields = append(fields, patient.FieldPatientMarital)
	}
	if m.patient_ethnicity != nil {
		fields = append(fields, patient.FieldPatientEthnicity)
	}
	if m.patient_birthdate != nil {
		fields = append(fields, patient.FieldPatientBirthdate)
	}
	if m.patient_ssn != nil {
		fields = append(fields, patient.FieldPatientSsn)
	}
	if m.patient_height != nil {
		fields = append(fields, patient.FieldPatientHeight)
	}
	if m.patient_weight != nil {
		fields = append(fields, patient.FieldPatientWeight)
	}
	if m.officeally_id != nil {
		fields = append(fields, patient.FieldOfficeallyID)
	}
	if m.patient_ny_waive_form_issue_status != nil {
		fields = append(fields, patient.FieldPatientNyWaiveFormIssueStatus)
	}
	if m.patient_create_time != nil {
		fields = append(fields, patient.FieldPatientCreateTime)
	}
	if m.current_customer != nil {
		fields = append(fields, patient.FieldCustomerID)
	}
	if m.isActive != nil {
		fields = append(fields, patient.FieldIsActive)
	}
	if m.patient_flagged != nil {
		fields = append(fields, patient.FieldPatientFlagged)
	}
	if m.patient_service_date != nil {
		fields = append(fields, patient.FieldPatientServiceDate)
	}
	if m.patient_description != nil {
		fields = append(fields, patient.FieldPatientDescription)
	}
	if m.patient_language != nil {
		fields = append(fields, patient.FieldPatientLanguage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldUserID:
		return m.UserID()
	case patient.FieldPatientType:
		return m.PatientType()
	case patient.FieldOriginalPatientID:
		return m.OriginalPatientID()
	case patient.FieldPatientGender:
		return m.PatientGender()
	case patient.FieldPatientFirstName:
		return m.PatientFirstName()
	case patient.FieldPatientLastName:
		return m.PatientLastName()
	case patient.FieldPatientMiddleName:
		return m.PatientMiddleName()
	case patient.FieldPatientMedicalRecordNumber:
		return m.PatientMedicalRecordNumber()
	case patient.FieldPatientLegalFirstname:
		return m.PatientLegalFirstname()
	case patient.FieldPatientLegalLastname:
		return m.PatientLegalLastname()
	case patient.FieldPatientHonorific:
		return m.PatientHonorific()
	case patient.FieldPatientSuffix:
		return m.PatientSuffix()
	case patient.FieldPatientMarital:
		return m.PatientMarital()
	case patient.FieldPatientEthnicity:
		return m.PatientEthnicity()
	case patient.FieldPatientBirthdate:
		return m.PatientBirthdate()
	case patient.FieldPatientSsn:
		return m.PatientSsn()
	case patient.FieldPatientHeight:
		return m.PatientHeight()
	case patient.FieldPatientWeight:
		return m.PatientWeight()
	case patient.FieldOfficeallyID:
		return m.OfficeallyID()
	case patient.FieldPatientNyWaiveFormIssueStatus:
		return m.PatientNyWaiveFormIssueStatus()
	case patient.FieldPatientCreateTime:
		return m.PatientCreateTime()
	case patient.FieldCustomerID:
		return m.CustomerID()
	case patient.FieldIsActive:
		return m.IsActive()
	case patient.FieldPatientFlagged:
		return m.PatientFlagged()
	case patient.FieldPatientServiceDate:
		return m.PatientServiceDate()
	case patient.FieldPatientDescription:
		return m.PatientDescription()
	case patient.FieldPatientLanguage:
		return m.PatientLanguage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldUserID:
		return m.OldUserID(ctx)
	case patient.FieldPatientType:
		return m.OldPatientType(ctx)
	case patient.FieldOriginalPatientID:
		return m.OldOriginalPatientID(ctx)
	case patient.FieldPatientGender:
		return m.OldPatientGender(ctx)
	case patient.FieldPatientFirstName:
		return m.OldPatientFirstName(ctx)
	case patient.FieldPatientLastName:
		return m.OldPatientLastName(ctx)
	case patient.FieldPatientMiddleName:
		return m.OldPatientMiddleName(ctx)
	case patient.FieldPatientMedicalRecordNumber:
		return m.OldPatientMedicalRecordNumber(ctx)
	case patient.FieldPatientLegalFirstname:
		return m.OldPatientLegalFirstname(ctx)
	case patient.FieldPatientLegalLastname:
		return m.OldPatientLegalLastname(ctx)
	case patient.FieldPatientHonorific:
		return m.OldPatientHonorific(ctx)
	case patient.FieldPatientSuffix:
		return m.OldPatientSuffix(ctx)
	case patient.FieldPatientMarital:
		return m.OldPatientMarital(ctx)
	case patient.FieldPatientEthnicity:
		return m.OldPatientEthnicity(ctx)
	case patient.FieldPatientBirthdate:
		return m.OldPatientBirthdate(ctx)
	case patient.FieldPatientSsn:
		return m.OldPatientSsn(ctx)
	case patient.FieldPatientHeight:
		return m.OldPatientHeight(ctx)
	case patient.FieldPatientWeight:
		return m.OldPatientWeight(ctx)
	case patient.FieldOfficeallyID:
		return m.OldOfficeallyID(ctx)
	case patient.FieldPatientNyWaiveFormIssueStatus:
		return m.OldPatientNyWaiveFormIssueStatus(ctx)
	case patient.FieldPatientCreateTime:
		return m.OldPatientCreateTime(ctx)
	case patient.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case patient.FieldIsActive:
		return m.OldIsActive(ctx)
	case patient.FieldPatientFlagged:
		return m.OldPatientFlagged(ctx)
	case patient.FieldPatientServiceDate:
		return m.OldPatientServiceDate(ctx)
	case patient.FieldPatientDescription:
		return m.OldPatientDescription(ctx)
	case patient.FieldPatientLanguage:
		return m.OldPatientLanguage(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case patient.FieldPatientType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientType(v)
		return nil
	case patient.FieldOriginalPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalPatientID(v)
		return nil
	case patient.FieldPatientGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientGender(v)
		return nil
	case patient.FieldPatientFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFirstName(v)
		return nil
	case patient.FieldPatientLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientLastName(v)
		return nil
	case patient.FieldPatientMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientMiddleName(v)
		return nil
	case patient.FieldPatientMedicalRecordNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientMedicalRecordNumber(v)
		return nil
	case patient.FieldPatientLegalFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientLegalFirstname(v)
		return nil
	case patient.FieldPatientLegalLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientLegalLastname(v)
		return nil
	case patient.FieldPatientHonorific:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientHonorific(v)
		return nil
	case patient.FieldPatientSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientSuffix(v)
		return nil
	case patient.FieldPatientMarital:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientMarital(v)
		return nil
	case patient.FieldPatientEthnicity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientEthnicity(v)
		return nil
	case patient.FieldPatientBirthdate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientBirthdate(v)
		return nil
	case patient.FieldPatientSsn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientSsn(v)
		return nil
	case patient.FieldPatientHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientHeight(v)
		return nil
	case patient.FieldPatientWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientWeight(v)
		return nil
	case patient.FieldOfficeallyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeallyID(v)
		return nil
	case patient.FieldPatientNyWaiveFormIssueStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientNyWaiveFormIssueStatus(v)
		return nil
	case patient.FieldPatientCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientCreateTime(v)
		return nil
	case patient.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case patient.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case patient.FieldPatientFlagged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagged(v)
		return nil
	case patient.FieldPatientServiceDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientServiceDate(v)
		return nil
	case patient.FieldPatientDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientDescription(v)
		return nil
	case patient.FieldPatientLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientLanguage(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addoriginal_patient_id != nil {
		fields = append(fields, patient.FieldOriginalPatientID)
	}
	if m.addofficeally_id != nil {
		fields = append(fields, patient.FieldOfficeallyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldOriginalPatientID:
		return m.AddedOriginalPatientID()
	case patient.FieldOfficeallyID:
		return m.AddedOfficeallyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldOriginalPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalPatientID(v)
		return nil
	case patient.FieldOfficeallyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfficeallyID(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patient.FieldUserID) {
		fields = append(fields, patient.FieldUserID)
	}
	if m.FieldCleared(patient.FieldOriginalPatientID) {
		fields = append(fields, patient.FieldOriginalPatientID)
	}
	if m.FieldCleared(patient.FieldPatientGender) {
		fields = append(fields, patient.FieldPatientGender)
	}
	if m.FieldCleared(patient.FieldPatientFirstName) {
		fields = append(fields, patient.FieldPatientFirstName)
	}
	if m.FieldCleared(patient.FieldPatientLastName) {
		fields = append(fields, patient.FieldPatientLastName)
	}
	if m.FieldCleared(patient.FieldPatientMiddleName) {
		fields = append(fields, patient.FieldPatientMiddleName)
	}
	if m.FieldCleared(patient.FieldPatientMedicalRecordNumber) {
		fields = append(fields, patient.FieldPatientMedicalRecordNumber)
	}
	if m.FieldCleared(patient.FieldPatientLegalFirstname) {
		fields = append(fields, patient.FieldPatientLegalFirstname)
	}
	if m.FieldCleared(patient.FieldPatientLegalLastname) {
		fields = append(fields, patient.FieldPatientLegalLastname)
	}
	if m.FieldCleared(patient.FieldPatientHonorific) {
		fields = append(fields, patient.FieldPatientHonorific)
	}
	if m.FieldCleared(patient.FieldPatientSuffix) {
		fields = append(fields, patient.FieldPatientSuffix)
	}
	if m.FieldCleared(patient.FieldPatientMarital) {
		fields = append(fields, patient.FieldPatientMarital)
	}
	if m.FieldCleared(patient.FieldPatientEthnicity) {
		fields = append(fields, patient.FieldPatientEthnicity)
	}
	if m.FieldCleared(patient.FieldPatientBirthdate) {
		fields = append(fields, patient.FieldPatientBirthdate)
	}
	if m.FieldCleared(patient.FieldPatientSsn) {
		fields = append(fields, patient.FieldPatientSsn)
	}
	if m.FieldCleared(patient.FieldPatientHeight) {
		fields = append(fields, patient.FieldPatientHeight)
	}
	if m.FieldCleared(patient.FieldPatientWeight) {
		fields = append(fields, patient.FieldPatientWeight)
	}
	if m.FieldCleared(patient.FieldOfficeallyID) {
		fields = append(fields, patient.FieldOfficeallyID)
	}
	if m.FieldCleared(patient.FieldPatientCreateTime) {
		fields = append(fields, patient.FieldPatientCreateTime)
	}
	if m.FieldCleared(patient.FieldCustomerID) {
		fields = append(fields, patient.FieldCustomerID)
	}
	if m.FieldCleared(patient.FieldPatientServiceDate) {
		fields = append(fields, patient.FieldPatientServiceDate)
	}
	if m.FieldCleared(patient.FieldPatientDescription) {
		fields = append(fields, patient.FieldPatientDescription)
	}
	if m.FieldCleared(patient.FieldPatientLanguage) {
		fields = append(fields, patient.FieldPatientLanguage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	switch name {
	case patient.FieldUserID:
		m.ClearUserID()
		return nil
	case patient.FieldOriginalPatientID:
		m.ClearOriginalPatientID()
		return nil
	case patient.FieldPatientGender:
		m.ClearPatientGender()
		return nil
	case patient.FieldPatientFirstName:
		m.ClearPatientFirstName()
		return nil
	case patient.FieldPatientLastName:
		m.ClearPatientLastName()
		return nil
	case patient.FieldPatientMiddleName:
		m.ClearPatientMiddleName()
		return nil
	case patient.FieldPatientMedicalRecordNumber:
		m.ClearPatientMedicalRecordNumber()
		return nil
	case patient.FieldPatientLegalFirstname:
		m.ClearPatientLegalFirstname()
		return nil
	case patient.FieldPatientLegalLastname:
		m.ClearPatientLegalLastname()
		return nil
	case patient.FieldPatientHonorific:
		m.ClearPatientHonorific()
		return nil
	case patient.FieldPatientSuffix:
		m.ClearPatientSuffix()
		return nil
	case patient.FieldPatientMarital:
		m.ClearPatientMarital()
		return nil
	case patient.FieldPatientEthnicity:
		m.ClearPatientEthnicity()
		return nil
	case patient.FieldPatientBirthdate:
		m.ClearPatientBirthdate()
		return nil
	case patient.FieldPatientSsn:
		m.ClearPatientSsn()
		return nil
	case patient.FieldPatientHeight:
		m.ClearPatientHeight()
		return nil
	case patient.FieldPatientWeight:
		m.ClearPatientWeight()
		return nil
	case patient.FieldOfficeallyID:
		m.ClearOfficeallyID()
		return nil
	case patient.FieldPatientCreateTime:
		m.ClearPatientCreateTime()
		return nil
	case patient.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case patient.FieldPatientServiceDate:
		m.ClearPatientServiceDate()
		return nil
	case patient.FieldPatientDescription:
		m.ClearPatientDescription()
		return nil
	case patient.FieldPatientLanguage:
		m.ClearPatientLanguage()
		return nil
	}
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldUserID:
		m.ResetUserID()
		return nil
	case patient.FieldPatientType:
		m.ResetPatientType()
		return nil
	case patient.FieldOriginalPatientID:
		m.ResetOriginalPatientID()
		return nil
	case patient.FieldPatientGender:
		m.ResetPatientGender()
		return nil
	case patient.FieldPatientFirstName:
		m.ResetPatientFirstName()
		return nil
	case patient.FieldPatientLastName:
		m.ResetPatientLastName()
		return nil
	case patient.FieldPatientMiddleName:
		m.ResetPatientMiddleName()
		return nil
	case patient.FieldPatientMedicalRecordNumber:
		m.ResetPatientMedicalRecordNumber()
		return nil
	case patient.FieldPatientLegalFirstname:
		m.ResetPatientLegalFirstname()
		return nil
	case patient.FieldPatientLegalLastname:
		m.ResetPatientLegalLastname()
		return nil
	case patient.FieldPatientHonorific:
		m.ResetPatientHonorific()
		return nil
	case patient.FieldPatientSuffix:
		m.ResetPatientSuffix()
		return nil
	case patient.FieldPatientMarital:
		m.ResetPatientMarital()
		return nil
	case patient.FieldPatientEthnicity:
		m.ResetPatientEthnicity()
		return nil
	case patient.FieldPatientBirthdate:
		m.ResetPatientBirthdate()
		return nil
	case patient.FieldPatientSsn:
		m.ResetPatientSsn()
		return nil
	case patient.FieldPatientHeight:
		m.ResetPatientHeight()
		return nil
	case patient.FieldPatientWeight:
		m.ResetPatientWeight()
		return nil
	case patient.FieldOfficeallyID:
		m.ResetOfficeallyID()
		return nil
	case patient.FieldPatientNyWaiveFormIssueStatus:
		m.ResetPatientNyWaiveFormIssueStatus()
		return nil
	case patient.FieldPatientCreateTime:
		m.ResetPatientCreateTime()
		return nil
	case patient.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case patient.FieldIsActive:
		m.ResetIsActive()
		return nil
	case patient.FieldPatientFlagged:
		m.ResetPatientFlagged()
		return nil
	case patient.FieldPatientServiceDate:
		m.ResetPatientServiceDate()
		return nil
	case patient.FieldPatientDescription:
		m.ResetPatientDescription()
		return nil
	case patient.FieldPatientLanguage:
		m.ResetPatientLanguage()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.current_customer != nil {
		edges = append(edges, patient.EdgeCurrentCustomer)
	}
	if m.patient_customers != nil {
		edges = append(edges, patient.EdgePatientCustomers)
	}
	if m.samples != nil {
		edges = append(edges, patient.EdgeSamples)
	}
	if m.patient_contacts != nil {
		edges = append(edges, patient.EdgePatientContacts)
	}
	if m.patient_addresses != nil {
		edges = append(edges, patient.EdgePatientAddresses)
	}
	if m.patient_clinics != nil {
		edges = append(edges, patient.EdgePatientClinics)
	}
	if m.user != nil {
		edges = append(edges, patient.EdgeUser)
	}
	if m.patient_weight_height_history != nil {
		edges = append(edges, patient.EdgePatientWeightHeightHistory)
	}
	if m.patient_settings != nil {
		edges = append(edges, patient.EdgePatientSettings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeCurrentCustomer:
		if id := m.current_customer; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePatientCustomers:
		ids := make([]ent.Value, 0, len(m.patient_customers))
		for id := range m.patient_customers {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeSamples:
		ids := make([]ent.Value, 0, len(m.samples))
		for id := range m.samples {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientContacts:
		ids := make([]ent.Value, 0, len(m.patient_contacts))
		for id := range m.patient_contacts {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientAddresses:
		ids := make([]ent.Value, 0, len(m.patient_addresses))
		for id := range m.patient_addresses {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientClinics:
		ids := make([]ent.Value, 0, len(m.patient_clinics))
		for id := range m.patient_clinics {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePatientWeightHeightHistory:
		ids := make([]ent.Value, 0, len(m.patient_weight_height_history))
		for id := range m.patient_weight_height_history {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientSettings:
		ids := make([]ent.Value, 0, len(m.patient_settings))
		for id := range m.patient_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedpatient_customers != nil {
		edges = append(edges, patient.EdgePatientCustomers)
	}
	if m.removedsamples != nil {
		edges = append(edges, patient.EdgeSamples)
	}
	if m.removedpatient_contacts != nil {
		edges = append(edges, patient.EdgePatientContacts)
	}
	if m.removedpatient_addresses != nil {
		edges = append(edges, patient.EdgePatientAddresses)
	}
	if m.removedpatient_clinics != nil {
		edges = append(edges, patient.EdgePatientClinics)
	}
	if m.removedpatient_weight_height_history != nil {
		edges = append(edges, patient.EdgePatientWeightHeightHistory)
	}
	if m.removedpatient_settings != nil {
		edges = append(edges, patient.EdgePatientSettings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePatientCustomers:
		ids := make([]ent.Value, 0, len(m.removedpatient_customers))
		for id := range m.removedpatient_customers {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeSamples:
		ids := make([]ent.Value, 0, len(m.removedsamples))
		for id := range m.removedsamples {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientContacts:
		ids := make([]ent.Value, 0, len(m.removedpatient_contacts))
		for id := range m.removedpatient_contacts {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientAddresses:
		ids := make([]ent.Value, 0, len(m.removedpatient_addresses))
		for id := range m.removedpatient_addresses {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientClinics:
		ids := make([]ent.Value, 0, len(m.removedpatient_clinics))
		for id := range m.removedpatient_clinics {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientWeightHeightHistory:
		ids := make([]ent.Value, 0, len(m.removedpatient_weight_height_history))
		for id := range m.removedpatient_weight_height_history {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientSettings:
		ids := make([]ent.Value, 0, len(m.removedpatient_settings))
		for id := range m.removedpatient_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcurrent_customer {
		edges = append(edges, patient.EdgeCurrentCustomer)
	}
	if m.clearedpatient_customers {
		edges = append(edges, patient.EdgePatientCustomers)
	}
	if m.clearedsamples {
		edges = append(edges, patient.EdgeSamples)
	}
	if m.clearedpatient_contacts {
		edges = append(edges, patient.EdgePatientContacts)
	}
	if m.clearedpatient_addresses {
		edges = append(edges, patient.EdgePatientAddresses)
	}
	if m.clearedpatient_clinics {
		edges = append(edges, patient.EdgePatientClinics)
	}
	if m.cleareduser {
		edges = append(edges, patient.EdgeUser)
	}
	if m.clearedpatient_weight_height_history {
		edges = append(edges, patient.EdgePatientWeightHeightHistory)
	}
	if m.clearedpatient_settings {
		edges = append(edges, patient.EdgePatientSettings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeCurrentCustomer:
		return m.clearedcurrent_customer
	case patient.EdgePatientCustomers:
		return m.clearedpatient_customers
	case patient.EdgeSamples:
		return m.clearedsamples
	case patient.EdgePatientContacts:
		return m.clearedpatient_contacts
	case patient.EdgePatientAddresses:
		return m.clearedpatient_addresses
	case patient.EdgePatientClinics:
		return m.clearedpatient_clinics
	case patient.EdgeUser:
		return m.cleareduser
	case patient.EdgePatientWeightHeightHistory:
		return m.clearedpatient_weight_height_history
	case patient.EdgePatientSettings:
		return m.clearedpatient_settings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgeCurrentCustomer:
		m.ClearCurrentCustomer()
		return nil
	case patient.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeCurrentCustomer:
		m.ResetCurrentCustomer()
		return nil
	case patient.EdgePatientCustomers:
		m.ResetPatientCustomers()
		return nil
	case patient.EdgeSamples:
		m.ResetSamples()
		return nil
	case patient.EdgePatientContacts:
		m.ResetPatientContacts()
		return nil
	case patient.EdgePatientAddresses:
		m.ResetPatientAddresses()
		return nil
	case patient.EdgePatientClinics:
		m.ResetPatientClinics()
		return nil
	case patient.EdgeUser:
		m.ResetUser()
		return nil
	case patient.EdgePatientWeightHeightHistory:
		m.ResetPatientWeightHeightHistory()
		return nil
	case patient.EdgePatientSettings:
		m.ResetPatientSettings()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PatientFlagMutation represents an operation that mutates the PatientFlag nodes in the graph.
type PatientFlagMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	patient_flag_name         *string
	patient_flag_display_name *string
	patient_flag_description  *string
	patient_flag_is_active    *bool
	patient_flag_created_at   *time.Time
	patient_flag_color        *string
	patient_flaged_by         *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*PatientFlag, error)
	predicates                []predicate.PatientFlag
}

var _ ent.Mutation = (*PatientFlagMutation)(nil)

// patientflagOption allows management of the mutation configuration using functional options.
type patientflagOption func(*PatientFlagMutation)

// newPatientFlagMutation creates new mutation for the PatientFlag entity.
func newPatientFlagMutation(c config, op Op, opts ...patientflagOption) *PatientFlagMutation {
	m := &PatientFlagMutation{
		config:        c,
		op:            op,
		typ:           TypePatientFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientFlagID sets the ID field of the mutation.
func withPatientFlagID(id int) patientflagOption {
	return func(m *PatientFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientFlag
		)
		m.oldValue = func(ctx context.Context) (*PatientFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientFlag sets the old PatientFlag of the mutation.
func withPatientFlag(node *PatientFlag) patientflagOption {
	return func(m *PatientFlagMutation) {
		m.oldValue = func(context.Context) (*PatientFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PatientFlag entities.
func (m *PatientFlagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientFlagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientFlagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPatientFlagName sets the "patient_flag_name" field.
func (m *PatientFlagMutation) SetPatientFlagName(s string) {
	m.patient_flag_name = &s
}

// PatientFlagName returns the value of the "patient_flag_name" field in the mutation.
func (m *PatientFlagMutation) PatientFlagName() (r string, exists bool) {
	v := m.patient_flag_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagName returns the old "patient_flag_name" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagName: %w", err)
	}
	return oldValue.PatientFlagName, nil
}

// ResetPatientFlagName resets all changes to the "patient_flag_name" field.
func (m *PatientFlagMutation) ResetPatientFlagName() {
	m.patient_flag_name = nil
}

// SetPatientFlagDisplayName sets the "patient_flag_display_name" field.
func (m *PatientFlagMutation) SetPatientFlagDisplayName(s string) {
	m.patient_flag_display_name = &s
}

// PatientFlagDisplayName returns the value of the "patient_flag_display_name" field in the mutation.
func (m *PatientFlagMutation) PatientFlagDisplayName() (r string, exists bool) {
	v := m.patient_flag_display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagDisplayName returns the old "patient_flag_display_name" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagDisplayName: %w", err)
	}
	return oldValue.PatientFlagDisplayName, nil
}

// ClearPatientFlagDisplayName clears the value of the "patient_flag_display_name" field.
func (m *PatientFlagMutation) ClearPatientFlagDisplayName() {
	m.patient_flag_display_name = nil
	m.clearedFields[patientflag.FieldPatientFlagDisplayName] = struct{}{}
}

// PatientFlagDisplayNameCleared returns if the "patient_flag_display_name" field was cleared in this mutation.
func (m *PatientFlagMutation) PatientFlagDisplayNameCleared() bool {
	_, ok := m.clearedFields[patientflag.FieldPatientFlagDisplayName]
	return ok
}

// ResetPatientFlagDisplayName resets all changes to the "patient_flag_display_name" field.
func (m *PatientFlagMutation) ResetPatientFlagDisplayName() {
	m.patient_flag_display_name = nil
	delete(m.clearedFields, patientflag.FieldPatientFlagDisplayName)
}

// SetPatientFlagDescription sets the "patient_flag_description" field.
func (m *PatientFlagMutation) SetPatientFlagDescription(s string) {
	m.patient_flag_description = &s
}

// PatientFlagDescription returns the value of the "patient_flag_description" field in the mutation.
func (m *PatientFlagMutation) PatientFlagDescription() (r string, exists bool) {
	v := m.patient_flag_description
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagDescription returns the old "patient_flag_description" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagDescription: %w", err)
	}
	return oldValue.PatientFlagDescription, nil
}

// ClearPatientFlagDescription clears the value of the "patient_flag_description" field.
func (m *PatientFlagMutation) ClearPatientFlagDescription() {
	m.patient_flag_description = nil
	m.clearedFields[patientflag.FieldPatientFlagDescription] = struct{}{}
}

// PatientFlagDescriptionCleared returns if the "patient_flag_description" field was cleared in this mutation.
func (m *PatientFlagMutation) PatientFlagDescriptionCleared() bool {
	_, ok := m.clearedFields[patientflag.FieldPatientFlagDescription]
	return ok
}

// ResetPatientFlagDescription resets all changes to the "patient_flag_description" field.
func (m *PatientFlagMutation) ResetPatientFlagDescription() {
	m.patient_flag_description = nil
	delete(m.clearedFields, patientflag.FieldPatientFlagDescription)
}

// SetPatientFlagIsActive sets the "patient_flag_is_active" field.
func (m *PatientFlagMutation) SetPatientFlagIsActive(b bool) {
	m.patient_flag_is_active = &b
}

// PatientFlagIsActive returns the value of the "patient_flag_is_active" field in the mutation.
func (m *PatientFlagMutation) PatientFlagIsActive() (r bool, exists bool) {
	v := m.patient_flag_is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagIsActive returns the old "patient_flag_is_active" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagIsActive: %w", err)
	}
	return oldValue.PatientFlagIsActive, nil
}

// ResetPatientFlagIsActive resets all changes to the "patient_flag_is_active" field.
func (m *PatientFlagMutation) ResetPatientFlagIsActive() {
	m.patient_flag_is_active = nil
}

// SetPatientFlagCreatedAt sets the "patient_flag_created_at" field.
func (m *PatientFlagMutation) SetPatientFlagCreatedAt(t time.Time) {
	m.patient_flag_created_at = &t
}

// PatientFlagCreatedAt returns the value of the "patient_flag_created_at" field in the mutation.
func (m *PatientFlagMutation) PatientFlagCreatedAt() (r time.Time, exists bool) {
	v := m.patient_flag_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagCreatedAt returns the old "patient_flag_created_at" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagCreatedAt: %w", err)
	}
	return oldValue.PatientFlagCreatedAt, nil
}

// ResetPatientFlagCreatedAt resets all changes to the "patient_flag_created_at" field.
func (m *PatientFlagMutation) ResetPatientFlagCreatedAt() {
	m.patient_flag_created_at = nil
}

// SetPatientFlagColor sets the "patient_flag_color" field.
func (m *PatientFlagMutation) SetPatientFlagColor(s string) {
	m.patient_flag_color = &s
}

// PatientFlagColor returns the value of the "patient_flag_color" field in the mutation.
func (m *PatientFlagMutation) PatientFlagColor() (r string, exists bool) {
	v := m.patient_flag_color
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagColor returns the old "patient_flag_color" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagColor: %w", err)
	}
	return oldValue.PatientFlagColor, nil
}

// ClearPatientFlagColor clears the value of the "patient_flag_color" field.
func (m *PatientFlagMutation) ClearPatientFlagColor() {
	m.patient_flag_color = nil
	m.clearedFields[patientflag.FieldPatientFlagColor] = struct{}{}
}

// PatientFlagColorCleared returns if the "patient_flag_color" field was cleared in this mutation.
func (m *PatientFlagMutation) PatientFlagColorCleared() bool {
	_, ok := m.clearedFields[patientflag.FieldPatientFlagColor]
	return ok
}

// ResetPatientFlagColor resets all changes to the "patient_flag_color" field.
func (m *PatientFlagMutation) ResetPatientFlagColor() {
	m.patient_flag_color = nil
	delete(m.clearedFields, patientflag.FieldPatientFlagColor)
}

// SetPatientFlagedBy sets the "patient_flaged_by" field.
func (m *PatientFlagMutation) SetPatientFlagedBy(s string) {
	m.patient_flaged_by = &s
}

// PatientFlagedBy returns the value of the "patient_flaged_by" field in the mutation.
func (m *PatientFlagMutation) PatientFlagedBy() (r string, exists bool) {
	v := m.patient_flaged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientFlagedBy returns the old "patient_flaged_by" field's value of the PatientFlag entity.
// If the PatientFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFlagMutation) OldPatientFlagedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientFlagedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientFlagedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientFlagedBy: %w", err)
	}
	return oldValue.PatientFlagedBy, nil
}

// ResetPatientFlagedBy resets all changes to the "patient_flaged_by" field.
func (m *PatientFlagMutation) ResetPatientFlagedBy() {
	m.patient_flaged_by = nil
}

// Where appends a list predicates to the PatientFlagMutation builder.
func (m *PatientFlagMutation) Where(ps ...predicate.PatientFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientFlag).
func (m *PatientFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientFlagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.patient_flag_name != nil {
		fields = append(fields, patientflag.FieldPatientFlagName)
	}
	if m.patient_flag_display_name != nil {
		fields = append(fields, patientflag.FieldPatientFlagDisplayName)
	}
	if m.patient_flag_description != nil {
		fields = append(fields, patientflag.FieldPatientFlagDescription)
	}
	if m.patient_flag_is_active != nil {
		fields = append(fields, patientflag.FieldPatientFlagIsActive)
	}
	if m.patient_flag_created_at != nil {
		fields = append(fields, patientflag.FieldPatientFlagCreatedAt)
	}
	if m.patient_flag_color != nil {
		fields = append(fields, patientflag.FieldPatientFlagColor)
	}
	if m.patient_flaged_by != nil {
		fields = append(fields, patientflag.FieldPatientFlagedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientflag.FieldPatientFlagName:
		return m.PatientFlagName()
	case patientflag.FieldPatientFlagDisplayName:
		return m.PatientFlagDisplayName()
	case patientflag.FieldPatientFlagDescription:
		return m.PatientFlagDescription()
	case patientflag.FieldPatientFlagIsActive:
		return m.PatientFlagIsActive()
	case patientflag.FieldPatientFlagCreatedAt:
		return m.PatientFlagCreatedAt()
	case patientflag.FieldPatientFlagColor:
		return m.PatientFlagColor()
	case patientflag.FieldPatientFlagedBy:
		return m.PatientFlagedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientflag.FieldPatientFlagName:
		return m.OldPatientFlagName(ctx)
	case patientflag.FieldPatientFlagDisplayName:
		return m.OldPatientFlagDisplayName(ctx)
	case patientflag.FieldPatientFlagDescription:
		return m.OldPatientFlagDescription(ctx)
	case patientflag.FieldPatientFlagIsActive:
		return m.OldPatientFlagIsActive(ctx)
	case patientflag.FieldPatientFlagCreatedAt:
		return m.OldPatientFlagCreatedAt(ctx)
	case patientflag.FieldPatientFlagColor:
		return m.OldPatientFlagColor(ctx)
	case patientflag.FieldPatientFlagedBy:
		return m.OldPatientFlagedBy(ctx)
	}
	return nil, fmt.Errorf("unknown PatientFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientflag.FieldPatientFlagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagName(v)
		return nil
	case patientflag.FieldPatientFlagDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagDisplayName(v)
		return nil
	case patientflag.FieldPatientFlagDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagDescription(v)
		return nil
	case patientflag.FieldPatientFlagIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagIsActive(v)
		return nil
	case patientflag.FieldPatientFlagCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagCreatedAt(v)
		return nil
	case patientflag.FieldPatientFlagColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagColor(v)
		return nil
	case patientflag.FieldPatientFlagedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientFlagedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PatientFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientFlagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientFlagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patientflag.FieldPatientFlagDisplayName) {
		fields = append(fields, patientflag.FieldPatientFlagDisplayName)
	}
	if m.FieldCleared(patientflag.FieldPatientFlagDescription) {
		fields = append(fields, patientflag.FieldPatientFlagDescription)
	}
	if m.FieldCleared(patientflag.FieldPatientFlagColor) {
		fields = append(fields, patientflag.FieldPatientFlagColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientFlagMutation) ClearField(name string) error {
	switch name {
	case patientflag.FieldPatientFlagDisplayName:
		m.ClearPatientFlagDisplayName()
		return nil
	case patientflag.FieldPatientFlagDescription:
		m.ClearPatientFlagDescription()
		return nil
	case patientflag.FieldPatientFlagColor:
		m.ClearPatientFlagColor()
		return nil
	}
	return fmt.Errorf("unknown PatientFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientFlagMutation) ResetField(name string) error {
	switch name {
	case patientflag.FieldPatientFlagName:
		m.ResetPatientFlagName()
		return nil
	case patientflag.FieldPatientFlagDisplayName:
		m.ResetPatientFlagDisplayName()
		return nil
	case patientflag.FieldPatientFlagDescription:
		m.ResetPatientFlagDescription()
		return nil
	case patientflag.FieldPatientFlagIsActive:
		m.ResetPatientFlagIsActive()
		return nil
	case patientflag.FieldPatientFlagCreatedAt:
		m.ResetPatientFlagCreatedAt()
		return nil
	case patientflag.FieldPatientFlagColor:
		m.ResetPatientFlagColor()
		return nil
	case patientflag.FieldPatientFlagedBy:
		m.ResetPatientFlagedBy()
		return nil
	}
	return fmt.Errorf("unknown PatientFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientFlagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientFlagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientFlagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientFlagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PatientFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientFlagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PatientFlag edge %s", name)
}

// PatientWeightHeightMutation represents an operation that mutates the PatientWeightHeight nodes in the graph.
type PatientWeightHeightMutation struct {
	config
	op             Op
	typ            string
	id             *int
	weight         *string
	height         *string
	weight_unit    *string
	height_unit    *string
	created_time   *time.Time
	updated_time   *time.Time
	clearedFields  map[string]struct{}
	patient        *int
	clearedpatient bool
	done           bool
	oldValue       func(context.Context) (*PatientWeightHeight, error)
	predicates     []predicate.PatientWeightHeight
}

var _ ent.Mutation = (*PatientWeightHeightMutation)(nil)

// patientweightheightOption allows management of the mutation configuration using functional options.
type patientweightheightOption func(*PatientWeightHeightMutation)

// newPatientWeightHeightMutation creates new mutation for the PatientWeightHeight entity.
func newPatientWeightHeightMutation(c config, op Op, opts ...patientweightheightOption) *PatientWeightHeightMutation {
	m := &PatientWeightHeightMutation{
		config:        c,
		op:            op,
		typ:           TypePatientWeightHeight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientWeightHeightID sets the ID field of the mutation.
func withPatientWeightHeightID(id int) patientweightheightOption {
	return func(m *PatientWeightHeightMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientWeightHeight
		)
		m.oldValue = func(ctx context.Context) (*PatientWeightHeight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientWeightHeight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientWeightHeight sets the old PatientWeightHeight of the mutation.
func withPatientWeightHeight(node *PatientWeightHeight) patientweightheightOption {
	return func(m *PatientWeightHeightMutation) {
		m.oldValue = func(context.Context) (*PatientWeightHeight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientWeightHeightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientWeightHeightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientWeightHeightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientWeightHeightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientWeightHeight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPatientID sets the "patient_id" field.
func (m *PatientWeightHeightMutation) SetPatientID(i int) {
	m.patient = &i
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *PatientWeightHeightMutation) PatientID() (r int, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldPatientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *PatientWeightHeightMutation) ResetPatientID() {
	m.patient = nil
}

// SetWeight sets the "weight" field.
func (m *PatientWeightHeightMutation) SetWeight(s string) {
	m.weight = &s
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PatientWeightHeightMutation) Weight() (r string, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// ResetWeight resets all changes to the "weight" field.
func (m *PatientWeightHeightMutation) ResetWeight() {
	m.weight = nil
}

// SetHeight sets the "height" field.
func (m *PatientWeightHeightMutation) SetHeight(s string) {
	m.height = &s
}

// Height returns the value of the "height" field in the mutation.
func (m *PatientWeightHeightMutation) Height() (r string, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// ResetHeight resets all changes to the "height" field.
func (m *PatientWeightHeightMutation) ResetHeight() {
	m.height = nil
}

// SetWeightUnit sets the "weight_unit" field.
func (m *PatientWeightHeightMutation) SetWeightUnit(s string) {
	m.weight_unit = &s
}

// WeightUnit returns the value of the "weight_unit" field in the mutation.
func (m *PatientWeightHeightMutation) WeightUnit() (r string, exists bool) {
	v := m.weight_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightUnit returns the old "weight_unit" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldWeightUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightUnit: %w", err)
	}
	return oldValue.WeightUnit, nil
}

// ResetWeightUnit resets all changes to the "weight_unit" field.
func (m *PatientWeightHeightMutation) ResetWeightUnit() {
	m.weight_unit = nil
}

// SetHeightUnit sets the "height_unit" field.
func (m *PatientWeightHeightMutation) SetHeightUnit(s string) {
	m.height_unit = &s
}

// HeightUnit returns the value of the "height_unit" field in the mutation.
func (m *PatientWeightHeightMutation) HeightUnit() (r string, exists bool) {
	v := m.height_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldHeightUnit returns the old "height_unit" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldHeightUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeightUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeightUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeightUnit: %w", err)
	}
	return oldValue.HeightUnit, nil
}

// ResetHeightUnit resets all changes to the "height_unit" field.
func (m *PatientWeightHeightMutation) ResetHeightUnit() {
	m.height_unit = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *PatientWeightHeightMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *PatientWeightHeightMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *PatientWeightHeightMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *PatientWeightHeightMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *PatientWeightHeightMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the PatientWeightHeight entity.
// If the PatientWeightHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientWeightHeightMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *PatientWeightHeightMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[patientweightheight.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *PatientWeightHeightMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[patientweightheight.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *PatientWeightHeightMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, patientweightheight.FieldUpdatedTime)
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *PatientWeightHeightMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[patientweightheight.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *PatientWeightHeightMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PatientWeightHeightMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *PatientWeightHeightMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// Where appends a list predicates to the PatientWeightHeightMutation builder.
func (m *PatientWeightHeightMutation) Where(ps ...predicate.PatientWeightHeight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientWeightHeightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientWeightHeightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientWeightHeight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientWeightHeightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientWeightHeightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientWeightHeight).
func (m *PatientWeightHeightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientWeightHeightMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.patient != nil {
		fields = append(fields, patientweightheight.FieldPatientID)
	}
	if m.weight != nil {
		fields = append(fields, patientweightheight.FieldWeight)
	}
	if m.height != nil {
		fields = append(fields, patientweightheight.FieldHeight)
	}
	if m.weight_unit != nil {
		fields = append(fields, patientweightheight.FieldWeightUnit)
	}
	if m.height_unit != nil {
		fields = append(fields, patientweightheight.FieldHeightUnit)
	}
	if m.created_time != nil {
		fields = append(fields, patientweightheight.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, patientweightheight.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientWeightHeightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientweightheight.FieldPatientID:
		return m.PatientID()
	case patientweightheight.FieldWeight:
		return m.Weight()
	case patientweightheight.FieldHeight:
		return m.Height()
	case patientweightheight.FieldWeightUnit:
		return m.WeightUnit()
	case patientweightheight.FieldHeightUnit:
		return m.HeightUnit()
	case patientweightheight.FieldCreatedTime:
		return m.CreatedTime()
	case patientweightheight.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientWeightHeightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientweightheight.FieldPatientID:
		return m.OldPatientID(ctx)
	case patientweightheight.FieldWeight:
		return m.OldWeight(ctx)
	case patientweightheight.FieldHeight:
		return m.OldHeight(ctx)
	case patientweightheight.FieldWeightUnit:
		return m.OldWeightUnit(ctx)
	case patientweightheight.FieldHeightUnit:
		return m.OldHeightUnit(ctx)
	case patientweightheight.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case patientweightheight.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown PatientWeightHeight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientWeightHeightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientweightheight.FieldPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case patientweightheight.FieldWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case patientweightheight.FieldHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case patientweightheight.FieldWeightUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightUnit(v)
		return nil
	case patientweightheight.FieldHeightUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeightUnit(v)
		return nil
	case patientweightheight.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case patientweightheight.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown PatientWeightHeight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientWeightHeightMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientWeightHeightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientWeightHeightMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientWeightHeight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientWeightHeightMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patientweightheight.FieldUpdatedTime) {
		fields = append(fields, patientweightheight.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientWeightHeightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientWeightHeightMutation) ClearField(name string) error {
	switch name {
	case patientweightheight.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown PatientWeightHeight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientWeightHeightMutation) ResetField(name string) error {
	switch name {
	case patientweightheight.FieldPatientID:
		m.ResetPatientID()
		return nil
	case patientweightheight.FieldWeight:
		m.ResetWeight()
		return nil
	case patientweightheight.FieldHeight:
		m.ResetHeight()
		return nil
	case patientweightheight.FieldWeightUnit:
		m.ResetWeightUnit()
		return nil
	case patientweightheight.FieldHeightUnit:
		m.ResetHeightUnit()
		return nil
	case patientweightheight.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case patientweightheight.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown PatientWeightHeight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientWeightHeightMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.patient != nil {
		edges = append(edges, patientweightheight.EdgePatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientWeightHeightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientweightheight.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientWeightHeightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientWeightHeightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientWeightHeightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpatient {
		edges = append(edges, patientweightheight.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientWeightHeightMutation) EdgeCleared(name string) bool {
	switch name {
	case patientweightheight.EdgePatient:
		return m.clearedpatient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientWeightHeightMutation) ClearEdge(name string) error {
	switch name {
	case patientweightheight.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown PatientWeightHeight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientWeightHeightMutation) ResetEdge(name string) error {
	switch name {
	case patientweightheight.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown PatientWeightHeight edge %s", name)
}

// PendingOrderCreditsMutation represents an operation that mutates the PendingOrderCredits nodes in the graph.
type PendingOrderCreditsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	order_id      *int64
	addorder_id   *int64
	credit_id     *int64
	addcredit_id  *int64
	clinic_id     *int64
	addclinic_id  *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PendingOrderCredits, error)
	predicates    []predicate.PendingOrderCredits
}

var _ ent.Mutation = (*PendingOrderCreditsMutation)(nil)

// pendingordercreditsOption allows management of the mutation configuration using functional options.
type pendingordercreditsOption func(*PendingOrderCreditsMutation)

// newPendingOrderCreditsMutation creates new mutation for the PendingOrderCredits entity.
func newPendingOrderCreditsMutation(c config, op Op, opts ...pendingordercreditsOption) *PendingOrderCreditsMutation {
	m := &PendingOrderCreditsMutation{
		config:        c,
		op:            op,
		typ:           TypePendingOrderCredits,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingOrderCreditsID sets the ID field of the mutation.
func withPendingOrderCreditsID(id int) pendingordercreditsOption {
	return func(m *PendingOrderCreditsMutation) {
		var (
			err   error
			once  sync.Once
			value *PendingOrderCredits
		)
		m.oldValue = func(ctx context.Context) (*PendingOrderCredits, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PendingOrderCredits.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingOrderCredits sets the old PendingOrderCredits of the mutation.
func withPendingOrderCredits(node *PendingOrderCredits) pendingordercreditsOption {
	return func(m *PendingOrderCreditsMutation) {
		m.oldValue = func(context.Context) (*PendingOrderCredits, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingOrderCreditsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingOrderCreditsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PendingOrderCreditsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PendingOrderCreditsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PendingOrderCredits.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *PendingOrderCreditsMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PendingOrderCreditsMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PendingOrderCredits entity.
// If the PendingOrderCredits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingOrderCreditsMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *PendingOrderCreditsMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *PendingOrderCreditsMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PendingOrderCreditsMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetCreditID sets the "credit_id" field.
func (m *PendingOrderCreditsMutation) SetCreditID(i int64) {
	m.credit_id = &i
	m.addcredit_id = nil
}

// CreditID returns the value of the "credit_id" field in the mutation.
func (m *PendingOrderCreditsMutation) CreditID() (r int64, exists bool) {
	v := m.credit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditID returns the old "credit_id" field's value of the PendingOrderCredits entity.
// If the PendingOrderCredits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingOrderCreditsMutation) OldCreditID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditID: %w", err)
	}
	return oldValue.CreditID, nil
}

// AddCreditID adds i to the "credit_id" field.
func (m *PendingOrderCreditsMutation) AddCreditID(i int64) {
	if m.addcredit_id != nil {
		*m.addcredit_id += i
	} else {
		m.addcredit_id = &i
	}
}

// AddedCreditID returns the value that was added to the "credit_id" field in this mutation.
func (m *PendingOrderCreditsMutation) AddedCreditID() (r int64, exists bool) {
	v := m.addcredit_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditID resets all changes to the "credit_id" field.
func (m *PendingOrderCreditsMutation) ResetCreditID() {
	m.credit_id = nil
	m.addcredit_id = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PendingOrderCreditsMutation) SetClinicID(i int64) {
	m.clinic_id = &i
	m.addclinic_id = nil
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PendingOrderCreditsMutation) ClinicID() (r int64, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PendingOrderCredits entity.
// If the PendingOrderCredits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingOrderCreditsMutation) OldClinicID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// AddClinicID adds i to the "clinic_id" field.
func (m *PendingOrderCreditsMutation) AddClinicID(i int64) {
	if m.addclinic_id != nil {
		*m.addclinic_id += i
	} else {
		m.addclinic_id = &i
	}
}

// AddedClinicID returns the value that was added to the "clinic_id" field in this mutation.
func (m *PendingOrderCreditsMutation) AddedClinicID() (r int64, exists bool) {
	v := m.addclinic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PendingOrderCreditsMutation) ResetClinicID() {
	m.clinic_id = nil
	m.addclinic_id = nil
}

// Where appends a list predicates to the PendingOrderCreditsMutation builder.
func (m *PendingOrderCreditsMutation) Where(ps ...predicate.PendingOrderCredits) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PendingOrderCreditsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PendingOrderCreditsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PendingOrderCredits, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PendingOrderCreditsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PendingOrderCreditsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PendingOrderCredits).
func (m *PendingOrderCreditsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingOrderCreditsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.order_id != nil {
		fields = append(fields, pendingordercredits.FieldOrderID)
	}
	if m.credit_id != nil {
		fields = append(fields, pendingordercredits.FieldCreditID)
	}
	if m.clinic_id != nil {
		fields = append(fields, pendingordercredits.FieldClinicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingOrderCreditsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingordercredits.FieldOrderID:
		return m.OrderID()
	case pendingordercredits.FieldCreditID:
		return m.CreditID()
	case pendingordercredits.FieldClinicID:
		return m.ClinicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingOrderCreditsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingordercredits.FieldOrderID:
		return m.OldOrderID(ctx)
	case pendingordercredits.FieldCreditID:
		return m.OldCreditID(ctx)
	case pendingordercredits.FieldClinicID:
		return m.OldClinicID(ctx)
	}
	return nil, fmt.Errorf("unknown PendingOrderCredits field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingOrderCreditsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingordercredits.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case pendingordercredits.FieldCreditID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditID(v)
		return nil
	case pendingordercredits.FieldClinicID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	}
	return fmt.Errorf("unknown PendingOrderCredits field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingOrderCreditsMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, pendingordercredits.FieldOrderID)
	}
	if m.addcredit_id != nil {
		fields = append(fields, pendingordercredits.FieldCreditID)
	}
	if m.addclinic_id != nil {
		fields = append(fields, pendingordercredits.FieldClinicID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingOrderCreditsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pendingordercredits.FieldOrderID:
		return m.AddedOrderID()
	case pendingordercredits.FieldCreditID:
		return m.AddedCreditID()
	case pendingordercredits.FieldClinicID:
		return m.AddedClinicID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingOrderCreditsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pendingordercredits.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case pendingordercredits.FieldCreditID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditID(v)
		return nil
	case pendingordercredits.FieldClinicID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClinicID(v)
		return nil
	}
	return fmt.Errorf("unknown PendingOrderCredits numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingOrderCreditsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingOrderCreditsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingOrderCreditsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PendingOrderCredits nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingOrderCreditsMutation) ResetField(name string) error {
	switch name {
	case pendingordercredits.FieldOrderID:
		m.ResetOrderID()
		return nil
	case pendingordercredits.FieldCreditID:
		m.ResetCreditID()
		return nil
	case pendingordercredits.FieldClinicID:
		m.ResetClinicID()
		return nil
	}
	return fmt.Errorf("unknown PendingOrderCredits field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingOrderCreditsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingOrderCreditsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingOrderCreditsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingOrderCreditsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingOrderCreditsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingOrderCreditsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingOrderCreditsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PendingOrderCredits unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingOrderCreditsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PendingOrderCredits edge %s", name)
}

// RBACActionsMutation represents an operation that mutates the RBACActions nodes in the graph.
type RBACActionsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RBACActions, error)
	predicates    []predicate.RBACActions
}

var _ ent.Mutation = (*RBACActionsMutation)(nil)

// rbacactionsOption allows management of the mutation configuration using functional options.
type rbacactionsOption func(*RBACActionsMutation)

// newRBACActionsMutation creates new mutation for the RBACActions entity.
func newRBACActionsMutation(c config, op Op, opts ...rbacactionsOption) *RBACActionsMutation {
	m := &RBACActionsMutation{
		config:        c,
		op:            op,
		typ:           TypeRBACActions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRBACActionsID sets the ID field of the mutation.
func withRBACActionsID(id int) rbacactionsOption {
	return func(m *RBACActionsMutation) {
		var (
			err   error
			once  sync.Once
			value *RBACActions
		)
		m.oldValue = func(ctx context.Context) (*RBACActions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RBACActions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRBACActions sets the old RBACActions of the mutation.
func withRBACActions(node *RBACActions) rbacactionsOption {
	return func(m *RBACActionsMutation) {
		m.oldValue = func(context.Context) (*RBACActions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RBACActionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RBACActionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RBACActionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RBACActionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RBACActions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RBACActionsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RBACActionsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RBACActions entity.
// If the RBACActions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACActionsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RBACActionsMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the RBACActionsMutation builder.
func (m *RBACActionsMutation) Where(ps ...predicate.RBACActions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RBACActionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RBACActionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RBACActions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RBACActionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RBACActionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RBACActions).
func (m *RBACActionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RBACActionsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, rbacactions.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RBACActionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacactions.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RBACActionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacactions.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RBACActions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACActionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacactions.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RBACActions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RBACActionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RBACActionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACActionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RBACActions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RBACActionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RBACActionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RBACActionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RBACActions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RBACActionsMutation) ResetField(name string) error {
	switch name {
	case rbacactions.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RBACActions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RBACActionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RBACActionsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RBACActionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RBACActionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RBACActionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RBACActionsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RBACActionsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RBACActions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RBACActionsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RBACActions edge %s", name)
}

// RBACResourcesMutation represents an operation that mutates the RBACResources nodes in the graph.
type RBACResourcesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RBACResources, error)
	predicates    []predicate.RBACResources
}

var _ ent.Mutation = (*RBACResourcesMutation)(nil)

// rbacresourcesOption allows management of the mutation configuration using functional options.
type rbacresourcesOption func(*RBACResourcesMutation)

// newRBACResourcesMutation creates new mutation for the RBACResources entity.
func newRBACResourcesMutation(c config, op Op, opts ...rbacresourcesOption) *RBACResourcesMutation {
	m := &RBACResourcesMutation{
		config:        c,
		op:            op,
		typ:           TypeRBACResources,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRBACResourcesID sets the ID field of the mutation.
func withRBACResourcesID(id int) rbacresourcesOption {
	return func(m *RBACResourcesMutation) {
		var (
			err   error
			once  sync.Once
			value *RBACResources
		)
		m.oldValue = func(ctx context.Context) (*RBACResources, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RBACResources.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRBACResources sets the old RBACResources of the mutation.
func withRBACResources(node *RBACResources) rbacresourcesOption {
	return func(m *RBACResourcesMutation) {
		m.oldValue = func(context.Context) (*RBACResources, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RBACResourcesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RBACResourcesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RBACResourcesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RBACResourcesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RBACResources.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RBACResourcesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RBACResourcesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RBACResources entity.
// If the RBACResources object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACResourcesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RBACResourcesMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RBACResourcesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RBACResourcesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RBACResources entity.
// If the RBACResources object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACResourcesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RBACResourcesMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the RBACResourcesMutation builder.
func (m *RBACResourcesMutation) Where(ps ...predicate.RBACResources) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RBACResourcesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RBACResourcesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RBACResources, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RBACResourcesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RBACResourcesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RBACResources).
func (m *RBACResourcesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RBACResourcesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, rbacresources.FieldName)
	}
	if m.description != nil {
		fields = append(fields, rbacresources.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RBACResourcesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacresources.FieldName:
		return m.Name()
	case rbacresources.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RBACResourcesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacresources.FieldName:
		return m.OldName(ctx)
	case rbacresources.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown RBACResources field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACResourcesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacresources.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rbacresources.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown RBACResources field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RBACResourcesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RBACResourcesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACResourcesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RBACResources numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RBACResourcesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RBACResourcesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RBACResourcesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RBACResources nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RBACResourcesMutation) ResetField(name string) error {
	switch name {
	case rbacresources.FieldName:
		m.ResetName()
		return nil
	case rbacresources.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown RBACResources field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RBACResourcesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RBACResourcesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RBACResourcesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RBACResourcesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RBACResourcesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RBACResourcesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RBACResourcesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RBACResources unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RBACResourcesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RBACResources edge %s", name)
}

// RBACRolesMutation represents an operation that mutates the RBACRoles nodes in the graph.
type RBACRolesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	internal_name *string
	_type         *rbacroles.Type
	clinic_id     *int32
	addclinic_id  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RBACRoles, error)
	predicates    []predicate.RBACRoles
}

var _ ent.Mutation = (*RBACRolesMutation)(nil)

// rbacrolesOption allows management of the mutation configuration using functional options.
type rbacrolesOption func(*RBACRolesMutation)

// newRBACRolesMutation creates new mutation for the RBACRoles entity.
func newRBACRolesMutation(c config, op Op, opts ...rbacrolesOption) *RBACRolesMutation {
	m := &RBACRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeRBACRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRBACRolesID sets the ID field of the mutation.
func withRBACRolesID(id int) rbacrolesOption {
	return func(m *RBACRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *RBACRoles
		)
		m.oldValue = func(ctx context.Context) (*RBACRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RBACRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRBACRoles sets the old RBACRoles of the mutation.
func withRBACRoles(node *RBACRoles) rbacrolesOption {
	return func(m *RBACRolesMutation) {
		m.oldValue = func(context.Context) (*RBACRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RBACRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RBACRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RBACRolesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RBACRolesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RBACRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RBACRolesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RBACRolesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RBACRoles entity.
// If the RBACRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACRolesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RBACRolesMutation) ResetName() {
	m.name = nil
}

// SetInternalName sets the "internal_name" field.
func (m *RBACRolesMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *RBACRolesMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the RBACRoles entity.
// If the RBACRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACRolesMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *RBACRolesMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetType sets the "type" field.
func (m *RBACRolesMutation) SetType(r rbacroles.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RBACRolesMutation) GetType() (r rbacroles.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RBACRoles entity.
// If the RBACRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACRolesMutation) OldType(ctx context.Context) (v rbacroles.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RBACRolesMutation) ResetType() {
	m._type = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *RBACRolesMutation) SetClinicID(i int32) {
	m.clinic_id = &i
	m.addclinic_id = nil
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *RBACRolesMutation) ClinicID() (r int32, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the RBACRoles entity.
// If the RBACRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RBACRolesMutation) OldClinicID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// AddClinicID adds i to the "clinic_id" field.
func (m *RBACRolesMutation) AddClinicID(i int32) {
	if m.addclinic_id != nil {
		*m.addclinic_id += i
	} else {
		m.addclinic_id = &i
	}
}

// AddedClinicID returns the value that was added to the "clinic_id" field in this mutation.
func (m *RBACRolesMutation) AddedClinicID() (r int32, exists bool) {
	v := m.addclinic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *RBACRolesMutation) ResetClinicID() {
	m.clinic_id = nil
	m.addclinic_id = nil
}

// Where appends a list predicates to the RBACRolesMutation builder.
func (m *RBACRolesMutation) Where(ps ...predicate.RBACRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RBACRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RBACRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RBACRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RBACRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RBACRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RBACRoles).
func (m *RBACRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RBACRolesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, rbacroles.FieldName)
	}
	if m.internal_name != nil {
		fields = append(fields, rbacroles.FieldInternalName)
	}
	if m._type != nil {
		fields = append(fields, rbacroles.FieldType)
	}
	if m.clinic_id != nil {
		fields = append(fields, rbacroles.FieldClinicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RBACRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacroles.FieldName:
		return m.Name()
	case rbacroles.FieldInternalName:
		return m.InternalName()
	case rbacroles.FieldType:
		return m.GetType()
	case rbacroles.FieldClinicID:
		return m.ClinicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RBACRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacroles.FieldName:
		return m.OldName(ctx)
	case rbacroles.FieldInternalName:
		return m.OldInternalName(ctx)
	case rbacroles.FieldType:
		return m.OldType(ctx)
	case rbacroles.FieldClinicID:
		return m.OldClinicID(ctx)
	}
	return nil, fmt.Errorf("unknown RBACRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacroles.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rbacroles.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case rbacroles.FieldType:
		v, ok := value.(rbacroles.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rbacroles.FieldClinicID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	}
	return fmt.Errorf("unknown RBACRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RBACRolesMutation) AddedFields() []string {
	var fields []string
	if m.addclinic_id != nil {
		fields = append(fields, rbacroles.FieldClinicID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RBACRolesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rbacroles.FieldClinicID:
		return m.AddedClinicID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RBACRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rbacroles.FieldClinicID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClinicID(v)
		return nil
	}
	return fmt.Errorf("unknown RBACRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RBACRolesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RBACRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RBACRolesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RBACRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RBACRolesMutation) ResetField(name string) error {
	switch name {
	case rbacroles.FieldName:
		m.ResetName()
		return nil
	case rbacroles.FieldInternalName:
		m.ResetInternalName()
		return nil
	case rbacroles.FieldType:
		m.ResetType()
		return nil
	case rbacroles.FieldClinicID:
		m.ResetClinicID()
		return nil
	}
	return fmt.Errorf("unknown RBACRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RBACRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RBACRolesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RBACRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RBACRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RBACRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RBACRolesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RBACRolesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RBACRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RBACRolesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RBACRoles edge %s", name)
}

// SalesTeamMutation represents an operation that mutates the SalesTeam nodes in the graph.
type SalesTeamMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_time         *time.Time
	updated_time         *time.Time
	clearedFields        map[string]struct{}
	subordinates         map[int]struct{}
	removedsubordinates  map[int]struct{}
	clearedsubordinates  bool
	supervisor           *int
	clearedsupervisor    bool
	internal_user        *int
	clearedinternal_user bool
	title                *int
	clearedtitle         bool
	done                 bool
	oldValue             func(context.Context) (*SalesTeam, error)
	predicates           []predicate.SalesTeam
}

var _ ent.Mutation = (*SalesTeamMutation)(nil)

// salesteamOption allows management of the mutation configuration using functional options.
type salesteamOption func(*SalesTeamMutation)

// newSalesTeamMutation creates new mutation for the SalesTeam entity.
func newSalesTeamMutation(c config, op Op, opts ...salesteamOption) *SalesTeamMutation {
	m := &SalesTeamMutation{
		config:        c,
		op:            op,
		typ:           TypeSalesTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSalesTeamID sets the ID field of the mutation.
func withSalesTeamID(id int) salesteamOption {
	return func(m *SalesTeamMutation) {
		var (
			err   error
			once  sync.Once
			value *SalesTeam
		)
		m.oldValue = func(ctx context.Context) (*SalesTeam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SalesTeam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSalesTeam sets the old SalesTeam of the mutation.
func withSalesTeam(node *SalesTeam) salesteamOption {
	return func(m *SalesTeamMutation) {
		m.oldValue = func(context.Context) (*SalesTeam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SalesTeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SalesTeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SalesTeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SalesTeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SalesTeam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalUserID sets the "internal_user_id" field.
func (m *SalesTeamMutation) SetInternalUserID(i int) {
	m.internal_user = &i
}

// InternalUserID returns the value of the "internal_user_id" field in the mutation.
func (m *SalesTeamMutation) InternalUserID() (r int, exists bool) {
	v := m.internal_user
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalUserID returns the old "internal_user_id" field's value of the SalesTeam entity.
// If the SalesTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTeamMutation) OldInternalUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalUserID: %w", err)
	}
	return oldValue.InternalUserID, nil
}

// ResetInternalUserID resets all changes to the "internal_user_id" field.
func (m *SalesTeamMutation) ResetInternalUserID() {
	m.internal_user = nil
}

// SetSupervisorID sets the "supervisor_id" field.
func (m *SalesTeamMutation) SetSupervisorID(i int) {
	m.supervisor = &i
}

// SupervisorID returns the value of the "supervisor_id" field in the mutation.
func (m *SalesTeamMutation) SupervisorID() (r int, exists bool) {
	v := m.supervisor
	if v == nil {
		return
	}
	return *v, true
}

// OldSupervisorID returns the old "supervisor_id" field's value of the SalesTeam entity.
// If the SalesTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTeamMutation) OldSupervisorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupervisorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupervisorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupervisorID: %w", err)
	}
	return oldValue.SupervisorID, nil
}

// ClearSupervisorID clears the value of the "supervisor_id" field.
func (m *SalesTeamMutation) ClearSupervisorID() {
	m.supervisor = nil
	m.clearedFields[salesteam.FieldSupervisorID] = struct{}{}
}

// SupervisorIDCleared returns if the "supervisor_id" field was cleared in this mutation.
func (m *SalesTeamMutation) SupervisorIDCleared() bool {
	_, ok := m.clearedFields[salesteam.FieldSupervisorID]
	return ok
}

// ResetSupervisorID resets all changes to the "supervisor_id" field.
func (m *SalesTeamMutation) ResetSupervisorID() {
	m.supervisor = nil
	delete(m.clearedFields, salesteam.FieldSupervisorID)
}

// SetTitleID sets the "title_id" field.
func (m *SalesTeamMutation) SetTitleID(i int) {
	m.title = &i
}

// TitleID returns the value of the "title_id" field in the mutation.
func (m *SalesTeamMutation) TitleID() (r int, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleID returns the old "title_id" field's value of the SalesTeam entity.
// If the SalesTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTeamMutation) OldTitleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleID: %w", err)
	}
	return oldValue.TitleID, nil
}

// ClearTitleID clears the value of the "title_id" field.
func (m *SalesTeamMutation) ClearTitleID() {
	m.title = nil
	m.clearedFields[salesteam.FieldTitleID] = struct{}{}
}

// TitleIDCleared returns if the "title_id" field was cleared in this mutation.
func (m *SalesTeamMutation) TitleIDCleared() bool {
	_, ok := m.clearedFields[salesteam.FieldTitleID]
	return ok
}

// ResetTitleID resets all changes to the "title_id" field.
func (m *SalesTeamMutation) ResetTitleID() {
	m.title = nil
	delete(m.clearedFields, salesteam.FieldTitleID)
}

// SetCreatedTime sets the "created_time" field.
func (m *SalesTeamMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SalesTeamMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SalesTeam entity.
// If the SalesTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTeamMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SalesTeamMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *SalesTeamMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *SalesTeamMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the SalesTeam entity.
// If the SalesTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTeamMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *SalesTeamMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[salesteam.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *SalesTeamMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[salesteam.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *SalesTeamMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, salesteam.FieldUpdatedTime)
}

// AddSubordinateIDs adds the "subordinates" edge to the SalesTeam entity by ids.
func (m *SalesTeamMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the SalesTeam entity.
func (m *SalesTeamMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the SalesTeam entity was cleared.
func (m *SalesTeamMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the SalesTeam entity by IDs.
func (m *SalesTeamMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the SalesTeam entity.
func (m *SalesTeamMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *SalesTeamMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *SalesTeamMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// ClearSupervisor clears the "supervisor" edge to the SalesTeam entity.
func (m *SalesTeamMutation) ClearSupervisor() {
	m.clearedsupervisor = true
	m.clearedFields[salesteam.FieldSupervisorID] = struct{}{}
}

// SupervisorCleared reports if the "supervisor" edge to the SalesTeam entity was cleared.
func (m *SalesTeamMutation) SupervisorCleared() bool {
	return m.SupervisorIDCleared() || m.clearedsupervisor
}

// SupervisorIDs returns the "supervisor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupervisorID instead. It exists only for internal usage by the builders.
func (m *SalesTeamMutation) SupervisorIDs() (ids []int) {
	if id := m.supervisor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupervisor resets all changes to the "supervisor" edge.
func (m *SalesTeamMutation) ResetSupervisor() {
	m.supervisor = nil
	m.clearedsupervisor = false
}

// ClearInternalUser clears the "internal_user" edge to the InternalUser entity.
func (m *SalesTeamMutation) ClearInternalUser() {
	m.clearedinternal_user = true
	m.clearedFields[salesteam.FieldInternalUserID] = struct{}{}
}

// InternalUserCleared reports if the "internal_user" edge to the InternalUser entity was cleared.
func (m *SalesTeamMutation) InternalUserCleared() bool {
	return m.clearedinternal_user
}

// InternalUserIDs returns the "internal_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InternalUserID instead. It exists only for internal usage by the builders.
func (m *SalesTeamMutation) InternalUserIDs() (ids []int) {
	if id := m.internal_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInternalUser resets all changes to the "internal_user" edge.
func (m *SalesTeamMutation) ResetInternalUser() {
	m.internal_user = nil
	m.clearedinternal_user = false
}

// ClearTitle clears the "title" edge to the SalesTitle entity.
func (m *SalesTeamMutation) ClearTitle() {
	m.clearedtitle = true
	m.clearedFields[salesteam.FieldTitleID] = struct{}{}
}

// TitleCleared reports if the "title" edge to the SalesTitle entity was cleared.
func (m *SalesTeamMutation) TitleCleared() bool {
	return m.TitleIDCleared() || m.clearedtitle
}

// TitleIDs returns the "title" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TitleID instead. It exists only for internal usage by the builders.
func (m *SalesTeamMutation) TitleIDs() (ids []int) {
	if id := m.title; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitle resets all changes to the "title" edge.
func (m *SalesTeamMutation) ResetTitle() {
	m.title = nil
	m.clearedtitle = false
}

// Where appends a list predicates to the SalesTeamMutation builder.
func (m *SalesTeamMutation) Where(ps ...predicate.SalesTeam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SalesTeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SalesTeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SalesTeam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SalesTeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SalesTeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SalesTeam).
func (m *SalesTeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SalesTeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.internal_user != nil {
		fields = append(fields, salesteam.FieldInternalUserID)
	}
	if m.supervisor != nil {
		fields = append(fields, salesteam.FieldSupervisorID)
	}
	if m.title != nil {
		fields = append(fields, salesteam.FieldTitleID)
	}
	if m.created_time != nil {
		fields = append(fields, salesteam.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, salesteam.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SalesTeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case salesteam.FieldInternalUserID:
		return m.InternalUserID()
	case salesteam.FieldSupervisorID:
		return m.SupervisorID()
	case salesteam.FieldTitleID:
		return m.TitleID()
	case salesteam.FieldCreatedTime:
		return m.CreatedTime()
	case salesteam.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SalesTeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case salesteam.FieldInternalUserID:
		return m.OldInternalUserID(ctx)
	case salesteam.FieldSupervisorID:
		return m.OldSupervisorID(ctx)
	case salesteam.FieldTitleID:
		return m.OldTitleID(ctx)
	case salesteam.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case salesteam.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SalesTeam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case salesteam.FieldInternalUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalUserID(v)
		return nil
	case salesteam.FieldSupervisorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupervisorID(v)
		return nil
	case salesteam.FieldTitleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleID(v)
		return nil
	case salesteam.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case salesteam.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SalesTeam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SalesTeamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SalesTeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SalesTeam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SalesTeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(salesteam.FieldSupervisorID) {
		fields = append(fields, salesteam.FieldSupervisorID)
	}
	if m.FieldCleared(salesteam.FieldTitleID) {
		fields = append(fields, salesteam.FieldTitleID)
	}
	if m.FieldCleared(salesteam.FieldUpdatedTime) {
		fields = append(fields, salesteam.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SalesTeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SalesTeamMutation) ClearField(name string) error {
	switch name {
	case salesteam.FieldSupervisorID:
		m.ClearSupervisorID()
		return nil
	case salesteam.FieldTitleID:
		m.ClearTitleID()
		return nil
	case salesteam.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SalesTeam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SalesTeamMutation) ResetField(name string) error {
	switch name {
	case salesteam.FieldInternalUserID:
		m.ResetInternalUserID()
		return nil
	case salesteam.FieldSupervisorID:
		m.ResetSupervisorID()
		return nil
	case salesteam.FieldTitleID:
		m.ResetTitleID()
		return nil
	case salesteam.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case salesteam.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SalesTeam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SalesTeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subordinates != nil {
		edges = append(edges, salesteam.EdgeSubordinates)
	}
	if m.supervisor != nil {
		edges = append(edges, salesteam.EdgeSupervisor)
	}
	if m.internal_user != nil {
		edges = append(edges, salesteam.EdgeInternalUser)
	}
	if m.title != nil {
		edges = append(edges, salesteam.EdgeTitle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SalesTeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case salesteam.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case salesteam.EdgeSupervisor:
		if id := m.supervisor; id != nil {
			return []ent.Value{*id}
		}
	case salesteam.EdgeInternalUser:
		if id := m.internal_user; id != nil {
			return []ent.Value{*id}
		}
	case salesteam.EdgeTitle:
		if id := m.title; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SalesTeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubordinates != nil {
		edges = append(edges, salesteam.EdgeSubordinates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SalesTeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case salesteam.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SalesTeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubordinates {
		edges = append(edges, salesteam.EdgeSubordinates)
	}
	if m.clearedsupervisor {
		edges = append(edges, salesteam.EdgeSupervisor)
	}
	if m.clearedinternal_user {
		edges = append(edges, salesteam.EdgeInternalUser)
	}
	if m.clearedtitle {
		edges = append(edges, salesteam.EdgeTitle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SalesTeamMutation) EdgeCleared(name string) bool {
	switch name {
	case salesteam.EdgeSubordinates:
		return m.clearedsubordinates
	case salesteam.EdgeSupervisor:
		return m.clearedsupervisor
	case salesteam.EdgeInternalUser:
		return m.clearedinternal_user
	case salesteam.EdgeTitle:
		return m.clearedtitle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SalesTeamMutation) ClearEdge(name string) error {
	switch name {
	case salesteam.EdgeSupervisor:
		m.ClearSupervisor()
		return nil
	case salesteam.EdgeInternalUser:
		m.ClearInternalUser()
		return nil
	case salesteam.EdgeTitle:
		m.ClearTitle()
		return nil
	}
	return fmt.Errorf("unknown SalesTeam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SalesTeamMutation) ResetEdge(name string) error {
	switch name {
	case salesteam.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case salesteam.EdgeSupervisor:
		m.ResetSupervisor()
		return nil
	case salesteam.EdgeInternalUser:
		m.ResetInternalUser()
		return nil
	case salesteam.EdgeTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown SalesTeam edge %s", name)
}

// SalesTerritoryMutation represents an operation that mutates the SalesTerritory nodes in the graph.
type SalesTerritoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sales         *string
	state         *string
	zipcode       *int
	addzipcode    *int
	country       *string
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SalesTerritory, error)
	predicates    []predicate.SalesTerritory
}

var _ ent.Mutation = (*SalesTerritoryMutation)(nil)

// salesterritoryOption allows management of the mutation configuration using functional options.
type salesterritoryOption func(*SalesTerritoryMutation)

// newSalesTerritoryMutation creates new mutation for the SalesTerritory entity.
func newSalesTerritoryMutation(c config, op Op, opts ...salesterritoryOption) *SalesTerritoryMutation {
	m := &SalesTerritoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSalesTerritory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSalesTerritoryID sets the ID field of the mutation.
func withSalesTerritoryID(id int) salesterritoryOption {
	return func(m *SalesTerritoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SalesTerritory
		)
		m.oldValue = func(ctx context.Context) (*SalesTerritory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SalesTerritory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSalesTerritory sets the old SalesTerritory of the mutation.
func withSalesTerritory(node *SalesTerritory) salesterritoryOption {
	return func(m *SalesTerritoryMutation) {
		m.oldValue = func(context.Context) (*SalesTerritory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SalesTerritoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SalesTerritoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SalesTerritoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SalesTerritoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SalesTerritory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSales sets the "sales" field.
func (m *SalesTerritoryMutation) SetSales(s string) {
	m.sales = &s
}

// Sales returns the value of the "sales" field in the mutation.
func (m *SalesTerritoryMutation) Sales() (r string, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSales returns the old "sales" field's value of the SalesTerritory entity.
// If the SalesTerritory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTerritoryMutation) OldSales(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSales is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSales requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSales: %w", err)
	}
	return oldValue.Sales, nil
}

// ResetSales resets all changes to the "sales" field.
func (m *SalesTerritoryMutation) ResetSales() {
	m.sales = nil
}

// SetState sets the "state" field.
func (m *SalesTerritoryMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *SalesTerritoryMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SalesTerritory entity.
// If the SalesTerritory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTerritoryMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *SalesTerritoryMutation) ClearState() {
	m.state = nil
	m.clearedFields[salesterritory.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *SalesTerritoryMutation) StateCleared() bool {
	_, ok := m.clearedFields[salesterritory.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *SalesTerritoryMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, salesterritory.FieldState)
}

// SetZipcode sets the "zipcode" field.
func (m *SalesTerritoryMutation) SetZipcode(i int) {
	m.zipcode = &i
	m.addzipcode = nil
}

// Zipcode returns the value of the "zipcode" field in the mutation.
func (m *SalesTerritoryMutation) Zipcode() (r int, exists bool) {
	v := m.zipcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipcode returns the old "zipcode" field's value of the SalesTerritory entity.
// If the SalesTerritory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTerritoryMutation) OldZipcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipcode: %w", err)
	}
	return oldValue.Zipcode, nil
}

// AddZipcode adds i to the "zipcode" field.
func (m *SalesTerritoryMutation) AddZipcode(i int) {
	if m.addzipcode != nil {
		*m.addzipcode += i
	} else {
		m.addzipcode = &i
	}
}

// AddedZipcode returns the value that was added to the "zipcode" field in this mutation.
func (m *SalesTerritoryMutation) AddedZipcode() (r int, exists bool) {
	v := m.addzipcode
	if v == nil {
		return
	}
	return *v, true
}

// ClearZipcode clears the value of the "zipcode" field.
func (m *SalesTerritoryMutation) ClearZipcode() {
	m.zipcode = nil
	m.addzipcode = nil
	m.clearedFields[salesterritory.FieldZipcode] = struct{}{}
}

// ZipcodeCleared returns if the "zipcode" field was cleared in this mutation.
func (m *SalesTerritoryMutation) ZipcodeCleared() bool {
	_, ok := m.clearedFields[salesterritory.FieldZipcode]
	return ok
}

// ResetZipcode resets all changes to the "zipcode" field.
func (m *SalesTerritoryMutation) ResetZipcode() {
	m.zipcode = nil
	m.addzipcode = nil
	delete(m.clearedFields, salesterritory.FieldZipcode)
}

// SetCountry sets the "country" field.
func (m *SalesTerritoryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SalesTerritoryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the SalesTerritory entity.
// If the SalesTerritory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTerritoryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *SalesTerritoryMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[salesterritory.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *SalesTerritoryMutation) CountryCleared() bool {
	_, ok := m.clearedFields[salesterritory.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *SalesTerritoryMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, salesterritory.FieldCountry)
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *SalesTerritoryMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *SalesTerritoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the SalesTerritory entity.
// If the SalesTerritory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTerritoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updatedAt" field.
func (m *SalesTerritoryMutation) ClearUpdatedAt() {
	m.updatedAt = nil
	m.clearedFields[salesterritory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updatedAt" field was cleared in this mutation.
func (m *SalesTerritoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[salesterritory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *SalesTerritoryMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	delete(m.clearedFields, salesterritory.FieldUpdatedAt)
}

// Where appends a list predicates to the SalesTerritoryMutation builder.
func (m *SalesTerritoryMutation) Where(ps ...predicate.SalesTerritory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SalesTerritoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SalesTerritoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SalesTerritory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SalesTerritoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SalesTerritoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SalesTerritory).
func (m *SalesTerritoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SalesTerritoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sales != nil {
		fields = append(fields, salesterritory.FieldSales)
	}
	if m.state != nil {
		fields = append(fields, salesterritory.FieldState)
	}
	if m.zipcode != nil {
		fields = append(fields, salesterritory.FieldZipcode)
	}
	if m.country != nil {
		fields = append(fields, salesterritory.FieldCountry)
	}
	if m.updatedAt != nil {
		fields = append(fields, salesterritory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SalesTerritoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case salesterritory.FieldSales:
		return m.Sales()
	case salesterritory.FieldState:
		return m.State()
	case salesterritory.FieldZipcode:
		return m.Zipcode()
	case salesterritory.FieldCountry:
		return m.Country()
	case salesterritory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SalesTerritoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case salesterritory.FieldSales:
		return m.OldSales(ctx)
	case salesterritory.FieldState:
		return m.OldState(ctx)
	case salesterritory.FieldZipcode:
		return m.OldZipcode(ctx)
	case salesterritory.FieldCountry:
		return m.OldCountry(ctx)
	case salesterritory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SalesTerritory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTerritoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case salesterritory.FieldSales:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSales(v)
		return nil
	case salesterritory.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case salesterritory.FieldZipcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipcode(v)
		return nil
	case salesterritory.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case salesterritory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SalesTerritory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SalesTerritoryMutation) AddedFields() []string {
	var fields []string
	if m.addzipcode != nil {
		fields = append(fields, salesterritory.FieldZipcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SalesTerritoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case salesterritory.FieldZipcode:
		return m.AddedZipcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTerritoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case salesterritory.FieldZipcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZipcode(v)
		return nil
	}
	return fmt.Errorf("unknown SalesTerritory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SalesTerritoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(salesterritory.FieldState) {
		fields = append(fields, salesterritory.FieldState)
	}
	if m.FieldCleared(salesterritory.FieldZipcode) {
		fields = append(fields, salesterritory.FieldZipcode)
	}
	if m.FieldCleared(salesterritory.FieldCountry) {
		fields = append(fields, salesterritory.FieldCountry)
	}
	if m.FieldCleared(salesterritory.FieldUpdatedAt) {
		fields = append(fields, salesterritory.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SalesTerritoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SalesTerritoryMutation) ClearField(name string) error {
	switch name {
	case salesterritory.FieldState:
		m.ClearState()
		return nil
	case salesterritory.FieldZipcode:
		m.ClearZipcode()
		return nil
	case salesterritory.FieldCountry:
		m.ClearCountry()
		return nil
	case salesterritory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SalesTerritory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SalesTerritoryMutation) ResetField(name string) error {
	switch name {
	case salesterritory.FieldSales:
		m.ResetSales()
		return nil
	case salesterritory.FieldState:
		m.ResetState()
		return nil
	case salesterritory.FieldZipcode:
		m.ResetZipcode()
		return nil
	case salesterritory.FieldCountry:
		m.ResetCountry()
		return nil
	case salesterritory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SalesTerritory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SalesTerritoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SalesTerritoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SalesTerritoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SalesTerritoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SalesTerritoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SalesTerritoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SalesTerritoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SalesTerritory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SalesTerritoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SalesTerritory edge %s", name)
}

// SalesTitleMutation represents an operation that mutates the SalesTitle nodes in the graph.
type SalesTitleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title_name    *string
	_order        *int
	add_order     *int
	created_time  *time.Time
	updated_time  *time.Time
	clearedFields map[string]struct{}
	sales         map[int]struct{}
	removedsales  map[int]struct{}
	clearedsales  bool
	done          bool
	oldValue      func(context.Context) (*SalesTitle, error)
	predicates    []predicate.SalesTitle
}

var _ ent.Mutation = (*SalesTitleMutation)(nil)

// salestitleOption allows management of the mutation configuration using functional options.
type salestitleOption func(*SalesTitleMutation)

// newSalesTitleMutation creates new mutation for the SalesTitle entity.
func newSalesTitleMutation(c config, op Op, opts ...salestitleOption) *SalesTitleMutation {
	m := &SalesTitleMutation{
		config:        c,
		op:            op,
		typ:           TypeSalesTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSalesTitleID sets the ID field of the mutation.
func withSalesTitleID(id int) salestitleOption {
	return func(m *SalesTitleMutation) {
		var (
			err   error
			once  sync.Once
			value *SalesTitle
		)
		m.oldValue = func(ctx context.Context) (*SalesTitle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SalesTitle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSalesTitle sets the old SalesTitle of the mutation.
func withSalesTitle(node *SalesTitle) salestitleOption {
	return func(m *SalesTitleMutation) {
		m.oldValue = func(context.Context) (*SalesTitle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SalesTitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SalesTitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SalesTitleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SalesTitleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SalesTitle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitleName sets the "title_name" field.
func (m *SalesTitleMutation) SetTitleName(s string) {
	m.title_name = &s
}

// TitleName returns the value of the "title_name" field in the mutation.
func (m *SalesTitleMutation) TitleName() (r string, exists bool) {
	v := m.title_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleName returns the old "title_name" field's value of the SalesTitle entity.
// If the SalesTitle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTitleMutation) OldTitleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleName: %w", err)
	}
	return oldValue.TitleName, nil
}

// ResetTitleName resets all changes to the "title_name" field.
func (m *SalesTitleMutation) ResetTitleName() {
	m.title_name = nil
}

// SetOrder sets the "order" field.
func (m *SalesTitleMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *SalesTitleMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the SalesTitle entity.
// If the SalesTitle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTitleMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *SalesTitleMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *SalesTitleMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *SalesTitleMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SalesTitleMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SalesTitleMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SalesTitle entity.
// If the SalesTitle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTitleMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SalesTitleMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *SalesTitleMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *SalesTitleMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the SalesTitle entity.
// If the SalesTitle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalesTitleMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *SalesTitleMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[salestitle.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *SalesTitleMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[salestitle.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *SalesTitleMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, salestitle.FieldUpdatedTime)
}

// AddSaleIDs adds the "sales" edge to the SalesTeam entity by ids.
func (m *SalesTitleMutation) AddSaleIDs(ids ...int) {
	if m.sales == nil {
		m.sales = make(map[int]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the SalesTeam entity.
func (m *SalesTitleMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the SalesTeam entity was cleared.
func (m *SalesTitleMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the SalesTeam entity by IDs.
func (m *SalesTitleMutation) RemoveSaleIDs(ids ...int) {
	if m.removedsales == nil {
		m.removedsales = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the SalesTeam entity.
func (m *SalesTitleMutation) RemovedSalesIDs() (ids []int) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *SalesTitleMutation) SalesIDs() (ids []int) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *SalesTitleMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// Where appends a list predicates to the SalesTitleMutation builder.
func (m *SalesTitleMutation) Where(ps ...predicate.SalesTitle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SalesTitleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SalesTitleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SalesTitle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SalesTitleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SalesTitleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SalesTitle).
func (m *SalesTitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SalesTitleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title_name != nil {
		fields = append(fields, salestitle.FieldTitleName)
	}
	if m._order != nil {
		fields = append(fields, salestitle.FieldOrder)
	}
	if m.created_time != nil {
		fields = append(fields, salestitle.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, salestitle.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SalesTitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case salestitle.FieldTitleName:
		return m.TitleName()
	case salestitle.FieldOrder:
		return m.Order()
	case salestitle.FieldCreatedTime:
		return m.CreatedTime()
	case salestitle.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SalesTitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case salestitle.FieldTitleName:
		return m.OldTitleName(ctx)
	case salestitle.FieldOrder:
		return m.OldOrder(ctx)
	case salestitle.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case salestitle.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SalesTitle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case salestitle.FieldTitleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleName(v)
		return nil
	case salestitle.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case salestitle.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case salestitle.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SalesTitle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SalesTitleMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, salestitle.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SalesTitleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case salestitle.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalesTitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case salestitle.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown SalesTitle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SalesTitleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(salestitle.FieldUpdatedTime) {
		fields = append(fields, salestitle.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SalesTitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SalesTitleMutation) ClearField(name string) error {
	switch name {
	case salestitle.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SalesTitle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SalesTitleMutation) ResetField(name string) error {
	switch name {
	case salestitle.FieldTitleName:
		m.ResetTitleName()
		return nil
	case salestitle.FieldOrder:
		m.ResetOrder()
		return nil
	case salestitle.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case salestitle.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SalesTitle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SalesTitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sales != nil {
		edges = append(edges, salestitle.EdgeSales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SalesTitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case salestitle.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SalesTitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsales != nil {
		edges = append(edges, salestitle.EdgeSales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SalesTitleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case salestitle.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SalesTitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsales {
		edges = append(edges, salestitle.EdgeSales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SalesTitleMutation) EdgeCleared(name string) bool {
	switch name {
	case salestitle.EdgeSales:
		return m.clearedsales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SalesTitleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SalesTitle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SalesTitleMutation) ResetEdge(name string) error {
	switch name {
	case salestitle.EdgeSales:
		m.ResetSales()
		return nil
	}
	return fmt.Errorf("unknown SalesTitle edge %s", name)
}

// SampleMutation represents an operation that mutates the Sample nodes in the graph.
type SampleMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	accession_id                  *string
	sample_storage                *string
	tube_count                    *int
	addtube_count                 *int
	sample_order_method           *string
	sample_collection_time        *time.Time
	sample_received_time          *time.Time
	sample_description            *string
	delayed_hours                 *int
	adddelayed_hours              *int
	sample_report_time            *time.Time
	internal_received_time        *time.Time
	sample_report_type            *string
	fasting_hours                 *float64
	addfasting_hours              *float64
	fasting_status                *string
	clearedFields                 map[string]struct{}
	_order                        *int
	cleared_order                 bool
	tubes                         map[int]struct{}
	removedtubes                  map[int]struct{}
	clearedtubes                  bool
	sample_receive_records        map[int]struct{}
	removedsample_receive_records map[int]struct{}
	clearedsample_receive_records bool
	sample_required_tubes         map[int]struct{}
	removedsample_required_tubes  map[int]struct{}
	clearedsample_required_tubes  bool
	patient                       *int
	clearedpatient                bool
	customer                      *int
	clearedcustomer               bool
	done                          bool
	oldValue                      func(context.Context) (*Sample, error)
	predicates                    []predicate.Sample
}

var _ ent.Mutation = (*SampleMutation)(nil)

// sampleOption allows management of the mutation configuration using functional options.
type sampleOption func(*SampleMutation)

// newSampleMutation creates new mutation for the Sample entity.
func newSampleMutation(c config, op Op, opts ...sampleOption) *SampleMutation {
	m := &SampleMutation{
		config:        c,
		op:            op,
		typ:           TypeSample,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSampleID sets the ID field of the mutation.
func withSampleID(id int) sampleOption {
	return func(m *SampleMutation) {
		var (
			err   error
			once  sync.Once
			value *Sample
		)
		m.oldValue = func(ctx context.Context) (*Sample, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sample.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSample sets the old Sample of the mutation.
func withSample(node *Sample) sampleOption {
	return func(m *SampleMutation) {
		m.oldValue = func(context.Context) (*Sample, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SampleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SampleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sample entities.
func (m *SampleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SampleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SampleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sample.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccessionID sets the "accession_id" field.
func (m *SampleMutation) SetAccessionID(s string) {
	m.accession_id = &s
}

// AccessionID returns the value of the "accession_id" field in the mutation.
func (m *SampleMutation) AccessionID() (r string, exists bool) {
	v := m.accession_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessionID returns the old "accession_id" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldAccessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessionID: %w", err)
	}
	return oldValue.AccessionID, nil
}

// ResetAccessionID resets all changes to the "accession_id" field.
func (m *SampleMutation) ResetAccessionID() {
	m.accession_id = nil
}

// SetSampleStorage sets the "sample_storage" field.
func (m *SampleMutation) SetSampleStorage(s string) {
	m.sample_storage = &s
}

// SampleStorage returns the value of the "sample_storage" field in the mutation.
func (m *SampleMutation) SampleStorage() (r string, exists bool) {
	v := m.sample_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleStorage returns the old "sample_storage" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleStorage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleStorage: %w", err)
	}
	return oldValue.SampleStorage, nil
}

// ClearSampleStorage clears the value of the "sample_storage" field.
func (m *SampleMutation) ClearSampleStorage() {
	m.sample_storage = nil
	m.clearedFields[sample.FieldSampleStorage] = struct{}{}
}

// SampleStorageCleared returns if the "sample_storage" field was cleared in this mutation.
func (m *SampleMutation) SampleStorageCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleStorage]
	return ok
}

// ResetSampleStorage resets all changes to the "sample_storage" field.
func (m *SampleMutation) ResetSampleStorage() {
	m.sample_storage = nil
	delete(m.clearedFields, sample.FieldSampleStorage)
}

// SetTubeCount sets the "tube_count" field.
func (m *SampleMutation) SetTubeCount(i int) {
	m.tube_count = &i
	m.addtube_count = nil
}

// TubeCount returns the value of the "tube_count" field in the mutation.
func (m *SampleMutation) TubeCount() (r int, exists bool) {
	v := m.tube_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeCount returns the old "tube_count" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldTubeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeCount: %w", err)
	}
	return oldValue.TubeCount, nil
}

// AddTubeCount adds i to the "tube_count" field.
func (m *SampleMutation) AddTubeCount(i int) {
	if m.addtube_count != nil {
		*m.addtube_count += i
	} else {
		m.addtube_count = &i
	}
}

// AddedTubeCount returns the value that was added to the "tube_count" field in this mutation.
func (m *SampleMutation) AddedTubeCount() (r int, exists bool) {
	v := m.addtube_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTubeCount clears the value of the "tube_count" field.
func (m *SampleMutation) ClearTubeCount() {
	m.tube_count = nil
	m.addtube_count = nil
	m.clearedFields[sample.FieldTubeCount] = struct{}{}
}

// TubeCountCleared returns if the "tube_count" field was cleared in this mutation.
func (m *SampleMutation) TubeCountCleared() bool {
	_, ok := m.clearedFields[sample.FieldTubeCount]
	return ok
}

// ResetTubeCount resets all changes to the "tube_count" field.
func (m *SampleMutation) ResetTubeCount() {
	m.tube_count = nil
	m.addtube_count = nil
	delete(m.clearedFields, sample.FieldTubeCount)
}

// SetOrderID sets the "order_id" field.
func (m *SampleMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *SampleMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *SampleMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[sample.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *SampleMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[sample.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *SampleMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, sample.FieldOrderID)
}

// SetPatientID sets the "patient_id" field.
func (m *SampleMutation) SetPatientID(i int) {
	m.patient = &i
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *SampleMutation) PatientID() (r int, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldPatientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ClearPatientID clears the value of the "patient_id" field.
func (m *SampleMutation) ClearPatientID() {
	m.patient = nil
	m.clearedFields[sample.FieldPatientID] = struct{}{}
}

// PatientIDCleared returns if the "patient_id" field was cleared in this mutation.
func (m *SampleMutation) PatientIDCleared() bool {
	_, ok := m.clearedFields[sample.FieldPatientID]
	return ok
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *SampleMutation) ResetPatientID() {
	m.patient = nil
	delete(m.clearedFields, sample.FieldPatientID)
}

// SetSampleOrderMethod sets the "sample_order_method" field.
func (m *SampleMutation) SetSampleOrderMethod(s string) {
	m.sample_order_method = &s
}

// SampleOrderMethod returns the value of the "sample_order_method" field in the mutation.
func (m *SampleMutation) SampleOrderMethod() (r string, exists bool) {
	v := m.sample_order_method
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleOrderMethod returns the old "sample_order_method" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleOrderMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleOrderMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleOrderMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleOrderMethod: %w", err)
	}
	return oldValue.SampleOrderMethod, nil
}

// ClearSampleOrderMethod clears the value of the "sample_order_method" field.
func (m *SampleMutation) ClearSampleOrderMethod() {
	m.sample_order_method = nil
	m.clearedFields[sample.FieldSampleOrderMethod] = struct{}{}
}

// SampleOrderMethodCleared returns if the "sample_order_method" field was cleared in this mutation.
func (m *SampleMutation) SampleOrderMethodCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleOrderMethod]
	return ok
}

// ResetSampleOrderMethod resets all changes to the "sample_order_method" field.
func (m *SampleMutation) ResetSampleOrderMethod() {
	m.sample_order_method = nil
	delete(m.clearedFields, sample.FieldSampleOrderMethod)
}

// SetSampleCollectionTime sets the "sample_collection_time" field.
func (m *SampleMutation) SetSampleCollectionTime(t time.Time) {
	m.sample_collection_time = &t
}

// SampleCollectionTime returns the value of the "sample_collection_time" field in the mutation.
func (m *SampleMutation) SampleCollectionTime() (r time.Time, exists bool) {
	v := m.sample_collection_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleCollectionTime returns the old "sample_collection_time" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleCollectionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleCollectionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleCollectionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleCollectionTime: %w", err)
	}
	return oldValue.SampleCollectionTime, nil
}

// ClearSampleCollectionTime clears the value of the "sample_collection_time" field.
func (m *SampleMutation) ClearSampleCollectionTime() {
	m.sample_collection_time = nil
	m.clearedFields[sample.FieldSampleCollectionTime] = struct{}{}
}

// SampleCollectionTimeCleared returns if the "sample_collection_time" field was cleared in this mutation.
func (m *SampleMutation) SampleCollectionTimeCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleCollectionTime]
	return ok
}

// ResetSampleCollectionTime resets all changes to the "sample_collection_time" field.
func (m *SampleMutation) ResetSampleCollectionTime() {
	m.sample_collection_time = nil
	delete(m.clearedFields, sample.FieldSampleCollectionTime)
}

// SetSampleReceivedTime sets the "sample_received_time" field.
func (m *SampleMutation) SetSampleReceivedTime(t time.Time) {
	m.sample_received_time = &t
}

// SampleReceivedTime returns the value of the "sample_received_time" field in the mutation.
func (m *SampleMutation) SampleReceivedTime() (r time.Time, exists bool) {
	v := m.sample_received_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleReceivedTime returns the old "sample_received_time" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleReceivedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleReceivedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleReceivedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleReceivedTime: %w", err)
	}
	return oldValue.SampleReceivedTime, nil
}

// ClearSampleReceivedTime clears the value of the "sample_received_time" field.
func (m *SampleMutation) ClearSampleReceivedTime() {
	m.sample_received_time = nil
	m.clearedFields[sample.FieldSampleReceivedTime] = struct{}{}
}

// SampleReceivedTimeCleared returns if the "sample_received_time" field was cleared in this mutation.
func (m *SampleMutation) SampleReceivedTimeCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleReceivedTime]
	return ok
}

// ResetSampleReceivedTime resets all changes to the "sample_received_time" field.
func (m *SampleMutation) ResetSampleReceivedTime() {
	m.sample_received_time = nil
	delete(m.clearedFields, sample.FieldSampleReceivedTime)
}

// SetSampleDescription sets the "sample_description" field.
func (m *SampleMutation) SetSampleDescription(s string) {
	m.sample_description = &s
}

// SampleDescription returns the value of the "sample_description" field in the mutation.
func (m *SampleMutation) SampleDescription() (r string, exists bool) {
	v := m.sample_description
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleDescription returns the old "sample_description" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleDescription: %w", err)
	}
	return oldValue.SampleDescription, nil
}

// ClearSampleDescription clears the value of the "sample_description" field.
func (m *SampleMutation) ClearSampleDescription() {
	m.sample_description = nil
	m.clearedFields[sample.FieldSampleDescription] = struct{}{}
}

// SampleDescriptionCleared returns if the "sample_description" field was cleared in this mutation.
func (m *SampleMutation) SampleDescriptionCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleDescription]
	return ok
}

// ResetSampleDescription resets all changes to the "sample_description" field.
func (m *SampleMutation) ResetSampleDescription() {
	m.sample_description = nil
	delete(m.clearedFields, sample.FieldSampleDescription)
}

// SetDelayedHours sets the "delayed_hours" field.
func (m *SampleMutation) SetDelayedHours(i int) {
	m.delayed_hours = &i
	m.adddelayed_hours = nil
}

// DelayedHours returns the value of the "delayed_hours" field in the mutation.
func (m *SampleMutation) DelayedHours() (r int, exists bool) {
	v := m.delayed_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldDelayedHours returns the old "delayed_hours" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldDelayedHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelayedHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelayedHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelayedHours: %w", err)
	}
	return oldValue.DelayedHours, nil
}

// AddDelayedHours adds i to the "delayed_hours" field.
func (m *SampleMutation) AddDelayedHours(i int) {
	if m.adddelayed_hours != nil {
		*m.adddelayed_hours += i
	} else {
		m.adddelayed_hours = &i
	}
}

// AddedDelayedHours returns the value that was added to the "delayed_hours" field in this mutation.
func (m *SampleMutation) AddedDelayedHours() (r int, exists bool) {
	v := m.adddelayed_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetDelayedHours resets all changes to the "delayed_hours" field.
func (m *SampleMutation) ResetDelayedHours() {
	m.delayed_hours = nil
	m.adddelayed_hours = nil
}

// SetSampleReportTime sets the "sample_report_time" field.
func (m *SampleMutation) SetSampleReportTime(t time.Time) {
	m.sample_report_time = &t
}

// SampleReportTime returns the value of the "sample_report_time" field in the mutation.
func (m *SampleMutation) SampleReportTime() (r time.Time, exists bool) {
	v := m.sample_report_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleReportTime returns the old "sample_report_time" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleReportTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleReportTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleReportTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleReportTime: %w", err)
	}
	return oldValue.SampleReportTime, nil
}

// ClearSampleReportTime clears the value of the "sample_report_time" field.
func (m *SampleMutation) ClearSampleReportTime() {
	m.sample_report_time = nil
	m.clearedFields[sample.FieldSampleReportTime] = struct{}{}
}

// SampleReportTimeCleared returns if the "sample_report_time" field was cleared in this mutation.
func (m *SampleMutation) SampleReportTimeCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleReportTime]
	return ok
}

// ResetSampleReportTime resets all changes to the "sample_report_time" field.
func (m *SampleMutation) ResetSampleReportTime() {
	m.sample_report_time = nil
	delete(m.clearedFields, sample.FieldSampleReportTime)
}

// SetInternalReceivedTime sets the "internal_received_time" field.
func (m *SampleMutation) SetInternalReceivedTime(t time.Time) {
	m.internal_received_time = &t
}

// InternalReceivedTime returns the value of the "internal_received_time" field in the mutation.
func (m *SampleMutation) InternalReceivedTime() (r time.Time, exists bool) {
	v := m.internal_received_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalReceivedTime returns the old "internal_received_time" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldInternalReceivedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalReceivedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalReceivedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalReceivedTime: %w", err)
	}
	return oldValue.InternalReceivedTime, nil
}

// ClearInternalReceivedTime clears the value of the "internal_received_time" field.
func (m *SampleMutation) ClearInternalReceivedTime() {
	m.internal_received_time = nil
	m.clearedFields[sample.FieldInternalReceivedTime] = struct{}{}
}

// InternalReceivedTimeCleared returns if the "internal_received_time" field was cleared in this mutation.
func (m *SampleMutation) InternalReceivedTimeCleared() bool {
	_, ok := m.clearedFields[sample.FieldInternalReceivedTime]
	return ok
}

// ResetInternalReceivedTime resets all changes to the "internal_received_time" field.
func (m *SampleMutation) ResetInternalReceivedTime() {
	m.internal_received_time = nil
	delete(m.clearedFields, sample.FieldInternalReceivedTime)
}

// SetSampleReportType sets the "sample_report_type" field.
func (m *SampleMutation) SetSampleReportType(s string) {
	m.sample_report_type = &s
}

// SampleReportType returns the value of the "sample_report_type" field in the mutation.
func (m *SampleMutation) SampleReportType() (r string, exists bool) {
	v := m.sample_report_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleReportType returns the old "sample_report_type" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldSampleReportType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleReportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleReportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleReportType: %w", err)
	}
	return oldValue.SampleReportType, nil
}

// ClearSampleReportType clears the value of the "sample_report_type" field.
func (m *SampleMutation) ClearSampleReportType() {
	m.sample_report_type = nil
	m.clearedFields[sample.FieldSampleReportType] = struct{}{}
}

// SampleReportTypeCleared returns if the "sample_report_type" field was cleared in this mutation.
func (m *SampleMutation) SampleReportTypeCleared() bool {
	_, ok := m.clearedFields[sample.FieldSampleReportType]
	return ok
}

// ResetSampleReportType resets all changes to the "sample_report_type" field.
func (m *SampleMutation) ResetSampleReportType() {
	m.sample_report_type = nil
	delete(m.clearedFields, sample.FieldSampleReportType)
}

// SetCustomerID sets the "customer_id" field.
func (m *SampleMutation) SetCustomerID(i int) {
	m.customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *SampleMutation) CustomerID() (r int, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *SampleMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[sample.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *SampleMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[sample.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *SampleMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, sample.FieldCustomerID)
}

// SetFastingHours sets the "fasting_hours" field.
func (m *SampleMutation) SetFastingHours(f float64) {
	m.fasting_hours = &f
	m.addfasting_hours = nil
}

// FastingHours returns the value of the "fasting_hours" field in the mutation.
func (m *SampleMutation) FastingHours() (r float64, exists bool) {
	v := m.fasting_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldFastingHours returns the old "fasting_hours" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldFastingHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFastingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFastingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFastingHours: %w", err)
	}
	return oldValue.FastingHours, nil
}

// AddFastingHours adds f to the "fasting_hours" field.
func (m *SampleMutation) AddFastingHours(f float64) {
	if m.addfasting_hours != nil {
		*m.addfasting_hours += f
	} else {
		m.addfasting_hours = &f
	}
}

// AddedFastingHours returns the value that was added to the "fasting_hours" field in this mutation.
func (m *SampleMutation) AddedFastingHours() (r float64, exists bool) {
	v := m.addfasting_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearFastingHours clears the value of the "fasting_hours" field.
func (m *SampleMutation) ClearFastingHours() {
	m.fasting_hours = nil
	m.addfasting_hours = nil
	m.clearedFields[sample.FieldFastingHours] = struct{}{}
}

// FastingHoursCleared returns if the "fasting_hours" field was cleared in this mutation.
func (m *SampleMutation) FastingHoursCleared() bool {
	_, ok := m.clearedFields[sample.FieldFastingHours]
	return ok
}

// ResetFastingHours resets all changes to the "fasting_hours" field.
func (m *SampleMutation) ResetFastingHours() {
	m.fasting_hours = nil
	m.addfasting_hours = nil
	delete(m.clearedFields, sample.FieldFastingHours)
}

// SetFastingStatus sets the "fasting_status" field.
func (m *SampleMutation) SetFastingStatus(s string) {
	m.fasting_status = &s
}

// FastingStatus returns the value of the "fasting_status" field in the mutation.
func (m *SampleMutation) FastingStatus() (r string, exists bool) {
	v := m.fasting_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFastingStatus returns the old "fasting_status" field's value of the Sample entity.
// If the Sample object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleMutation) OldFastingStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFastingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFastingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFastingStatus: %w", err)
	}
	return oldValue.FastingStatus, nil
}

// ClearFastingStatus clears the value of the "fasting_status" field.
func (m *SampleMutation) ClearFastingStatus() {
	m.fasting_status = nil
	m.clearedFields[sample.FieldFastingStatus] = struct{}{}
}

// FastingStatusCleared returns if the "fasting_status" field was cleared in this mutation.
func (m *SampleMutation) FastingStatusCleared() bool {
	_, ok := m.clearedFields[sample.FieldFastingStatus]
	return ok
}

// ResetFastingStatus resets all changes to the "fasting_status" field.
func (m *SampleMutation) ResetFastingStatus() {
	m.fasting_status = nil
	delete(m.clearedFields, sample.FieldFastingStatus)
}

// ClearOrder clears the "order" edge to the OrderInfo entity.
func (m *SampleMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[sample.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the OrderInfo entity was cleared.
func (m *SampleMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *SampleMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *SampleMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// AddTubeIDs adds the "tubes" edge to the Tube entity by ids.
func (m *SampleMutation) AddTubeIDs(ids ...int) {
	if m.tubes == nil {
		m.tubes = make(map[int]struct{})
	}
	for i := range ids {
		m.tubes[ids[i]] = struct{}{}
	}
}

// ClearTubes clears the "tubes" edge to the Tube entity.
func (m *SampleMutation) ClearTubes() {
	m.clearedtubes = true
}

// TubesCleared reports if the "tubes" edge to the Tube entity was cleared.
func (m *SampleMutation) TubesCleared() bool {
	return m.clearedtubes
}

// RemoveTubeIDs removes the "tubes" edge to the Tube entity by IDs.
func (m *SampleMutation) RemoveTubeIDs(ids ...int) {
	if m.removedtubes == nil {
		m.removedtubes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tubes, ids[i])
		m.removedtubes[ids[i]] = struct{}{}
	}
}

// RemovedTubes returns the removed IDs of the "tubes" edge to the Tube entity.
func (m *SampleMutation) RemovedTubesIDs() (ids []int) {
	for id := range m.removedtubes {
		ids = append(ids, id)
	}
	return
}

// TubesIDs returns the "tubes" edge IDs in the mutation.
func (m *SampleMutation) TubesIDs() (ids []int) {
	for id := range m.tubes {
		ids = append(ids, id)
	}
	return
}

// ResetTubes resets all changes to the "tubes" edge.
func (m *SampleMutation) ResetTubes() {
	m.tubes = nil
	m.clearedtubes = false
	m.removedtubes = nil
}

// AddSampleReceiveRecordIDs adds the "sample_receive_records" edge to the TubeReceive entity by ids.
func (m *SampleMutation) AddSampleReceiveRecordIDs(ids ...int) {
	if m.sample_receive_records == nil {
		m.sample_receive_records = make(map[int]struct{})
	}
	for i := range ids {
		m.sample_receive_records[ids[i]] = struct{}{}
	}
}

// ClearSampleReceiveRecords clears the "sample_receive_records" edge to the TubeReceive entity.
func (m *SampleMutation) ClearSampleReceiveRecords() {
	m.clearedsample_receive_records = true
}

// SampleReceiveRecordsCleared reports if the "sample_receive_records" edge to the TubeReceive entity was cleared.
func (m *SampleMutation) SampleReceiveRecordsCleared() bool {
	return m.clearedsample_receive_records
}

// RemoveSampleReceiveRecordIDs removes the "sample_receive_records" edge to the TubeReceive entity by IDs.
func (m *SampleMutation) RemoveSampleReceiveRecordIDs(ids ...int) {
	if m.removedsample_receive_records == nil {
		m.removedsample_receive_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sample_receive_records, ids[i])
		m.removedsample_receive_records[ids[i]] = struct{}{}
	}
}

// RemovedSampleReceiveRecords returns the removed IDs of the "sample_receive_records" edge to the TubeReceive entity.
func (m *SampleMutation) RemovedSampleReceiveRecordsIDs() (ids []int) {
	for id := range m.removedsample_receive_records {
		ids = append(ids, id)
	}
	return
}

// SampleReceiveRecordsIDs returns the "sample_receive_records" edge IDs in the mutation.
func (m *SampleMutation) SampleReceiveRecordsIDs() (ids []int) {
	for id := range m.sample_receive_records {
		ids = append(ids, id)
	}
	return
}

// ResetSampleReceiveRecords resets all changes to the "sample_receive_records" edge.
func (m *SampleMutation) ResetSampleReceiveRecords() {
	m.sample_receive_records = nil
	m.clearedsample_receive_records = false
	m.removedsample_receive_records = nil
}

// AddSampleRequiredTubeIDs adds the "sample_required_tubes" edge to the TubeRequirement entity by ids.
func (m *SampleMutation) AddSampleRequiredTubeIDs(ids ...int) {
	if m.sample_required_tubes == nil {
		m.sample_required_tubes = make(map[int]struct{})
	}
	for i := range ids {
		m.sample_required_tubes[ids[i]] = struct{}{}
	}
}

// ClearSampleRequiredTubes clears the "sample_required_tubes" edge to the TubeRequirement entity.
func (m *SampleMutation) ClearSampleRequiredTubes() {
	m.clearedsample_required_tubes = true
}

// SampleRequiredTubesCleared reports if the "sample_required_tubes" edge to the TubeRequirement entity was cleared.
func (m *SampleMutation) SampleRequiredTubesCleared() bool {
	return m.clearedsample_required_tubes
}

// RemoveSampleRequiredTubeIDs removes the "sample_required_tubes" edge to the TubeRequirement entity by IDs.
func (m *SampleMutation) RemoveSampleRequiredTubeIDs(ids ...int) {
	if m.removedsample_required_tubes == nil {
		m.removedsample_required_tubes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sample_required_tubes, ids[i])
		m.removedsample_required_tubes[ids[i]] = struct{}{}
	}
}

// RemovedSampleRequiredTubes returns the removed IDs of the "sample_required_tubes" edge to the TubeRequirement entity.
func (m *SampleMutation) RemovedSampleRequiredTubesIDs() (ids []int) {
	for id := range m.removedsample_required_tubes {
		ids = append(ids, id)
	}
	return
}

// SampleRequiredTubesIDs returns the "sample_required_tubes" edge IDs in the mutation.
func (m *SampleMutation) SampleRequiredTubesIDs() (ids []int) {
	for id := range m.sample_required_tubes {
		ids = append(ids, id)
	}
	return
}

// ResetSampleRequiredTubes resets all changes to the "sample_required_tubes" edge.
func (m *SampleMutation) ResetSampleRequiredTubes() {
	m.sample_required_tubes = nil
	m.clearedsample_required_tubes = false
	m.removedsample_required_tubes = nil
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *SampleMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[sample.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *SampleMutation) PatientCleared() bool {
	return m.PatientIDCleared() || m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *SampleMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *SampleMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *SampleMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[sample.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *SampleMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *SampleMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *SampleMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the SampleMutation builder.
func (m *SampleMutation) Where(ps ...predicate.Sample) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SampleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SampleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sample, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SampleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SampleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sample).
func (m *SampleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SampleMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.accession_id != nil {
		fields = append(fields, sample.FieldAccessionID)
	}
	if m.sample_storage != nil {
		fields = append(fields, sample.FieldSampleStorage)
	}
	if m.tube_count != nil {
		fields = append(fields, sample.FieldTubeCount)
	}
	if m._order != nil {
		fields = append(fields, sample.FieldOrderID)
	}
	if m.patient != nil {
		fields = append(fields, sample.FieldPatientID)
	}
	if m.sample_order_method != nil {
		fields = append(fields, sample.FieldSampleOrderMethod)
	}
	if m.sample_collection_time != nil {
		fields = append(fields, sample.FieldSampleCollectionTime)
	}
	if m.sample_received_time != nil {
		fields = append(fields, sample.FieldSampleReceivedTime)
	}
	if m.sample_description != nil {
		fields = append(fields, sample.FieldSampleDescription)
	}
	if m.delayed_hours != nil {
		fields = append(fields, sample.FieldDelayedHours)
	}
	if m.sample_report_time != nil {
		fields = append(fields, sample.FieldSampleReportTime)
	}
	if m.internal_received_time != nil {
		fields = append(fields, sample.FieldInternalReceivedTime)
	}
	if m.sample_report_type != nil {
		fields = append(fields, sample.FieldSampleReportType)
	}
	if m.customer != nil {
		fields = append(fields, sample.FieldCustomerID)
	}
	if m.fasting_hours != nil {
		fields = append(fields, sample.FieldFastingHours)
	}
	if m.fasting_status != nil {
		fields = append(fields, sample.FieldFastingStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SampleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sample.FieldAccessionID:
		return m.AccessionID()
	case sample.FieldSampleStorage:
		return m.SampleStorage()
	case sample.FieldTubeCount:
		return m.TubeCount()
	case sample.FieldOrderID:
		return m.OrderID()
	case sample.FieldPatientID:
		return m.PatientID()
	case sample.FieldSampleOrderMethod:
		return m.SampleOrderMethod()
	case sample.FieldSampleCollectionTime:
		return m.SampleCollectionTime()
	case sample.FieldSampleReceivedTime:
		return m.SampleReceivedTime()
	case sample.FieldSampleDescription:
		return m.SampleDescription()
	case sample.FieldDelayedHours:
		return m.DelayedHours()
	case sample.FieldSampleReportTime:
		return m.SampleReportTime()
	case sample.FieldInternalReceivedTime:
		return m.InternalReceivedTime()
	case sample.FieldSampleReportType:
		return m.SampleReportType()
	case sample.FieldCustomerID:
		return m.CustomerID()
	case sample.FieldFastingHours:
		return m.FastingHours()
	case sample.FieldFastingStatus:
		return m.FastingStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SampleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sample.FieldAccessionID:
		return m.OldAccessionID(ctx)
	case sample.FieldSampleStorage:
		return m.OldSampleStorage(ctx)
	case sample.FieldTubeCount:
		return m.OldTubeCount(ctx)
	case sample.FieldOrderID:
		return m.OldOrderID(ctx)
	case sample.FieldPatientID:
		return m.OldPatientID(ctx)
	case sample.FieldSampleOrderMethod:
		return m.OldSampleOrderMethod(ctx)
	case sample.FieldSampleCollectionTime:
		return m.OldSampleCollectionTime(ctx)
	case sample.FieldSampleReceivedTime:
		return m.OldSampleReceivedTime(ctx)
	case sample.FieldSampleDescription:
		return m.OldSampleDescription(ctx)
	case sample.FieldDelayedHours:
		return m.OldDelayedHours(ctx)
	case sample.FieldSampleReportTime:
		return m.OldSampleReportTime(ctx)
	case sample.FieldInternalReceivedTime:
		return m.OldInternalReceivedTime(ctx)
	case sample.FieldSampleReportType:
		return m.OldSampleReportType(ctx)
	case sample.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case sample.FieldFastingHours:
		return m.OldFastingHours(ctx)
	case sample.FieldFastingStatus:
		return m.OldFastingStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Sample field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sample.FieldAccessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessionID(v)
		return nil
	case sample.FieldSampleStorage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleStorage(v)
		return nil
	case sample.FieldTubeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeCount(v)
		return nil
	case sample.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case sample.FieldPatientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case sample.FieldSampleOrderMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleOrderMethod(v)
		return nil
	case sample.FieldSampleCollectionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleCollectionTime(v)
		return nil
	case sample.FieldSampleReceivedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleReceivedTime(v)
		return nil
	case sample.FieldSampleDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleDescription(v)
		return nil
	case sample.FieldDelayedHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelayedHours(v)
		return nil
	case sample.FieldSampleReportTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleReportTime(v)
		return nil
	case sample.FieldInternalReceivedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalReceivedTime(v)
		return nil
	case sample.FieldSampleReportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleReportType(v)
		return nil
	case sample.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case sample.FieldFastingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFastingHours(v)
		return nil
	case sample.FieldFastingStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFastingStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Sample field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SampleMutation) AddedFields() []string {
	var fields []string
	if m.addtube_count != nil {
		fields = append(fields, sample.FieldTubeCount)
	}
	if m.adddelayed_hours != nil {
		fields = append(fields, sample.FieldDelayedHours)
	}
	if m.addfasting_hours != nil {
		fields = append(fields, sample.FieldFastingHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SampleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sample.FieldTubeCount:
		return m.AddedTubeCount()
	case sample.FieldDelayedHours:
		return m.AddedDelayedHours()
	case sample.FieldFastingHours:
		return m.AddedFastingHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sample.FieldTubeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTubeCount(v)
		return nil
	case sample.FieldDelayedHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelayedHours(v)
		return nil
	case sample.FieldFastingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFastingHours(v)
		return nil
	}
	return fmt.Errorf("unknown Sample numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SampleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sample.FieldSampleStorage) {
		fields = append(fields, sample.FieldSampleStorage)
	}
	if m.FieldCleared(sample.FieldTubeCount) {
		fields = append(fields, sample.FieldTubeCount)
	}
	if m.FieldCleared(sample.FieldOrderID) {
		fields = append(fields, sample.FieldOrderID)
	}
	if m.FieldCleared(sample.FieldPatientID) {
		fields = append(fields, sample.FieldPatientID)
	}
	if m.FieldCleared(sample.FieldSampleOrderMethod) {
		fields = append(fields, sample.FieldSampleOrderMethod)
	}
	if m.FieldCleared(sample.FieldSampleCollectionTime) {
		fields = append(fields, sample.FieldSampleCollectionTime)
	}
	if m.FieldCleared(sample.FieldSampleReceivedTime) {
		fields = append(fields, sample.FieldSampleReceivedTime)
	}
	if m.FieldCleared(sample.FieldSampleDescription) {
		fields = append(fields, sample.FieldSampleDescription)
	}
	if m.FieldCleared(sample.FieldSampleReportTime) {
		fields = append(fields, sample.FieldSampleReportTime)
	}
	if m.FieldCleared(sample.FieldInternalReceivedTime) {
		fields = append(fields, sample.FieldInternalReceivedTime)
	}
	if m.FieldCleared(sample.FieldSampleReportType) {
		fields = append(fields, sample.FieldSampleReportType)
	}
	if m.FieldCleared(sample.FieldCustomerID) {
		fields = append(fields, sample.FieldCustomerID)
	}
	if m.FieldCleared(sample.FieldFastingHours) {
		fields = append(fields, sample.FieldFastingHours)
	}
	if m.FieldCleared(sample.FieldFastingStatus) {
		fields = append(fields, sample.FieldFastingStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SampleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SampleMutation) ClearField(name string) error {
	switch name {
	case sample.FieldSampleStorage:
		m.ClearSampleStorage()
		return nil
	case sample.FieldTubeCount:
		m.ClearTubeCount()
		return nil
	case sample.FieldOrderID:
		m.ClearOrderID()
		return nil
	case sample.FieldPatientID:
		m.ClearPatientID()
		return nil
	case sample.FieldSampleOrderMethod:
		m.ClearSampleOrderMethod()
		return nil
	case sample.FieldSampleCollectionTime:
		m.ClearSampleCollectionTime()
		return nil
	case sample.FieldSampleReceivedTime:
		m.ClearSampleReceivedTime()
		return nil
	case sample.FieldSampleDescription:
		m.ClearSampleDescription()
		return nil
	case sample.FieldSampleReportTime:
		m.ClearSampleReportTime()
		return nil
	case sample.FieldInternalReceivedTime:
		m.ClearInternalReceivedTime()
		return nil
	case sample.FieldSampleReportType:
		m.ClearSampleReportType()
		return nil
	case sample.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case sample.FieldFastingHours:
		m.ClearFastingHours()
		return nil
	case sample.FieldFastingStatus:
		m.ClearFastingStatus()
		return nil
	}
	return fmt.Errorf("unknown Sample nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SampleMutation) ResetField(name string) error {
	switch name {
	case sample.FieldAccessionID:
		m.ResetAccessionID()
		return nil
	case sample.FieldSampleStorage:
		m.ResetSampleStorage()
		return nil
	case sample.FieldTubeCount:
		m.ResetTubeCount()
		return nil
	case sample.FieldOrderID:
		m.ResetOrderID()
		return nil
	case sample.FieldPatientID:
		m.ResetPatientID()
		return nil
	case sample.FieldSampleOrderMethod:
		m.ResetSampleOrderMethod()
		return nil
	case sample.FieldSampleCollectionTime:
		m.ResetSampleCollectionTime()
		return nil
	case sample.FieldSampleReceivedTime:
		m.ResetSampleReceivedTime()
		return nil
	case sample.FieldSampleDescription:
		m.ResetSampleDescription()
		return nil
	case sample.FieldDelayedHours:
		m.ResetDelayedHours()
		return nil
	case sample.FieldSampleReportTime:
		m.ResetSampleReportTime()
		return nil
	case sample.FieldInternalReceivedTime:
		m.ResetInternalReceivedTime()
		return nil
	case sample.FieldSampleReportType:
		m.ResetSampleReportType()
		return nil
	case sample.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case sample.FieldFastingHours:
		m.ResetFastingHours()
		return nil
	case sample.FieldFastingStatus:
		m.ResetFastingStatus()
		return nil
	}
	return fmt.Errorf("unknown Sample field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SampleMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._order != nil {
		edges = append(edges, sample.EdgeOrder)
	}
	if m.tubes != nil {
		edges = append(edges, sample.EdgeTubes)
	}
	if m.sample_receive_records != nil {
		edges = append(edges, sample.EdgeSampleReceiveRecords)
	}
	if m.sample_required_tubes != nil {
		edges = append(edges, sample.EdgeSampleRequiredTubes)
	}
	if m.patient != nil {
		edges = append(edges, sample.EdgePatient)
	}
	if m.customer != nil {
		edges = append(edges, sample.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SampleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sample.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case sample.EdgeTubes:
		ids := make([]ent.Value, 0, len(m.tubes))
		for id := range m.tubes {
			ids = append(ids, id)
		}
		return ids
	case sample.EdgeSampleReceiveRecords:
		ids := make([]ent.Value, 0, len(m.sample_receive_records))
		for id := range m.sample_receive_records {
			ids = append(ids, id)
		}
		return ids
	case sample.EdgeSampleRequiredTubes:
		ids := make([]ent.Value, 0, len(m.sample_required_tubes))
		for id := range m.sample_required_tubes {
			ids = append(ids, id)
		}
		return ids
	case sample.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case sample.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SampleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtubes != nil {
		edges = append(edges, sample.EdgeTubes)
	}
	if m.removedsample_receive_records != nil {
		edges = append(edges, sample.EdgeSampleReceiveRecords)
	}
	if m.removedsample_required_tubes != nil {
		edges = append(edges, sample.EdgeSampleRequiredTubes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SampleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sample.EdgeTubes:
		ids := make([]ent.Value, 0, len(m.removedtubes))
		for id := range m.removedtubes {
			ids = append(ids, id)
		}
		return ids
	case sample.EdgeSampleReceiveRecords:
		ids := make([]ent.Value, 0, len(m.removedsample_receive_records))
		for id := range m.removedsample_receive_records {
			ids = append(ids, id)
		}
		return ids
	case sample.EdgeSampleRequiredTubes:
		ids := make([]ent.Value, 0, len(m.removedsample_required_tubes))
		for id := range m.removedsample_required_tubes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SampleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_order {
		edges = append(edges, sample.EdgeOrder)
	}
	if m.clearedtubes {
		edges = append(edges, sample.EdgeTubes)
	}
	if m.clearedsample_receive_records {
		edges = append(edges, sample.EdgeSampleReceiveRecords)
	}
	if m.clearedsample_required_tubes {
		edges = append(edges, sample.EdgeSampleRequiredTubes)
	}
	if m.clearedpatient {
		edges = append(edges, sample.EdgePatient)
	}
	if m.clearedcustomer {
		edges = append(edges, sample.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SampleMutation) EdgeCleared(name string) bool {
	switch name {
	case sample.EdgeOrder:
		return m.cleared_order
	case sample.EdgeTubes:
		return m.clearedtubes
	case sample.EdgeSampleReceiveRecords:
		return m.clearedsample_receive_records
	case sample.EdgeSampleRequiredTubes:
		return m.clearedsample_required_tubes
	case sample.EdgePatient:
		return m.clearedpatient
	case sample.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SampleMutation) ClearEdge(name string) error {
	switch name {
	case sample.EdgeOrder:
		m.ClearOrder()
		return nil
	case sample.EdgePatient:
		m.ClearPatient()
		return nil
	case sample.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Sample unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SampleMutation) ResetEdge(name string) error {
	switch name {
	case sample.EdgeOrder:
		m.ResetOrder()
		return nil
	case sample.EdgeTubes:
		m.ResetTubes()
		return nil
	case sample.EdgeSampleReceiveRecords:
		m.ResetSampleReceiveRecords()
		return nil
	case sample.EdgeSampleRequiredTubes:
		m.ResetSampleRequiredTubes()
		return nil
	case sample.EdgePatient:
		m.ResetPatient()
		return nil
	case sample.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown Sample edge %s", name)
}

// SampleIDGenerateMutation represents an operation that mutates the SampleIDGenerate nodes in the graph.
type SampleIDGenerateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	barcode       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SampleIDGenerate, error)
	predicates    []predicate.SampleIDGenerate
}

var _ ent.Mutation = (*SampleIDGenerateMutation)(nil)

// sampleidgenerateOption allows management of the mutation configuration using functional options.
type sampleidgenerateOption func(*SampleIDGenerateMutation)

// newSampleIDGenerateMutation creates new mutation for the SampleIDGenerate entity.
func newSampleIDGenerateMutation(c config, op Op, opts ...sampleidgenerateOption) *SampleIDGenerateMutation {
	m := &SampleIDGenerateMutation{
		config:        c,
		op:            op,
		typ:           TypeSampleIDGenerate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSampleIDGenerateID sets the ID field of the mutation.
func withSampleIDGenerateID(id int) sampleidgenerateOption {
	return func(m *SampleIDGenerateMutation) {
		var (
			err   error
			once  sync.Once
			value *SampleIDGenerate
		)
		m.oldValue = func(ctx context.Context) (*SampleIDGenerate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SampleIDGenerate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSampleIDGenerate sets the old SampleIDGenerate of the mutation.
func withSampleIDGenerate(node *SampleIDGenerate) sampleidgenerateOption {
	return func(m *SampleIDGenerateMutation) {
		m.oldValue = func(context.Context) (*SampleIDGenerate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SampleIDGenerateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SampleIDGenerateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SampleIDGenerate entities.
func (m *SampleIDGenerateMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SampleIDGenerateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SampleIDGenerateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SampleIDGenerate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBarcode sets the "barcode" field.
func (m *SampleIDGenerateMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *SampleIDGenerateMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the SampleIDGenerate entity.
// If the SampleIDGenerate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleIDGenerateMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ClearBarcode clears the value of the "barcode" field.
func (m *SampleIDGenerateMutation) ClearBarcode() {
	m.barcode = nil
	m.clearedFields[sampleidgenerate.FieldBarcode] = struct{}{}
}

// BarcodeCleared returns if the "barcode" field was cleared in this mutation.
func (m *SampleIDGenerateMutation) BarcodeCleared() bool {
	_, ok := m.clearedFields[sampleidgenerate.FieldBarcode]
	return ok
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *SampleIDGenerateMutation) ResetBarcode() {
	m.barcode = nil
	delete(m.clearedFields, sampleidgenerate.FieldBarcode)
}

// Where appends a list predicates to the SampleIDGenerateMutation builder.
func (m *SampleIDGenerateMutation) Where(ps ...predicate.SampleIDGenerate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SampleIDGenerateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SampleIDGenerateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SampleIDGenerate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SampleIDGenerateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SampleIDGenerateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SampleIDGenerate).
func (m *SampleIDGenerateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SampleIDGenerateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.barcode != nil {
		fields = append(fields, sampleidgenerate.FieldBarcode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SampleIDGenerateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sampleidgenerate.FieldBarcode:
		return m.Barcode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SampleIDGenerateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sampleidgenerate.FieldBarcode:
		return m.OldBarcode(ctx)
	}
	return nil, fmt.Errorf("unknown SampleIDGenerate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleIDGenerateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sampleidgenerate.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	}
	return fmt.Errorf("unknown SampleIDGenerate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SampleIDGenerateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SampleIDGenerateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleIDGenerateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SampleIDGenerate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SampleIDGenerateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sampleidgenerate.FieldBarcode) {
		fields = append(fields, sampleidgenerate.FieldBarcode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SampleIDGenerateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SampleIDGenerateMutation) ClearField(name string) error {
	switch name {
	case sampleidgenerate.FieldBarcode:
		m.ClearBarcode()
		return nil
	}
	return fmt.Errorf("unknown SampleIDGenerate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SampleIDGenerateMutation) ResetField(name string) error {
	switch name {
	case sampleidgenerate.FieldBarcode:
		m.ResetBarcode()
		return nil
	}
	return fmt.Errorf("unknown SampleIDGenerate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SampleIDGenerateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SampleIDGenerateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SampleIDGenerateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SampleIDGenerateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SampleIDGenerateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SampleIDGenerateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SampleIDGenerateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SampleIDGenerate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SampleIDGenerateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SampleIDGenerate edge %s", name)
}

// SampleTypeMutation represents an operation that mutates the SampleType nodes in the graph.
type SampleTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	sample_type_name                 *string
	sample_type_code                 *string
	sample_type_enum                 *string
	sample_type_enum_old_lis_request *string
	sample_type_description          *string
	primary_sample_type_group        *string
	is_active                        *bool
	created_time                     *time.Time
	updated_time                     *time.Time
	clearedFields                    map[string]struct{}
	tube_types                       map[int]struct{}
	removedtube_types                map[int]struct{}
	clearedtube_types                bool
	tests                            map[int]struct{}
	removedtests                     map[int]struct{}
	clearedtests                     bool
	done                             bool
	oldValue                         func(context.Context) (*SampleType, error)
	predicates                       []predicate.SampleType
}

var _ ent.Mutation = (*SampleTypeMutation)(nil)

// sampletypeOption allows management of the mutation configuration using functional options.
type sampletypeOption func(*SampleTypeMutation)

// newSampleTypeMutation creates new mutation for the SampleType entity.
func newSampleTypeMutation(c config, op Op, opts ...sampletypeOption) *SampleTypeMutation {
	m := &SampleTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSampleType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSampleTypeID sets the ID field of the mutation.
func withSampleTypeID(id int) sampletypeOption {
	return func(m *SampleTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SampleType
		)
		m.oldValue = func(ctx context.Context) (*SampleType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SampleType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSampleType sets the old SampleType of the mutation.
func withSampleType(node *SampleType) sampletypeOption {
	return func(m *SampleTypeMutation) {
		m.oldValue = func(context.Context) (*SampleType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SampleTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SampleTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SampleType entities.
func (m *SampleTypeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SampleTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SampleTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SampleType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSampleTypeName sets the "sample_type_name" field.
func (m *SampleTypeMutation) SetSampleTypeName(s string) {
	m.sample_type_name = &s
}

// SampleTypeName returns the value of the "sample_type_name" field in the mutation.
func (m *SampleTypeMutation) SampleTypeName() (r string, exists bool) {
	v := m.sample_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleTypeName returns the old "sample_type_name" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldSampleTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleTypeName: %w", err)
	}
	return oldValue.SampleTypeName, nil
}

// ResetSampleTypeName resets all changes to the "sample_type_name" field.
func (m *SampleTypeMutation) ResetSampleTypeName() {
	m.sample_type_name = nil
}

// SetSampleTypeCode sets the "sample_type_code" field.
func (m *SampleTypeMutation) SetSampleTypeCode(s string) {
	m.sample_type_code = &s
}

// SampleTypeCode returns the value of the "sample_type_code" field in the mutation.
func (m *SampleTypeMutation) SampleTypeCode() (r string, exists bool) {
	v := m.sample_type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleTypeCode returns the old "sample_type_code" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldSampleTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleTypeCode: %w", err)
	}
	return oldValue.SampleTypeCode, nil
}

// ResetSampleTypeCode resets all changes to the "sample_type_code" field.
func (m *SampleTypeMutation) ResetSampleTypeCode() {
	m.sample_type_code = nil
}

// SetSampleTypeEnum sets the "sample_type_enum" field.
func (m *SampleTypeMutation) SetSampleTypeEnum(s string) {
	m.sample_type_enum = &s
}

// SampleTypeEnum returns the value of the "sample_type_enum" field in the mutation.
func (m *SampleTypeMutation) SampleTypeEnum() (r string, exists bool) {
	v := m.sample_type_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleTypeEnum returns the old "sample_type_enum" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldSampleTypeEnum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleTypeEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleTypeEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleTypeEnum: %w", err)
	}
	return oldValue.SampleTypeEnum, nil
}

// ClearSampleTypeEnum clears the value of the "sample_type_enum" field.
func (m *SampleTypeMutation) ClearSampleTypeEnum() {
	m.sample_type_enum = nil
	m.clearedFields[sampletype.FieldSampleTypeEnum] = struct{}{}
}

// SampleTypeEnumCleared returns if the "sample_type_enum" field was cleared in this mutation.
func (m *SampleTypeMutation) SampleTypeEnumCleared() bool {
	_, ok := m.clearedFields[sampletype.FieldSampleTypeEnum]
	return ok
}

// ResetSampleTypeEnum resets all changes to the "sample_type_enum" field.
func (m *SampleTypeMutation) ResetSampleTypeEnum() {
	m.sample_type_enum = nil
	delete(m.clearedFields, sampletype.FieldSampleTypeEnum)
}

// SetSampleTypeEnumOldLisRequest sets the "sample_type_enum_old_lis_request" field.
func (m *SampleTypeMutation) SetSampleTypeEnumOldLisRequest(s string) {
	m.sample_type_enum_old_lis_request = &s
}

// SampleTypeEnumOldLisRequest returns the value of the "sample_type_enum_old_lis_request" field in the mutation.
func (m *SampleTypeMutation) SampleTypeEnumOldLisRequest() (r string, exists bool) {
	v := m.sample_type_enum_old_lis_request
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleTypeEnumOldLisRequest returns the old "sample_type_enum_old_lis_request" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldSampleTypeEnumOldLisRequest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleTypeEnumOldLisRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleTypeEnumOldLisRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleTypeEnumOldLisRequest: %w", err)
	}
	return oldValue.SampleTypeEnumOldLisRequest, nil
}

// ClearSampleTypeEnumOldLisRequest clears the value of the "sample_type_enum_old_lis_request" field.
func (m *SampleTypeMutation) ClearSampleTypeEnumOldLisRequest() {
	m.sample_type_enum_old_lis_request = nil
	m.clearedFields[sampletype.FieldSampleTypeEnumOldLisRequest] = struct{}{}
}

// SampleTypeEnumOldLisRequestCleared returns if the "sample_type_enum_old_lis_request" field was cleared in this mutation.
func (m *SampleTypeMutation) SampleTypeEnumOldLisRequestCleared() bool {
	_, ok := m.clearedFields[sampletype.FieldSampleTypeEnumOldLisRequest]
	return ok
}

// ResetSampleTypeEnumOldLisRequest resets all changes to the "sample_type_enum_old_lis_request" field.
func (m *SampleTypeMutation) ResetSampleTypeEnumOldLisRequest() {
	m.sample_type_enum_old_lis_request = nil
	delete(m.clearedFields, sampletype.FieldSampleTypeEnumOldLisRequest)
}

// SetSampleTypeDescription sets the "sample_type_description" field.
func (m *SampleTypeMutation) SetSampleTypeDescription(s string) {
	m.sample_type_description = &s
}

// SampleTypeDescription returns the value of the "sample_type_description" field in the mutation.
func (m *SampleTypeMutation) SampleTypeDescription() (r string, exists bool) {
	v := m.sample_type_description
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleTypeDescription returns the old "sample_type_description" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldSampleTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleTypeDescription: %w", err)
	}
	return oldValue.SampleTypeDescription, nil
}

// ResetSampleTypeDescription resets all changes to the "sample_type_description" field.
func (m *SampleTypeMutation) ResetSampleTypeDescription() {
	m.sample_type_description = nil
}

// SetPrimarySampleTypeGroup sets the "primary_sample_type_group" field.
func (m *SampleTypeMutation) SetPrimarySampleTypeGroup(s string) {
	m.primary_sample_type_group = &s
}

// PrimarySampleTypeGroup returns the value of the "primary_sample_type_group" field in the mutation.
func (m *SampleTypeMutation) PrimarySampleTypeGroup() (r string, exists bool) {
	v := m.primary_sample_type_group
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimarySampleTypeGroup returns the old "primary_sample_type_group" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldPrimarySampleTypeGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimarySampleTypeGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimarySampleTypeGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimarySampleTypeGroup: %w", err)
	}
	return oldValue.PrimarySampleTypeGroup, nil
}

// ResetPrimarySampleTypeGroup resets all changes to the "primary_sample_type_group" field.
func (m *SampleTypeMutation) ResetPrimarySampleTypeGroup() {
	m.primary_sample_type_group = nil
}

// SetIsActive sets the "is_active" field.
func (m *SampleTypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SampleTypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SampleTypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SampleTypeMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SampleTypeMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SampleTypeMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *SampleTypeMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *SampleTypeMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the SampleType entity.
// If the SampleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SampleTypeMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *SampleTypeMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[sampletype.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *SampleTypeMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[sampletype.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *SampleTypeMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, sampletype.FieldUpdatedTime)
}

// AddTubeTypeIDs adds the "tube_types" edge to the TubeType entity by ids.
func (m *SampleTypeMutation) AddTubeTypeIDs(ids ...int) {
	if m.tube_types == nil {
		m.tube_types = make(map[int]struct{})
	}
	for i := range ids {
		m.tube_types[ids[i]] = struct{}{}
	}
}

// ClearTubeTypes clears the "tube_types" edge to the TubeType entity.
func (m *SampleTypeMutation) ClearTubeTypes() {
	m.clearedtube_types = true
}

// TubeTypesCleared reports if the "tube_types" edge to the TubeType entity was cleared.
func (m *SampleTypeMutation) TubeTypesCleared() bool {
	return m.clearedtube_types
}

// RemoveTubeTypeIDs removes the "tube_types" edge to the TubeType entity by IDs.
func (m *SampleTypeMutation) RemoveTubeTypeIDs(ids ...int) {
	if m.removedtube_types == nil {
		m.removedtube_types = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tube_types, ids[i])
		m.removedtube_types[ids[i]] = struct{}{}
	}
}

// RemovedTubeTypes returns the removed IDs of the "tube_types" edge to the TubeType entity.
func (m *SampleTypeMutation) RemovedTubeTypesIDs() (ids []int) {
	for id := range m.removedtube_types {
		ids = append(ids, id)
	}
	return
}

// TubeTypesIDs returns the "tube_types" edge IDs in the mutation.
func (m *SampleTypeMutation) TubeTypesIDs() (ids []int) {
	for id := range m.tube_types {
		ids = append(ids, id)
	}
	return
}

// ResetTubeTypes resets all changes to the "tube_types" edge.
func (m *SampleTypeMutation) ResetTubeTypes() {
	m.tube_types = nil
	m.clearedtube_types = false
	m.removedtube_types = nil
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *SampleTypeMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *SampleTypeMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *SampleTypeMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *SampleTypeMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *SampleTypeMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *SampleTypeMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *SampleTypeMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the SampleTypeMutation builder.
func (m *SampleTypeMutation) Where(ps ...predicate.SampleType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SampleTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SampleTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SampleType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SampleTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SampleTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SampleType).
func (m *SampleTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SampleTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.sample_type_name != nil {
		fields = append(fields, sampletype.FieldSampleTypeName)
	}
	if m.sample_type_code != nil {
		fields = append(fields, sampletype.FieldSampleTypeCode)
	}
	if m.sample_type_enum != nil {
		fields = append(fields, sampletype.FieldSampleTypeEnum)
	}
	if m.sample_type_enum_old_lis_request != nil {
		fields = append(fields, sampletype.FieldSampleTypeEnumOldLisRequest)
	}
	if m.sample_type_description != nil {
		fields = append(fields, sampletype.FieldSampleTypeDescription)
	}
	if m.primary_sample_type_group != nil {
		fields = append(fields, sampletype.FieldPrimarySampleTypeGroup)
	}
	if m.is_active != nil {
		fields = append(fields, sampletype.FieldIsActive)
	}
	if m.created_time != nil {
		fields = append(fields, sampletype.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, sampletype.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SampleTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sampletype.FieldSampleTypeName:
		return m.SampleTypeName()
	case sampletype.FieldSampleTypeCode:
		return m.SampleTypeCode()
	case sampletype.FieldSampleTypeEnum:
		return m.SampleTypeEnum()
	case sampletype.FieldSampleTypeEnumOldLisRequest:
		return m.SampleTypeEnumOldLisRequest()
	case sampletype.FieldSampleTypeDescription:
		return m.SampleTypeDescription()
	case sampletype.FieldPrimarySampleTypeGroup:
		return m.PrimarySampleTypeGroup()
	case sampletype.FieldIsActive:
		return m.IsActive()
	case sampletype.FieldCreatedTime:
		return m.CreatedTime()
	case sampletype.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SampleTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sampletype.FieldSampleTypeName:
		return m.OldSampleTypeName(ctx)
	case sampletype.FieldSampleTypeCode:
		return m.OldSampleTypeCode(ctx)
	case sampletype.FieldSampleTypeEnum:
		return m.OldSampleTypeEnum(ctx)
	case sampletype.FieldSampleTypeEnumOldLisRequest:
		return m.OldSampleTypeEnumOldLisRequest(ctx)
	case sampletype.FieldSampleTypeDescription:
		return m.OldSampleTypeDescription(ctx)
	case sampletype.FieldPrimarySampleTypeGroup:
		return m.OldPrimarySampleTypeGroup(ctx)
	case sampletype.FieldIsActive:
		return m.OldIsActive(ctx)
	case sampletype.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case sampletype.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SampleType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sampletype.FieldSampleTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleTypeName(v)
		return nil
	case sampletype.FieldSampleTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleTypeCode(v)
		return nil
	case sampletype.FieldSampleTypeEnum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleTypeEnum(v)
		return nil
	case sampletype.FieldSampleTypeEnumOldLisRequest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleTypeEnumOldLisRequest(v)
		return nil
	case sampletype.FieldSampleTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleTypeDescription(v)
		return nil
	case sampletype.FieldPrimarySampleTypeGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimarySampleTypeGroup(v)
		return nil
	case sampletype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case sampletype.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case sampletype.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SampleType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SampleTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SampleTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SampleTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SampleType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SampleTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sampletype.FieldSampleTypeEnum) {
		fields = append(fields, sampletype.FieldSampleTypeEnum)
	}
	if m.FieldCleared(sampletype.FieldSampleTypeEnumOldLisRequest) {
		fields = append(fields, sampletype.FieldSampleTypeEnumOldLisRequest)
	}
	if m.FieldCleared(sampletype.FieldUpdatedTime) {
		fields = append(fields, sampletype.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SampleTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SampleTypeMutation) ClearField(name string) error {
	switch name {
	case sampletype.FieldSampleTypeEnum:
		m.ClearSampleTypeEnum()
		return nil
	case sampletype.FieldSampleTypeEnumOldLisRequest:
		m.ClearSampleTypeEnumOldLisRequest()
		return nil
	case sampletype.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SampleTypeMutation) ResetField(name string) error {
	switch name {
	case sampletype.FieldSampleTypeName:
		m.ResetSampleTypeName()
		return nil
	case sampletype.FieldSampleTypeCode:
		m.ResetSampleTypeCode()
		return nil
	case sampletype.FieldSampleTypeEnum:
		m.ResetSampleTypeEnum()
		return nil
	case sampletype.FieldSampleTypeEnumOldLisRequest:
		m.ResetSampleTypeEnumOldLisRequest()
		return nil
	case sampletype.FieldSampleTypeDescription:
		m.ResetSampleTypeDescription()
		return nil
	case sampletype.FieldPrimarySampleTypeGroup:
		m.ResetPrimarySampleTypeGroup()
		return nil
	case sampletype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case sampletype.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case sampletype.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown SampleType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SampleTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tube_types != nil {
		edges = append(edges, sampletype.EdgeTubeTypes)
	}
	if m.tests != nil {
		edges = append(edges, sampletype.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SampleTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sampletype.EdgeTubeTypes:
		ids := make([]ent.Value, 0, len(m.tube_types))
		for id := range m.tube_types {
			ids = append(ids, id)
		}
		return ids
	case sampletype.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SampleTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtube_types != nil {
		edges = append(edges, sampletype.EdgeTubeTypes)
	}
	if m.removedtests != nil {
		edges = append(edges, sampletype.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SampleTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sampletype.EdgeTubeTypes:
		ids := make([]ent.Value, 0, len(m.removedtube_types))
		for id := range m.removedtube_types {
			ids = append(ids, id)
		}
		return ids
	case sampletype.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SampleTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtube_types {
		edges = append(edges, sampletype.EdgeTubeTypes)
	}
	if m.clearedtests {
		edges = append(edges, sampletype.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SampleTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case sampletype.EdgeTubeTypes:
		return m.clearedtube_types
	case sampletype.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SampleTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SampleType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SampleTypeMutation) ResetEdge(name string) error {
	switch name {
	case sampletype.EdgeTubeTypes:
		m.ResetTubeTypes()
		return nil
	case sampletype.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown SampleType edge %s", name)
}

// ServiceshipMutation represents an operation that mutates the Serviceship nodes in the graph.
type ServiceshipMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	tag                             *string
	_type                           *serviceship.Type
	clearedFields                   map[string]struct{}
	serviceship_billing_plan        map[int]struct{}
	removedserviceship_billing_plan map[int]struct{}
	clearedserviceship_billing_plan bool
	account_subscription            map[int]struct{}
	removedaccount_subscription     map[int]struct{}
	clearedaccount_subscription     bool
	done                            bool
	oldValue                        func(context.Context) (*Serviceship, error)
	predicates                      []predicate.Serviceship
}

var _ ent.Mutation = (*ServiceshipMutation)(nil)

// serviceshipOption allows management of the mutation configuration using functional options.
type serviceshipOption func(*ServiceshipMutation)

// newServiceshipMutation creates new mutation for the Serviceship entity.
func newServiceshipMutation(c config, op Op, opts ...serviceshipOption) *ServiceshipMutation {
	m := &ServiceshipMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceshipID sets the ID field of the mutation.
func withServiceshipID(id int) serviceshipOption {
	return func(m *ServiceshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Serviceship
		)
		m.oldValue = func(ctx context.Context) (*Serviceship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Serviceship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceship sets the old Serviceship of the mutation.
func withServiceship(node *Serviceship) serviceshipOption {
	return func(m *ServiceshipMutation) {
		m.oldValue = func(context.Context) (*Serviceship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Serviceship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTag sets the "tag" field.
func (m *ServiceshipMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *ServiceshipMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Serviceship entity.
// If the Serviceship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *ServiceshipMutation) ResetTag() {
	m.tag = nil
}

// SetType sets the "type" field.
func (m *ServiceshipMutation) SetType(s serviceship.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceshipMutation) GetType() (r serviceship.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Serviceship entity.
// If the Serviceship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipMutation) OldType(ctx context.Context) (v serviceship.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceshipMutation) ResetType() {
	m._type = nil
}

// AddServiceshipBillingPlanIDs adds the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity by ids.
func (m *ServiceshipMutation) AddServiceshipBillingPlanIDs(ids ...int) {
	if m.serviceship_billing_plan == nil {
		m.serviceship_billing_plan = make(map[int]struct{})
	}
	for i := range ids {
		m.serviceship_billing_plan[ids[i]] = struct{}{}
	}
}

// ClearServiceshipBillingPlan clears the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity.
func (m *ServiceshipMutation) ClearServiceshipBillingPlan() {
	m.clearedserviceship_billing_plan = true
}

// ServiceshipBillingPlanCleared reports if the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity was cleared.
func (m *ServiceshipMutation) ServiceshipBillingPlanCleared() bool {
	return m.clearedserviceship_billing_plan
}

// RemoveServiceshipBillingPlanIDs removes the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity by IDs.
func (m *ServiceshipMutation) RemoveServiceshipBillingPlanIDs(ids ...int) {
	if m.removedserviceship_billing_plan == nil {
		m.removedserviceship_billing_plan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serviceship_billing_plan, ids[i])
		m.removedserviceship_billing_plan[ids[i]] = struct{}{}
	}
}

// RemovedServiceshipBillingPlan returns the removed IDs of the "serviceship_billing_plan" edge to the ServiceshipBillingPlan entity.
func (m *ServiceshipMutation) RemovedServiceshipBillingPlanIDs() (ids []int) {
	for id := range m.removedserviceship_billing_plan {
		ids = append(ids, id)
	}
	return
}

// ServiceshipBillingPlanIDs returns the "serviceship_billing_plan" edge IDs in the mutation.
func (m *ServiceshipMutation) ServiceshipBillingPlanIDs() (ids []int) {
	for id := range m.serviceship_billing_plan {
		ids = append(ids, id)
	}
	return
}

// ResetServiceshipBillingPlan resets all changes to the "serviceship_billing_plan" edge.
func (m *ServiceshipMutation) ResetServiceshipBillingPlan() {
	m.serviceship_billing_plan = nil
	m.clearedserviceship_billing_plan = false
	m.removedserviceship_billing_plan = nil
}

// AddAccountSubscriptionIDs adds the "account_subscription" edge to the AccountSubscription entity by ids.
func (m *ServiceshipMutation) AddAccountSubscriptionIDs(ids ...int) {
	if m.account_subscription == nil {
		m.account_subscription = make(map[int]struct{})
	}
	for i := range ids {
		m.account_subscription[ids[i]] = struct{}{}
	}
}

// ClearAccountSubscription clears the "account_subscription" edge to the AccountSubscription entity.
func (m *ServiceshipMutation) ClearAccountSubscription() {
	m.clearedaccount_subscription = true
}

// AccountSubscriptionCleared reports if the "account_subscription" edge to the AccountSubscription entity was cleared.
func (m *ServiceshipMutation) AccountSubscriptionCleared() bool {
	return m.clearedaccount_subscription
}

// RemoveAccountSubscriptionIDs removes the "account_subscription" edge to the AccountSubscription entity by IDs.
func (m *ServiceshipMutation) RemoveAccountSubscriptionIDs(ids ...int) {
	if m.removedaccount_subscription == nil {
		m.removedaccount_subscription = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_subscription, ids[i])
		m.removedaccount_subscription[ids[i]] = struct{}{}
	}
}

// RemovedAccountSubscription returns the removed IDs of the "account_subscription" edge to the AccountSubscription entity.
func (m *ServiceshipMutation) RemovedAccountSubscriptionIDs() (ids []int) {
	for id := range m.removedaccount_subscription {
		ids = append(ids, id)
	}
	return
}

// AccountSubscriptionIDs returns the "account_subscription" edge IDs in the mutation.
func (m *ServiceshipMutation) AccountSubscriptionIDs() (ids []int) {
	for id := range m.account_subscription {
		ids = append(ids, id)
	}
	return
}

// ResetAccountSubscription resets all changes to the "account_subscription" edge.
func (m *ServiceshipMutation) ResetAccountSubscription() {
	m.account_subscription = nil
	m.clearedaccount_subscription = false
	m.removedaccount_subscription = nil
}

// Where appends a list predicates to the ServiceshipMutation builder.
func (m *ServiceshipMutation) Where(ps ...predicate.Serviceship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Serviceship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Serviceship).
func (m *ServiceshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceshipMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tag != nil {
		fields = append(fields, serviceship.FieldTag)
	}
	if m._type != nil {
		fields = append(fields, serviceship.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceship.FieldTag:
		return m.Tag()
	case serviceship.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceship.FieldTag:
		return m.OldTag(ctx)
	case serviceship.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Serviceship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceship.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case serviceship.FieldType:
		v, ok := value.(serviceship.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Serviceship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Serviceship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Serviceship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceshipMutation) ResetField(name string) error {
	switch name {
	case serviceship.FieldTag:
		m.ResetTag()
		return nil
	case serviceship.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Serviceship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.serviceship_billing_plan != nil {
		edges = append(edges, serviceship.EdgeServiceshipBillingPlan)
	}
	if m.account_subscription != nil {
		edges = append(edges, serviceship.EdgeAccountSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceship.EdgeServiceshipBillingPlan:
		ids := make([]ent.Value, 0, len(m.serviceship_billing_plan))
		for id := range m.serviceship_billing_plan {
			ids = append(ids, id)
		}
		return ids
	case serviceship.EdgeAccountSubscription:
		ids := make([]ent.Value, 0, len(m.account_subscription))
		for id := range m.account_subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedserviceship_billing_plan != nil {
		edges = append(edges, serviceship.EdgeServiceshipBillingPlan)
	}
	if m.removedaccount_subscription != nil {
		edges = append(edges, serviceship.EdgeAccountSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceship.EdgeServiceshipBillingPlan:
		ids := make([]ent.Value, 0, len(m.removedserviceship_billing_plan))
		for id := range m.removedserviceship_billing_plan {
			ids = append(ids, id)
		}
		return ids
	case serviceship.EdgeAccountSubscription:
		ids := make([]ent.Value, 0, len(m.removedaccount_subscription))
		for id := range m.removedaccount_subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserviceship_billing_plan {
		edges = append(edges, serviceship.EdgeServiceshipBillingPlan)
	}
	if m.clearedaccount_subscription {
		edges = append(edges, serviceship.EdgeAccountSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceshipMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceship.EdgeServiceshipBillingPlan:
		return m.clearedserviceship_billing_plan
	case serviceship.EdgeAccountSubscription:
		return m.clearedaccount_subscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceshipMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Serviceship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceshipMutation) ResetEdge(name string) error {
	switch name {
	case serviceship.EdgeServiceshipBillingPlan:
		m.ResetServiceshipBillingPlan()
		return nil
	case serviceship.EdgeAccountSubscription:
		m.ResetAccountSubscription()
		return nil
	}
	return fmt.Errorf("unknown Serviceship edge %s", name)
}

// ServiceshipBillingPlanMutation represents an operation that mutates the ServiceshipBillingPlan nodes in the graph.
type ServiceshipBillingPlanMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	fee                         *float32
	addfee                      *float32
	billing_cycle               *int32
	addbilling_cycle            *int32
	interval                    *serviceshipbillingplan.Interval
	effective_time              *time.Time
	clearedFields               map[string]struct{}
	account_subscription        map[int]struct{}
	removedaccount_subscription map[int]struct{}
	clearedaccount_subscription bool
	serviceship                 *int
	clearedserviceship          bool
	done                        bool
	oldValue                    func(context.Context) (*ServiceshipBillingPlan, error)
	predicates                  []predicate.ServiceshipBillingPlan
}

var _ ent.Mutation = (*ServiceshipBillingPlanMutation)(nil)

// serviceshipbillingplanOption allows management of the mutation configuration using functional options.
type serviceshipbillingplanOption func(*ServiceshipBillingPlanMutation)

// newServiceshipBillingPlanMutation creates new mutation for the ServiceshipBillingPlan entity.
func newServiceshipBillingPlanMutation(c config, op Op, opts ...serviceshipbillingplanOption) *ServiceshipBillingPlanMutation {
	m := &ServiceshipBillingPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceshipBillingPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceshipBillingPlanID sets the ID field of the mutation.
func withServiceshipBillingPlanID(id int) serviceshipbillingplanOption {
	return func(m *ServiceshipBillingPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceshipBillingPlan
		)
		m.oldValue = func(ctx context.Context) (*ServiceshipBillingPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceshipBillingPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceshipBillingPlan sets the old ServiceshipBillingPlan of the mutation.
func withServiceshipBillingPlan(node *ServiceshipBillingPlan) serviceshipbillingplanOption {
	return func(m *ServiceshipBillingPlanMutation) {
		m.oldValue = func(context.Context) (*ServiceshipBillingPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceshipBillingPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceshipBillingPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceshipBillingPlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceshipBillingPlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceshipBillingPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFee sets the "fee" field.
func (m *ServiceshipBillingPlanMutation) SetFee(f float32) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ServiceshipBillingPlanMutation) Fee() (r float32, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the ServiceshipBillingPlan entity.
// If the ServiceshipBillingPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipBillingPlanMutation) OldFee(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ServiceshipBillingPlanMutation) AddFee(f float32) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ServiceshipBillingPlanMutation) AddedFee() (r float32, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *ServiceshipBillingPlanMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetBillingCycle sets the "billing_cycle" field.
func (m *ServiceshipBillingPlanMutation) SetBillingCycle(i int32) {
	m.billing_cycle = &i
	m.addbilling_cycle = nil
}

// BillingCycle returns the value of the "billing_cycle" field in the mutation.
func (m *ServiceshipBillingPlanMutation) BillingCycle() (r int32, exists bool) {
	v := m.billing_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCycle returns the old "billing_cycle" field's value of the ServiceshipBillingPlan entity.
// If the ServiceshipBillingPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipBillingPlanMutation) OldBillingCycle(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCycle: %w", err)
	}
	return oldValue.BillingCycle, nil
}

// AddBillingCycle adds i to the "billing_cycle" field.
func (m *ServiceshipBillingPlanMutation) AddBillingCycle(i int32) {
	if m.addbilling_cycle != nil {
		*m.addbilling_cycle += i
	} else {
		m.addbilling_cycle = &i
	}
}

// AddedBillingCycle returns the value that was added to the "billing_cycle" field in this mutation.
func (m *ServiceshipBillingPlanMutation) AddedBillingCycle() (r int32, exists bool) {
	v := m.addbilling_cycle
	if v == nil {
		return
	}
	return *v, true
}

// ResetBillingCycle resets all changes to the "billing_cycle" field.
func (m *ServiceshipBillingPlanMutation) ResetBillingCycle() {
	m.billing_cycle = nil
	m.addbilling_cycle = nil
}

// SetInterval sets the "interval" field.
func (m *ServiceshipBillingPlanMutation) SetInterval(s serviceshipbillingplan.Interval) {
	m.interval = &s
}

// Interval returns the value of the "interval" field in the mutation.
func (m *ServiceshipBillingPlanMutation) Interval() (r serviceshipbillingplan.Interval, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the ServiceshipBillingPlan entity.
// If the ServiceshipBillingPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipBillingPlanMutation) OldInterval(ctx context.Context) (v serviceshipbillingplan.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ResetInterval resets all changes to the "interval" field.
func (m *ServiceshipBillingPlanMutation) ResetInterval() {
	m.interval = nil
}

// SetEffectiveTime sets the "effective_time" field.
func (m *ServiceshipBillingPlanMutation) SetEffectiveTime(t time.Time) {
	m.effective_time = &t
}

// EffectiveTime returns the value of the "effective_time" field in the mutation.
func (m *ServiceshipBillingPlanMutation) EffectiveTime() (r time.Time, exists bool) {
	v := m.effective_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTime returns the old "effective_time" field's value of the ServiceshipBillingPlan entity.
// If the ServiceshipBillingPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceshipBillingPlanMutation) OldEffectiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTime: %w", err)
	}
	return oldValue.EffectiveTime, nil
}

// ResetEffectiveTime resets all changes to the "effective_time" field.
func (m *ServiceshipBillingPlanMutation) ResetEffectiveTime() {
	m.effective_time = nil
}

// AddAccountSubscriptionIDs adds the "account_subscription" edge to the AccountSubscription entity by ids.
func (m *ServiceshipBillingPlanMutation) AddAccountSubscriptionIDs(ids ...int) {
	if m.account_subscription == nil {
		m.account_subscription = make(map[int]struct{})
	}
	for i := range ids {
		m.account_subscription[ids[i]] = struct{}{}
	}
}

// ClearAccountSubscription clears the "account_subscription" edge to the AccountSubscription entity.
func (m *ServiceshipBillingPlanMutation) ClearAccountSubscription() {
	m.clearedaccount_subscription = true
}

// AccountSubscriptionCleared reports if the "account_subscription" edge to the AccountSubscription entity was cleared.
func (m *ServiceshipBillingPlanMutation) AccountSubscriptionCleared() bool {
	return m.clearedaccount_subscription
}

// RemoveAccountSubscriptionIDs removes the "account_subscription" edge to the AccountSubscription entity by IDs.
func (m *ServiceshipBillingPlanMutation) RemoveAccountSubscriptionIDs(ids ...int) {
	if m.removedaccount_subscription == nil {
		m.removedaccount_subscription = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_subscription, ids[i])
		m.removedaccount_subscription[ids[i]] = struct{}{}
	}
}

// RemovedAccountSubscription returns the removed IDs of the "account_subscription" edge to the AccountSubscription entity.
func (m *ServiceshipBillingPlanMutation) RemovedAccountSubscriptionIDs() (ids []int) {
	for id := range m.removedaccount_subscription {
		ids = append(ids, id)
	}
	return
}

// AccountSubscriptionIDs returns the "account_subscription" edge IDs in the mutation.
func (m *ServiceshipBillingPlanMutation) AccountSubscriptionIDs() (ids []int) {
	for id := range m.account_subscription {
		ids = append(ids, id)
	}
	return
}

// ResetAccountSubscription resets all changes to the "account_subscription" edge.
func (m *ServiceshipBillingPlanMutation) ResetAccountSubscription() {
	m.account_subscription = nil
	m.clearedaccount_subscription = false
	m.removedaccount_subscription = nil
}

// SetServiceshipID sets the "serviceship" edge to the Serviceship entity by id.
func (m *ServiceshipBillingPlanMutation) SetServiceshipID(id int) {
	m.serviceship = &id
}

// ClearServiceship clears the "serviceship" edge to the Serviceship entity.
func (m *ServiceshipBillingPlanMutation) ClearServiceship() {
	m.clearedserviceship = true
}

// ServiceshipCleared reports if the "serviceship" edge to the Serviceship entity was cleared.
func (m *ServiceshipBillingPlanMutation) ServiceshipCleared() bool {
	return m.clearedserviceship
}

// ServiceshipID returns the "serviceship" edge ID in the mutation.
func (m *ServiceshipBillingPlanMutation) ServiceshipID() (id int, exists bool) {
	if m.serviceship != nil {
		return *m.serviceship, true
	}
	return
}

// ServiceshipIDs returns the "serviceship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceshipID instead. It exists only for internal usage by the builders.
func (m *ServiceshipBillingPlanMutation) ServiceshipIDs() (ids []int) {
	if id := m.serviceship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceship resets all changes to the "serviceship" edge.
func (m *ServiceshipBillingPlanMutation) ResetServiceship() {
	m.serviceship = nil
	m.clearedserviceship = false
}

// Where appends a list predicates to the ServiceshipBillingPlanMutation builder.
func (m *ServiceshipBillingPlanMutation) Where(ps ...predicate.ServiceshipBillingPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceshipBillingPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceshipBillingPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceshipBillingPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceshipBillingPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceshipBillingPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceshipBillingPlan).
func (m *ServiceshipBillingPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceshipBillingPlanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.fee != nil {
		fields = append(fields, serviceshipbillingplan.FieldFee)
	}
	if m.billing_cycle != nil {
		fields = append(fields, serviceshipbillingplan.FieldBillingCycle)
	}
	if m.interval != nil {
		fields = append(fields, serviceshipbillingplan.FieldInterval)
	}
	if m.effective_time != nil {
		fields = append(fields, serviceshipbillingplan.FieldEffectiveTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceshipBillingPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceshipbillingplan.FieldFee:
		return m.Fee()
	case serviceshipbillingplan.FieldBillingCycle:
		return m.BillingCycle()
	case serviceshipbillingplan.FieldInterval:
		return m.Interval()
	case serviceshipbillingplan.FieldEffectiveTime:
		return m.EffectiveTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceshipBillingPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceshipbillingplan.FieldFee:
		return m.OldFee(ctx)
	case serviceshipbillingplan.FieldBillingCycle:
		return m.OldBillingCycle(ctx)
	case serviceshipbillingplan.FieldInterval:
		return m.OldInterval(ctx)
	case serviceshipbillingplan.FieldEffectiveTime:
		return m.OldEffectiveTime(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceshipBillingPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceshipBillingPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceshipbillingplan.FieldFee:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case serviceshipbillingplan.FieldBillingCycle:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCycle(v)
		return nil
	case serviceshipbillingplan.FieldInterval:
		v, ok := value.(serviceshipbillingplan.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case serviceshipbillingplan.FieldEffectiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTime(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceshipBillingPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceshipBillingPlanMutation) AddedFields() []string {
	var fields []string
	if m.addfee != nil {
		fields = append(fields, serviceshipbillingplan.FieldFee)
	}
	if m.addbilling_cycle != nil {
		fields = append(fields, serviceshipbillingplan.FieldBillingCycle)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceshipBillingPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceshipbillingplan.FieldFee:
		return m.AddedFee()
	case serviceshipbillingplan.FieldBillingCycle:
		return m.AddedBillingCycle()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceshipBillingPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceshipbillingplan.FieldFee:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case serviceshipbillingplan.FieldBillingCycle:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBillingCycle(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceshipBillingPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceshipBillingPlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceshipBillingPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceshipBillingPlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceshipBillingPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceshipBillingPlanMutation) ResetField(name string) error {
	switch name {
	case serviceshipbillingplan.FieldFee:
		m.ResetFee()
		return nil
	case serviceshipbillingplan.FieldBillingCycle:
		m.ResetBillingCycle()
		return nil
	case serviceshipbillingplan.FieldInterval:
		m.ResetInterval()
		return nil
	case serviceshipbillingplan.FieldEffectiveTime:
		m.ResetEffectiveTime()
		return nil
	}
	return fmt.Errorf("unknown ServiceshipBillingPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceshipBillingPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account_subscription != nil {
		edges = append(edges, serviceshipbillingplan.EdgeAccountSubscription)
	}
	if m.serviceship != nil {
		edges = append(edges, serviceshipbillingplan.EdgeServiceship)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceshipBillingPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceshipbillingplan.EdgeAccountSubscription:
		ids := make([]ent.Value, 0, len(m.account_subscription))
		for id := range m.account_subscription {
			ids = append(ids, id)
		}
		return ids
	case serviceshipbillingplan.EdgeServiceship:
		if id := m.serviceship; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceshipBillingPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccount_subscription != nil {
		edges = append(edges, serviceshipbillingplan.EdgeAccountSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceshipBillingPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceshipbillingplan.EdgeAccountSubscription:
		ids := make([]ent.Value, 0, len(m.removedaccount_subscription))
		for id := range m.removedaccount_subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceshipBillingPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount_subscription {
		edges = append(edges, serviceshipbillingplan.EdgeAccountSubscription)
	}
	if m.clearedserviceship {
		edges = append(edges, serviceshipbillingplan.EdgeServiceship)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceshipBillingPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceshipbillingplan.EdgeAccountSubscription:
		return m.clearedaccount_subscription
	case serviceshipbillingplan.EdgeServiceship:
		return m.clearedserviceship
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceshipBillingPlanMutation) ClearEdge(name string) error {
	switch name {
	case serviceshipbillingplan.EdgeServiceship:
		m.ClearServiceship()
		return nil
	}
	return fmt.Errorf("unknown ServiceshipBillingPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceshipBillingPlanMutation) ResetEdge(name string) error {
	switch name {
	case serviceshipbillingplan.EdgeAccountSubscription:
		m.ResetAccountSubscription()
		return nil
	case serviceshipbillingplan.EdgeServiceship:
		m.ResetServiceship()
		return nil
	}
	return fmt.Errorf("unknown ServiceshipBillingPlan edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	setting_name               *string
	setting_group              *string
	setting_description        *string
	setting_value              *string
	setting_type               *string
	setting_value_updated_time *time.Time
	is_active                  *bool
	apply_to_all_group_member  *bool
	is_official                *bool
	setting_level              *int
	addsetting_level           *int
	setting_level_name         *string
	use_group_setting          *bool
	clearedFields              map[string]struct{}
	clinics                    map[int]struct{}
	removedclinics             map[int]struct{}
	clearedclinics             bool
	internal_users             map[int]struct{}
	removedinternal_users      map[int]struct{}
	clearedinternal_users      bool
	patients                   map[int]struct{}
	removedpatients            map[int]struct{}
	clearedpatients            bool
	clinic_customers           map[int]struct{}
	removedclinic_customers    map[int]struct{}
	clearedclinic_customers    bool
	done                       bool
	oldValue                   func(context.Context) (*Setting, error)
	predicates                 []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSettingName sets the "setting_name" field.
func (m *SettingMutation) SetSettingName(s string) {
	m.setting_name = &s
}

// SettingName returns the value of the "setting_name" field in the mutation.
func (m *SettingMutation) SettingName() (r string, exists bool) {
	v := m.setting_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingName returns the old "setting_name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingName: %w", err)
	}
	return oldValue.SettingName, nil
}

// ResetSettingName resets all changes to the "setting_name" field.
func (m *SettingMutation) ResetSettingName() {
	m.setting_name = nil
}

// SetSettingGroup sets the "setting_group" field.
func (m *SettingMutation) SetSettingGroup(s string) {
	m.setting_group = &s
}

// SettingGroup returns the value of the "setting_group" field in the mutation.
func (m *SettingMutation) SettingGroup() (r string, exists bool) {
	v := m.setting_group
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingGroup returns the old "setting_group" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingGroup: %w", err)
	}
	return oldValue.SettingGroup, nil
}

// ResetSettingGroup resets all changes to the "setting_group" field.
func (m *SettingMutation) ResetSettingGroup() {
	m.setting_group = nil
}

// SetSettingDescription sets the "setting_description" field.
func (m *SettingMutation) SetSettingDescription(s string) {
	m.setting_description = &s
}

// SettingDescription returns the value of the "setting_description" field in the mutation.
func (m *SettingMutation) SettingDescription() (r string, exists bool) {
	v := m.setting_description
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingDescription returns the old "setting_description" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingDescription: %w", err)
	}
	return oldValue.SettingDescription, nil
}

// ResetSettingDescription resets all changes to the "setting_description" field.
func (m *SettingMutation) ResetSettingDescription() {
	m.setting_description = nil
}

// SetSettingValue sets the "setting_value" field.
func (m *SettingMutation) SetSettingValue(s string) {
	m.setting_value = &s
}

// SettingValue returns the value of the "setting_value" field in the mutation.
func (m *SettingMutation) SettingValue() (r string, exists bool) {
	v := m.setting_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingValue returns the old "setting_value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingValue: %w", err)
	}
	return oldValue.SettingValue, nil
}

// ClearSettingValue clears the value of the "setting_value" field.
func (m *SettingMutation) ClearSettingValue() {
	m.setting_value = nil
	m.clearedFields[setting.FieldSettingValue] = struct{}{}
}

// SettingValueCleared returns if the "setting_value" field was cleared in this mutation.
func (m *SettingMutation) SettingValueCleared() bool {
	_, ok := m.clearedFields[setting.FieldSettingValue]
	return ok
}

// ResetSettingValue resets all changes to the "setting_value" field.
func (m *SettingMutation) ResetSettingValue() {
	m.setting_value = nil
	delete(m.clearedFields, setting.FieldSettingValue)
}

// SetSettingType sets the "setting_type" field.
func (m *SettingMutation) SetSettingType(s string) {
	m.setting_type = &s
}

// SettingType returns the value of the "setting_type" field in the mutation.
func (m *SettingMutation) SettingType() (r string, exists bool) {
	v := m.setting_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingType returns the old "setting_type" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingType: %w", err)
	}
	return oldValue.SettingType, nil
}

// ResetSettingType resets all changes to the "setting_type" field.
func (m *SettingMutation) ResetSettingType() {
	m.setting_type = nil
}

// SetSettingValueUpdatedTime sets the "setting_value_updated_time" field.
func (m *SettingMutation) SetSettingValueUpdatedTime(t time.Time) {
	m.setting_value_updated_time = &t
}

// SettingValueUpdatedTime returns the value of the "setting_value_updated_time" field in the mutation.
func (m *SettingMutation) SettingValueUpdatedTime() (r time.Time, exists bool) {
	v := m.setting_value_updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingValueUpdatedTime returns the old "setting_value_updated_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingValueUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingValueUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingValueUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingValueUpdatedTime: %w", err)
	}
	return oldValue.SettingValueUpdatedTime, nil
}

// ResetSettingValueUpdatedTime resets all changes to the "setting_value_updated_time" field.
func (m *SettingMutation) ResetSettingValueUpdatedTime() {
	m.setting_value_updated_time = nil
}

// SetIsActive sets the "is_active" field.
func (m *SettingMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SettingMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SettingMutation) ResetIsActive() {
	m.is_active = nil
}

// SetApplyToAllGroupMember sets the "apply_to_all_group_member" field.
func (m *SettingMutation) SetApplyToAllGroupMember(b bool) {
	m.apply_to_all_group_member = &b
}

// ApplyToAllGroupMember returns the value of the "apply_to_all_group_member" field in the mutation.
func (m *SettingMutation) ApplyToAllGroupMember() (r bool, exists bool) {
	v := m.apply_to_all_group_member
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyToAllGroupMember returns the old "apply_to_all_group_member" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldApplyToAllGroupMember(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyToAllGroupMember is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyToAllGroupMember requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyToAllGroupMember: %w", err)
	}
	return oldValue.ApplyToAllGroupMember, nil
}

// ResetApplyToAllGroupMember resets all changes to the "apply_to_all_group_member" field.
func (m *SettingMutation) ResetApplyToAllGroupMember() {
	m.apply_to_all_group_member = nil
}

// SetIsOfficial sets the "is_official" field.
func (m *SettingMutation) SetIsOfficial(b bool) {
	m.is_official = &b
}

// IsOfficial returns the value of the "is_official" field in the mutation.
func (m *SettingMutation) IsOfficial() (r bool, exists bool) {
	v := m.is_official
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOfficial returns the old "is_official" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldIsOfficial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOfficial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOfficial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOfficial: %w", err)
	}
	return oldValue.IsOfficial, nil
}

// ResetIsOfficial resets all changes to the "is_official" field.
func (m *SettingMutation) ResetIsOfficial() {
	m.is_official = nil
}

// SetSettingLevel sets the "setting_level" field.
func (m *SettingMutation) SetSettingLevel(i int) {
	m.setting_level = &i
	m.addsetting_level = nil
}

// SettingLevel returns the value of the "setting_level" field in the mutation.
func (m *SettingMutation) SettingLevel() (r int, exists bool) {
	v := m.setting_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingLevel returns the old "setting_level" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingLevel: %w", err)
	}
	return oldValue.SettingLevel, nil
}

// AddSettingLevel adds i to the "setting_level" field.
func (m *SettingMutation) AddSettingLevel(i int) {
	if m.addsetting_level != nil {
		*m.addsetting_level += i
	} else {
		m.addsetting_level = &i
	}
}

// AddedSettingLevel returns the value that was added to the "setting_level" field in this mutation.
func (m *SettingMutation) AddedSettingLevel() (r int, exists bool) {
	v := m.addsetting_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetSettingLevel resets all changes to the "setting_level" field.
func (m *SettingMutation) ResetSettingLevel() {
	m.setting_level = nil
	m.addsetting_level = nil
}

// SetSettingLevelName sets the "setting_level_name" field.
func (m *SettingMutation) SetSettingLevelName(s string) {
	m.setting_level_name = &s
}

// SettingLevelName returns the value of the "setting_level_name" field in the mutation.
func (m *SettingMutation) SettingLevelName() (r string, exists bool) {
	v := m.setting_level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingLevelName returns the old "setting_level_name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSettingLevelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingLevelName: %w", err)
	}
	return oldValue.SettingLevelName, nil
}

// ResetSettingLevelName resets all changes to the "setting_level_name" field.
func (m *SettingMutation) ResetSettingLevelName() {
	m.setting_level_name = nil
}

// SetUseGroupSetting sets the "use_group_setting" field.
func (m *SettingMutation) SetUseGroupSetting(b bool) {
	m.use_group_setting = &b
}

// UseGroupSetting returns the value of the "use_group_setting" field in the mutation.
func (m *SettingMutation) UseGroupSetting() (r bool, exists bool) {
	v := m.use_group_setting
	if v == nil {
		return
	}
	return *v, true
}

// OldUseGroupSetting returns the old "use_group_setting" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUseGroupSetting(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseGroupSetting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseGroupSetting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseGroupSetting: %w", err)
	}
	return oldValue.UseGroupSetting, nil
}

// ResetUseGroupSetting resets all changes to the "use_group_setting" field.
func (m *SettingMutation) ResetUseGroupSetting() {
	m.use_group_setting = nil
}

// AddClinicIDs adds the "clinics" edge to the Clinic entity by ids.
func (m *SettingMutation) AddClinicIDs(ids ...int) {
	if m.clinics == nil {
		m.clinics = make(map[int]struct{})
	}
	for i := range ids {
		m.clinics[ids[i]] = struct{}{}
	}
}

// ClearClinics clears the "clinics" edge to the Clinic entity.
func (m *SettingMutation) ClearClinics() {
	m.clearedclinics = true
}

// ClinicsCleared reports if the "clinics" edge to the Clinic entity was cleared.
func (m *SettingMutation) ClinicsCleared() bool {
	return m.clearedclinics
}

// RemoveClinicIDs removes the "clinics" edge to the Clinic entity by IDs.
func (m *SettingMutation) RemoveClinicIDs(ids ...int) {
	if m.removedclinics == nil {
		m.removedclinics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinics, ids[i])
		m.removedclinics[ids[i]] = struct{}{}
	}
}

// RemovedClinics returns the removed IDs of the "clinics" edge to the Clinic entity.
func (m *SettingMutation) RemovedClinicsIDs() (ids []int) {
	for id := range m.removedclinics {
		ids = append(ids, id)
	}
	return
}

// ClinicsIDs returns the "clinics" edge IDs in the mutation.
func (m *SettingMutation) ClinicsIDs() (ids []int) {
	for id := range m.clinics {
		ids = append(ids, id)
	}
	return
}

// ResetClinics resets all changes to the "clinics" edge.
func (m *SettingMutation) ResetClinics() {
	m.clinics = nil
	m.clearedclinics = false
	m.removedclinics = nil
}

// AddInternalUserIDs adds the "internal_users" edge to the InternalUser entity by ids.
func (m *SettingMutation) AddInternalUserIDs(ids ...int) {
	if m.internal_users == nil {
		m.internal_users = make(map[int]struct{})
	}
	for i := range ids {
		m.internal_users[ids[i]] = struct{}{}
	}
}

// ClearInternalUsers clears the "internal_users" edge to the InternalUser entity.
func (m *SettingMutation) ClearInternalUsers() {
	m.clearedinternal_users = true
}

// InternalUsersCleared reports if the "internal_users" edge to the InternalUser entity was cleared.
func (m *SettingMutation) InternalUsersCleared() bool {
	return m.clearedinternal_users
}

// RemoveInternalUserIDs removes the "internal_users" edge to the InternalUser entity by IDs.
func (m *SettingMutation) RemoveInternalUserIDs(ids ...int) {
	if m.removedinternal_users == nil {
		m.removedinternal_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.internal_users, ids[i])
		m.removedinternal_users[ids[i]] = struct{}{}
	}
}

// RemovedInternalUsers returns the removed IDs of the "internal_users" edge to the InternalUser entity.
func (m *SettingMutation) RemovedInternalUsersIDs() (ids []int) {
	for id := range m.removedinternal_users {
		ids = append(ids, id)
	}
	return
}

// InternalUsersIDs returns the "internal_users" edge IDs in the mutation.
func (m *SettingMutation) InternalUsersIDs() (ids []int) {
	for id := range m.internal_users {
		ids = append(ids, id)
	}
	return
}

// ResetInternalUsers resets all changes to the "internal_users" edge.
func (m *SettingMutation) ResetInternalUsers() {
	m.internal_users = nil
	m.clearedinternal_users = false
	m.removedinternal_users = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *SettingMutation) AddPatientIDs(ids ...int) {
	if m.patients == nil {
		m.patients = make(map[int]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *SettingMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared reports if the "patients" edge to the Patient entity was cleared.
func (m *SettingMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *SettingMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patients, ids[i])
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *SettingMutation) RemovedPatientsIDs() (ids []int) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *SettingMutation) PatientsIDs() (ids []int) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *SettingMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// AddClinicCustomerIDs adds the "clinic_customers" edge to the CustomerSettingOnClinics entity by ids.
func (m *SettingMutation) AddClinicCustomerIDs(ids ...int) {
	if m.clinic_customers == nil {
		m.clinic_customers = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic_customers[ids[i]] = struct{}{}
	}
}

// ClearClinicCustomers clears the "clinic_customers" edge to the CustomerSettingOnClinics entity.
func (m *SettingMutation) ClearClinicCustomers() {
	m.clearedclinic_customers = true
}

// ClinicCustomersCleared reports if the "clinic_customers" edge to the CustomerSettingOnClinics entity was cleared.
func (m *SettingMutation) ClinicCustomersCleared() bool {
	return m.clearedclinic_customers
}

// RemoveClinicCustomerIDs removes the "clinic_customers" edge to the CustomerSettingOnClinics entity by IDs.
func (m *SettingMutation) RemoveClinicCustomerIDs(ids ...int) {
	if m.removedclinic_customers == nil {
		m.removedclinic_customers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic_customers, ids[i])
		m.removedclinic_customers[ids[i]] = struct{}{}
	}
}

// RemovedClinicCustomers returns the removed IDs of the "clinic_customers" edge to the CustomerSettingOnClinics entity.
func (m *SettingMutation) RemovedClinicCustomersIDs() (ids []int) {
	for id := range m.removedclinic_customers {
		ids = append(ids, id)
	}
	return
}

// ClinicCustomersIDs returns the "clinic_customers" edge IDs in the mutation.
func (m *SettingMutation) ClinicCustomersIDs() (ids []int) {
	for id := range m.clinic_customers {
		ids = append(ids, id)
	}
	return
}

// ResetClinicCustomers resets all changes to the "clinic_customers" edge.
func (m *SettingMutation) ResetClinicCustomers() {
	m.clinic_customers = nil
	m.clearedclinic_customers = false
	m.removedclinic_customers = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.setting_name != nil {
		fields = append(fields, setting.FieldSettingName)
	}
	if m.setting_group != nil {
		fields = append(fields, setting.FieldSettingGroup)
	}
	if m.setting_description != nil {
		fields = append(fields, setting.FieldSettingDescription)
	}
	if m.setting_value != nil {
		fields = append(fields, setting.FieldSettingValue)
	}
	if m.setting_type != nil {
		fields = append(fields, setting.FieldSettingType)
	}
	if m.setting_value_updated_time != nil {
		fields = append(fields, setting.FieldSettingValueUpdatedTime)
	}
	if m.is_active != nil {
		fields = append(fields, setting.FieldIsActive)
	}
	if m.apply_to_all_group_member != nil {
		fields = append(fields, setting.FieldApplyToAllGroupMember)
	}
	if m.is_official != nil {
		fields = append(fields, setting.FieldIsOfficial)
	}
	if m.setting_level != nil {
		fields = append(fields, setting.FieldSettingLevel)
	}
	if m.setting_level_name != nil {
		fields = append(fields, setting.FieldSettingLevelName)
	}
	if m.use_group_setting != nil {
		fields = append(fields, setting.FieldUseGroupSetting)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldSettingName:
		return m.SettingName()
	case setting.FieldSettingGroup:
		return m.SettingGroup()
	case setting.FieldSettingDescription:
		return m.SettingDescription()
	case setting.FieldSettingValue:
		return m.SettingValue()
	case setting.FieldSettingType:
		return m.SettingType()
	case setting.FieldSettingValueUpdatedTime:
		return m.SettingValueUpdatedTime()
	case setting.FieldIsActive:
		return m.IsActive()
	case setting.FieldApplyToAllGroupMember:
		return m.ApplyToAllGroupMember()
	case setting.FieldIsOfficial:
		return m.IsOfficial()
	case setting.FieldSettingLevel:
		return m.SettingLevel()
	case setting.FieldSettingLevelName:
		return m.SettingLevelName()
	case setting.FieldUseGroupSetting:
		return m.UseGroupSetting()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldSettingName:
		return m.OldSettingName(ctx)
	case setting.FieldSettingGroup:
		return m.OldSettingGroup(ctx)
	case setting.FieldSettingDescription:
		return m.OldSettingDescription(ctx)
	case setting.FieldSettingValue:
		return m.OldSettingValue(ctx)
	case setting.FieldSettingType:
		return m.OldSettingType(ctx)
	case setting.FieldSettingValueUpdatedTime:
		return m.OldSettingValueUpdatedTime(ctx)
	case setting.FieldIsActive:
		return m.OldIsActive(ctx)
	case setting.FieldApplyToAllGroupMember:
		return m.OldApplyToAllGroupMember(ctx)
	case setting.FieldIsOfficial:
		return m.OldIsOfficial(ctx)
	case setting.FieldSettingLevel:
		return m.OldSettingLevel(ctx)
	case setting.FieldSettingLevelName:
		return m.OldSettingLevelName(ctx)
	case setting.FieldUseGroupSetting:
		return m.OldUseGroupSetting(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldSettingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingName(v)
		return nil
	case setting.FieldSettingGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingGroup(v)
		return nil
	case setting.FieldSettingDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingDescription(v)
		return nil
	case setting.FieldSettingValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingValue(v)
		return nil
	case setting.FieldSettingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingType(v)
		return nil
	case setting.FieldSettingValueUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingValueUpdatedTime(v)
		return nil
	case setting.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case setting.FieldApplyToAllGroupMember:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyToAllGroupMember(v)
		return nil
	case setting.FieldIsOfficial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOfficial(v)
		return nil
	case setting.FieldSettingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingLevel(v)
		return nil
	case setting.FieldSettingLevelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingLevelName(v)
		return nil
	case setting.FieldUseGroupSetting:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseGroupSetting(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	var fields []string
	if m.addsetting_level != nil {
		fields = append(fields, setting.FieldSettingLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldSettingLevel:
		return m.AddedSettingLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setting.FieldSettingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettingLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldSettingValue) {
		fields = append(fields, setting.FieldSettingValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldSettingValue:
		m.ClearSettingValue()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldSettingName:
		m.ResetSettingName()
		return nil
	case setting.FieldSettingGroup:
		m.ResetSettingGroup()
		return nil
	case setting.FieldSettingDescription:
		m.ResetSettingDescription()
		return nil
	case setting.FieldSettingValue:
		m.ResetSettingValue()
		return nil
	case setting.FieldSettingType:
		m.ResetSettingType()
		return nil
	case setting.FieldSettingValueUpdatedTime:
		m.ResetSettingValueUpdatedTime()
		return nil
	case setting.FieldIsActive:
		m.ResetIsActive()
		return nil
	case setting.FieldApplyToAllGroupMember:
		m.ResetApplyToAllGroupMember()
		return nil
	case setting.FieldIsOfficial:
		m.ResetIsOfficial()
		return nil
	case setting.FieldSettingLevel:
		m.ResetSettingLevel()
		return nil
	case setting.FieldSettingLevelName:
		m.ResetSettingLevelName()
		return nil
	case setting.FieldUseGroupSetting:
		m.ResetUseGroupSetting()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clinics != nil {
		edges = append(edges, setting.EdgeClinics)
	}
	if m.internal_users != nil {
		edges = append(edges, setting.EdgeInternalUsers)
	}
	if m.patients != nil {
		edges = append(edges, setting.EdgePatients)
	}
	if m.clinic_customers != nil {
		edges = append(edges, setting.EdgeClinicCustomers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case setting.EdgeClinics:
		ids := make([]ent.Value, 0, len(m.clinics))
		for id := range m.clinics {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgeInternalUsers:
		ids := make([]ent.Value, 0, len(m.internal_users))
		for id := range m.internal_users {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgeClinicCustomers:
		ids := make([]ent.Value, 0, len(m.clinic_customers))
		for id := range m.clinic_customers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedclinics != nil {
		edges = append(edges, setting.EdgeClinics)
	}
	if m.removedinternal_users != nil {
		edges = append(edges, setting.EdgeInternalUsers)
	}
	if m.removedpatients != nil {
		edges = append(edges, setting.EdgePatients)
	}
	if m.removedclinic_customers != nil {
		edges = append(edges, setting.EdgeClinicCustomers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case setting.EdgeClinics:
		ids := make([]ent.Value, 0, len(m.removedclinics))
		for id := range m.removedclinics {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgeInternalUsers:
		ids := make([]ent.Value, 0, len(m.removedinternal_users))
		for id := range m.removedinternal_users {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	case setting.EdgeClinicCustomers:
		ids := make([]ent.Value, 0, len(m.removedclinic_customers))
		for id := range m.removedclinic_customers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedclinics {
		edges = append(edges, setting.EdgeClinics)
	}
	if m.clearedinternal_users {
		edges = append(edges, setting.EdgeInternalUsers)
	}
	if m.clearedpatients {
		edges = append(edges, setting.EdgePatients)
	}
	if m.clearedclinic_customers {
		edges = append(edges, setting.EdgeClinicCustomers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	switch name {
	case setting.EdgeClinics:
		return m.clearedclinics
	case setting.EdgeInternalUsers:
		return m.clearedinternal_users
	case setting.EdgePatients:
		return m.clearedpatients
	case setting.EdgeClinicCustomers:
		return m.clearedclinic_customers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	switch name {
	case setting.EdgeClinics:
		m.ResetClinics()
		return nil
	case setting.EdgeInternalUsers:
		m.ResetInternalUsers()
		return nil
	case setting.EdgePatients:
		m.ResetPatients()
		return nil
	case setting.EdgeClinicCustomers:
		m.ResetClinicCustomers()
		return nil
	}
	return fmt.Errorf("unknown Setting edge %s", name)
}

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	test_name           *string
	test_code           *string
	display_name        *string
	test_description    *string
	assay_name          *string
	isActive            *bool
	created_time        *time.Time
	updated_time        *time.Time
	clearedFields       map[string]struct{}
	test_details        map[int]struct{}
	removedtest_details map[int]struct{}
	clearedtest_details bool
	order_info          map[int]struct{}
	removedorder_info   map[int]struct{}
	clearedorder_info   bool
	sample_types        map[int]struct{}
	removedsample_types map[int]struct{}
	clearedsample_types bool
	tube_types          map[int]struct{}
	removedtube_types   map[int]struct{}
	clearedtube_types   bool
	done                bool
	oldValue            func(context.Context) (*Test, error)
	predicates          []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id int) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Test entities.
func (m *TestMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTestName sets the "test_name" field.
func (m *TestMutation) SetTestName(s string) {
	m.test_name = &s
}

// TestName returns the value of the "test_name" field in the mutation.
func (m *TestMutation) TestName() (r string, exists bool) {
	v := m.test_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTestName returns the old "test_name" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldTestName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestName: %w", err)
	}
	return oldValue.TestName, nil
}

// ResetTestName resets all changes to the "test_name" field.
func (m *TestMutation) ResetTestName() {
	m.test_name = nil
}

// SetTestCode sets the "test_code" field.
func (m *TestMutation) SetTestCode(s string) {
	m.test_code = &s
}

// TestCode returns the value of the "test_code" field in the mutation.
func (m *TestMutation) TestCode() (r string, exists bool) {
	v := m.test_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCode returns the old "test_code" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldTestCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCode: %w", err)
	}
	return oldValue.TestCode, nil
}

// ResetTestCode resets all changes to the "test_code" field.
func (m *TestMutation) ResetTestCode() {
	m.test_code = nil
}

// SetDisplayName sets the "display_name" field.
func (m *TestMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TestMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TestMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetTestDescription sets the "test_description" field.
func (m *TestMutation) SetTestDescription(s string) {
	m.test_description = &s
}

// TestDescription returns the value of the "test_description" field in the mutation.
func (m *TestMutation) TestDescription() (r string, exists bool) {
	v := m.test_description
	if v == nil {
		return
	}
	return *v, true
}

// OldTestDescription returns the old "test_description" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldTestDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestDescription: %w", err)
	}
	return oldValue.TestDescription, nil
}

// ResetTestDescription resets all changes to the "test_description" field.
func (m *TestMutation) ResetTestDescription() {
	m.test_description = nil
}

// SetAssayName sets the "assay_name" field.
func (m *TestMutation) SetAssayName(s string) {
	m.assay_name = &s
}

// AssayName returns the value of the "assay_name" field in the mutation.
func (m *TestMutation) AssayName() (r string, exists bool) {
	v := m.assay_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAssayName returns the old "assay_name" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldAssayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssayName: %w", err)
	}
	return oldValue.AssayName, nil
}

// ResetAssayName resets all changes to the "assay_name" field.
func (m *TestMutation) ResetAssayName() {
	m.assay_name = nil
}

// SetIsActive sets the "isActive" field.
func (m *TestMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *TestMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *TestMutation) ResetIsActive() {
	m.isActive = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TestMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TestMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TestMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *TestMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *TestMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *TestMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[test.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *TestMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[test.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *TestMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, test.FieldUpdatedTime)
}

// AddTestDetailIDs adds the "test_details" edge to the TestDetail entity by ids.
func (m *TestMutation) AddTestDetailIDs(ids ...int) {
	if m.test_details == nil {
		m.test_details = make(map[int]struct{})
	}
	for i := range ids {
		m.test_details[ids[i]] = struct{}{}
	}
}

// ClearTestDetails clears the "test_details" edge to the TestDetail entity.
func (m *TestMutation) ClearTestDetails() {
	m.clearedtest_details = true
}

// TestDetailsCleared reports if the "test_details" edge to the TestDetail entity was cleared.
func (m *TestMutation) TestDetailsCleared() bool {
	return m.clearedtest_details
}

// RemoveTestDetailIDs removes the "test_details" edge to the TestDetail entity by IDs.
func (m *TestMutation) RemoveTestDetailIDs(ids ...int) {
	if m.removedtest_details == nil {
		m.removedtest_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_details, ids[i])
		m.removedtest_details[ids[i]] = struct{}{}
	}
}

// RemovedTestDetails returns the removed IDs of the "test_details" edge to the TestDetail entity.
func (m *TestMutation) RemovedTestDetailsIDs() (ids []int) {
	for id := range m.removedtest_details {
		ids = append(ids, id)
	}
	return
}

// TestDetailsIDs returns the "test_details" edge IDs in the mutation.
func (m *TestMutation) TestDetailsIDs() (ids []int) {
	for id := range m.test_details {
		ids = append(ids, id)
	}
	return
}

// ResetTestDetails resets all changes to the "test_details" edge.
func (m *TestMutation) ResetTestDetails() {
	m.test_details = nil
	m.clearedtest_details = false
	m.removedtest_details = nil
}

// AddOrderInfoIDs adds the "order_info" edge to the OrderInfo entity by ids.
func (m *TestMutation) AddOrderInfoIDs(ids ...int) {
	if m.order_info == nil {
		m.order_info = make(map[int]struct{})
	}
	for i := range ids {
		m.order_info[ids[i]] = struct{}{}
	}
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *TestMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *TestMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// RemoveOrderInfoIDs removes the "order_info" edge to the OrderInfo entity by IDs.
func (m *TestMutation) RemoveOrderInfoIDs(ids ...int) {
	if m.removedorder_info == nil {
		m.removedorder_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_info, ids[i])
		m.removedorder_info[ids[i]] = struct{}{}
	}
}

// RemovedOrderInfo returns the removed IDs of the "order_info" edge to the OrderInfo entity.
func (m *TestMutation) RemovedOrderInfoIDs() (ids []int) {
	for id := range m.removedorder_info {
		ids = append(ids, id)
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
func (m *TestMutation) OrderInfoIDs() (ids []int) {
	for id := range m.order_info {
		ids = append(ids, id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *TestMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
	m.removedorder_info = nil
}

// AddSampleTypeIDs adds the "sample_types" edge to the SampleType entity by ids.
func (m *TestMutation) AddSampleTypeIDs(ids ...int) {
	if m.sample_types == nil {
		m.sample_types = make(map[int]struct{})
	}
	for i := range ids {
		m.sample_types[ids[i]] = struct{}{}
	}
}

// ClearSampleTypes clears the "sample_types" edge to the SampleType entity.
func (m *TestMutation) ClearSampleTypes() {
	m.clearedsample_types = true
}

// SampleTypesCleared reports if the "sample_types" edge to the SampleType entity was cleared.
func (m *TestMutation) SampleTypesCleared() bool {
	return m.clearedsample_types
}

// RemoveSampleTypeIDs removes the "sample_types" edge to the SampleType entity by IDs.
func (m *TestMutation) RemoveSampleTypeIDs(ids ...int) {
	if m.removedsample_types == nil {
		m.removedsample_types = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sample_types, ids[i])
		m.removedsample_types[ids[i]] = struct{}{}
	}
}

// RemovedSampleTypes returns the removed IDs of the "sample_types" edge to the SampleType entity.
func (m *TestMutation) RemovedSampleTypesIDs() (ids []int) {
	for id := range m.removedsample_types {
		ids = append(ids, id)
	}
	return
}

// SampleTypesIDs returns the "sample_types" edge IDs in the mutation.
func (m *TestMutation) SampleTypesIDs() (ids []int) {
	for id := range m.sample_types {
		ids = append(ids, id)
	}
	return
}

// ResetSampleTypes resets all changes to the "sample_types" edge.
func (m *TestMutation) ResetSampleTypes() {
	m.sample_types = nil
	m.clearedsample_types = false
	m.removedsample_types = nil
}

// AddTubeTypeIDs adds the "tube_types" edge to the TubeType entity by ids.
func (m *TestMutation) AddTubeTypeIDs(ids ...int) {
	if m.tube_types == nil {
		m.tube_types = make(map[int]struct{})
	}
	for i := range ids {
		m.tube_types[ids[i]] = struct{}{}
	}
}

// ClearTubeTypes clears the "tube_types" edge to the TubeType entity.
func (m *TestMutation) ClearTubeTypes() {
	m.clearedtube_types = true
}

// TubeTypesCleared reports if the "tube_types" edge to the TubeType entity was cleared.
func (m *TestMutation) TubeTypesCleared() bool {
	return m.clearedtube_types
}

// RemoveTubeTypeIDs removes the "tube_types" edge to the TubeType entity by IDs.
func (m *TestMutation) RemoveTubeTypeIDs(ids ...int) {
	if m.removedtube_types == nil {
		m.removedtube_types = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tube_types, ids[i])
		m.removedtube_types[ids[i]] = struct{}{}
	}
}

// RemovedTubeTypes returns the removed IDs of the "tube_types" edge to the TubeType entity.
func (m *TestMutation) RemovedTubeTypesIDs() (ids []int) {
	for id := range m.removedtube_types {
		ids = append(ids, id)
	}
	return
}

// TubeTypesIDs returns the "tube_types" edge IDs in the mutation.
func (m *TestMutation) TubeTypesIDs() (ids []int) {
	for id := range m.tube_types {
		ids = append(ids, id)
	}
	return
}

// ResetTubeTypes resets all changes to the "tube_types" edge.
func (m *TestMutation) ResetTubeTypes() {
	m.tube_types = nil
	m.clearedtube_types = false
	m.removedtube_types = nil
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.test_name != nil {
		fields = append(fields, test.FieldTestName)
	}
	if m.test_code != nil {
		fields = append(fields, test.FieldTestCode)
	}
	if m.display_name != nil {
		fields = append(fields, test.FieldDisplayName)
	}
	if m.test_description != nil {
		fields = append(fields, test.FieldTestDescription)
	}
	if m.assay_name != nil {
		fields = append(fields, test.FieldAssayName)
	}
	if m.isActive != nil {
		fields = append(fields, test.FieldIsActive)
	}
	if m.created_time != nil {
		fields = append(fields, test.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, test.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test.FieldTestName:
		return m.TestName()
	case test.FieldTestCode:
		return m.TestCode()
	case test.FieldDisplayName:
		return m.DisplayName()
	case test.FieldTestDescription:
		return m.TestDescription()
	case test.FieldAssayName:
		return m.AssayName()
	case test.FieldIsActive:
		return m.IsActive()
	case test.FieldCreatedTime:
		return m.CreatedTime()
	case test.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test.FieldTestName:
		return m.OldTestName(ctx)
	case test.FieldTestCode:
		return m.OldTestCode(ctx)
	case test.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case test.FieldTestDescription:
		return m.OldTestDescription(ctx)
	case test.FieldAssayName:
		return m.OldAssayName(ctx)
	case test.FieldIsActive:
		return m.OldIsActive(ctx)
	case test.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case test.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test.FieldTestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestName(v)
		return nil
	case test.FieldTestCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCode(v)
		return nil
	case test.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case test.FieldTestDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestDescription(v)
		return nil
	case test.FieldAssayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssayName(v)
		return nil
	case test.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case test.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case test.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test.FieldUpdatedTime) {
		fields = append(fields, test.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	switch name {
	case test.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	switch name {
	case test.FieldTestName:
		m.ResetTestName()
		return nil
	case test.FieldTestCode:
		m.ResetTestCode()
		return nil
	case test.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case test.FieldTestDescription:
		m.ResetTestDescription()
		return nil
	case test.FieldAssayName:
		m.ResetAssayName()
		return nil
	case test.FieldIsActive:
		m.ResetIsActive()
		return nil
	case test.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case test.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.test_details != nil {
		edges = append(edges, test.EdgeTestDetails)
	}
	if m.order_info != nil {
		edges = append(edges, test.EdgeOrderInfo)
	}
	if m.sample_types != nil {
		edges = append(edges, test.EdgeSampleTypes)
	}
	if m.tube_types != nil {
		edges = append(edges, test.EdgeTubeTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case test.EdgeTestDetails:
		ids := make([]ent.Value, 0, len(m.test_details))
		for id := range m.test_details {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.order_info))
		for id := range m.order_info {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeSampleTypes:
		ids := make([]ent.Value, 0, len(m.sample_types))
		for id := range m.sample_types {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeTubeTypes:
		ids := make([]ent.Value, 0, len(m.tube_types))
		for id := range m.tube_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtest_details != nil {
		edges = append(edges, test.EdgeTestDetails)
	}
	if m.removedorder_info != nil {
		edges = append(edges, test.EdgeOrderInfo)
	}
	if m.removedsample_types != nil {
		edges = append(edges, test.EdgeSampleTypes)
	}
	if m.removedtube_types != nil {
		edges = append(edges, test.EdgeTubeTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case test.EdgeTestDetails:
		ids := make([]ent.Value, 0, len(m.removedtest_details))
		for id := range m.removedtest_details {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.removedorder_info))
		for id := range m.removedorder_info {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeSampleTypes:
		ids := make([]ent.Value, 0, len(m.removedsample_types))
		for id := range m.removedsample_types {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeTubeTypes:
		ids := make([]ent.Value, 0, len(m.removedtube_types))
		for id := range m.removedtube_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtest_details {
		edges = append(edges, test.EdgeTestDetails)
	}
	if m.clearedorder_info {
		edges = append(edges, test.EdgeOrderInfo)
	}
	if m.clearedsample_types {
		edges = append(edges, test.EdgeSampleTypes)
	}
	if m.clearedtube_types {
		edges = append(edges, test.EdgeTubeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	switch name {
	case test.EdgeTestDetails:
		return m.clearedtest_details
	case test.EdgeOrderInfo:
		return m.clearedorder_info
	case test.EdgeSampleTypes:
		return m.clearedsample_types
	case test.EdgeTubeTypes:
		return m.clearedtube_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	switch name {
	case test.EdgeTestDetails:
		m.ResetTestDetails()
		return nil
	case test.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	case test.EdgeSampleTypes:
		m.ResetSampleTypes()
		return nil
	case test.EdgeTubeTypes:
		m.ResetTubeTypes()
		return nil
	}
	return fmt.Errorf("unknown Test edge %s", name)
}

// TestDetailMutation represents an operation that mutates the TestDetail nodes in the graph.
type TestDetailMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	test_detail_name   *string
	test_details_value *string
	isActive           *bool
	clearedFields      map[string]struct{}
	test               *int
	clearedtest        bool
	done               bool
	oldValue           func(context.Context) (*TestDetail, error)
	predicates         []predicate.TestDetail
}

var _ ent.Mutation = (*TestDetailMutation)(nil)

// testdetailOption allows management of the mutation configuration using functional options.
type testdetailOption func(*TestDetailMutation)

// newTestDetailMutation creates new mutation for the TestDetail entity.
func newTestDetailMutation(c config, op Op, opts ...testdetailOption) *TestDetailMutation {
	m := &TestDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeTestDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestDetailID sets the ID field of the mutation.
func withTestDetailID(id int) testdetailOption {
	return func(m *TestDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *TestDetail
		)
		m.oldValue = func(ctx context.Context) (*TestDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestDetail sets the old TestDetail of the mutation.
func withTestDetail(node *TestDetail) testdetailOption {
	return func(m *TestDetailMutation) {
		m.oldValue = func(context.Context) (*TestDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTestID sets the "test_id" field.
func (m *TestDetailMutation) SetTestID(i int) {
	m.test = &i
}

// TestID returns the value of the "test_id" field in the mutation.
func (m *TestDetailMutation) TestID() (r int, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTestID returns the old "test_id" field's value of the TestDetail entity.
// If the TestDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestDetailMutation) OldTestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestID: %w", err)
	}
	return oldValue.TestID, nil
}

// ResetTestID resets all changes to the "test_id" field.
func (m *TestDetailMutation) ResetTestID() {
	m.test = nil
}

// SetTestDetailName sets the "test_detail_name" field.
func (m *TestDetailMutation) SetTestDetailName(s string) {
	m.test_detail_name = &s
}

// TestDetailName returns the value of the "test_detail_name" field in the mutation.
func (m *TestDetailMutation) TestDetailName() (r string, exists bool) {
	v := m.test_detail_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTestDetailName returns the old "test_detail_name" field's value of the TestDetail entity.
// If the TestDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestDetailMutation) OldTestDetailName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestDetailName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestDetailName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestDetailName: %w", err)
	}
	return oldValue.TestDetailName, nil
}

// ResetTestDetailName resets all changes to the "test_detail_name" field.
func (m *TestDetailMutation) ResetTestDetailName() {
	m.test_detail_name = nil
}

// SetTestDetailsValue sets the "test_details_value" field.
func (m *TestDetailMutation) SetTestDetailsValue(s string) {
	m.test_details_value = &s
}

// TestDetailsValue returns the value of the "test_details_value" field in the mutation.
func (m *TestDetailMutation) TestDetailsValue() (r string, exists bool) {
	v := m.test_details_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTestDetailsValue returns the old "test_details_value" field's value of the TestDetail entity.
// If the TestDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestDetailMutation) OldTestDetailsValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestDetailsValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestDetailsValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestDetailsValue: %w", err)
	}
	return oldValue.TestDetailsValue, nil
}

// ResetTestDetailsValue resets all changes to the "test_details_value" field.
func (m *TestDetailMutation) ResetTestDetailsValue() {
	m.test_details_value = nil
}

// SetIsActive sets the "isActive" field.
func (m *TestDetailMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *TestDetailMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the TestDetail entity.
// If the TestDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestDetailMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *TestDetailMutation) ResetIsActive() {
	m.isActive = nil
}

// ClearTest clears the "test" edge to the Test entity.
func (m *TestDetailMutation) ClearTest() {
	m.clearedtest = true
	m.clearedFields[testdetail.FieldTestID] = struct{}{}
}

// TestCleared reports if the "test" edge to the Test entity was cleared.
func (m *TestDetailMutation) TestCleared() bool {
	return m.clearedtest
}

// TestIDs returns the "test" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestID instead. It exists only for internal usage by the builders.
func (m *TestDetailMutation) TestIDs() (ids []int) {
	if id := m.test; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTest resets all changes to the "test" edge.
func (m *TestDetailMutation) ResetTest() {
	m.test = nil
	m.clearedtest = false
}

// Where appends a list predicates to the TestDetailMutation builder.
func (m *TestDetailMutation) Where(ps ...predicate.TestDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestDetail).
func (m *TestDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestDetailMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.test != nil {
		fields = append(fields, testdetail.FieldTestID)
	}
	if m.test_detail_name != nil {
		fields = append(fields, testdetail.FieldTestDetailName)
	}
	if m.test_details_value != nil {
		fields = append(fields, testdetail.FieldTestDetailsValue)
	}
	if m.isActive != nil {
		fields = append(fields, testdetail.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testdetail.FieldTestID:
		return m.TestID()
	case testdetail.FieldTestDetailName:
		return m.TestDetailName()
	case testdetail.FieldTestDetailsValue:
		return m.TestDetailsValue()
	case testdetail.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testdetail.FieldTestID:
		return m.OldTestID(ctx)
	case testdetail.FieldTestDetailName:
		return m.OldTestDetailName(ctx)
	case testdetail.FieldTestDetailsValue:
		return m.OldTestDetailsValue(ctx)
	case testdetail.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown TestDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testdetail.FieldTestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestID(v)
		return nil
	case testdetail.FieldTestDetailName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestDetailName(v)
		return nil
	case testdetail.FieldTestDetailsValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestDetailsValue(v)
		return nil
	case testdetail.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown TestDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestDetailMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TestDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestDetailMutation) ResetField(name string) error {
	switch name {
	case testdetail.FieldTestID:
		m.ResetTestID()
		return nil
	case testdetail.FieldTestDetailName:
		m.ResetTestDetailName()
		return nil
	case testdetail.FieldTestDetailsValue:
		m.ResetTestDetailsValue()
		return nil
	case testdetail.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown TestDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.test != nil {
		edges = append(edges, testdetail.EdgeTest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testdetail.EdgeTest:
		if id := m.test; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtest {
		edges = append(edges, testdetail.EdgeTest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case testdetail.EdgeTest:
		return m.clearedtest
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestDetailMutation) ClearEdge(name string) error {
	switch name {
	case testdetail.EdgeTest:
		m.ClearTest()
		return nil
	}
	return fmt.Errorf("unknown TestDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestDetailMutation) ResetEdge(name string) error {
	switch name {
	case testdetail.EdgeTest:
		m.ResetTest()
		return nil
	}
	return fmt.Errorf("unknown TestDetail edge %s", name)
}

// TestListMutation represents an operation that mutates the TestList nodes in the graph.
type TestListMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	test_instrument    *testlist.TestInstrument
	tube_type          *testlist.TubeType
	_DI_group_name     *string
	volume_required    *float64
	addvolume_required *float64
	blood_type         *bool
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*TestList, error)
	predicates         []predicate.TestList
}

var _ ent.Mutation = (*TestListMutation)(nil)

// testlistOption allows management of the mutation configuration using functional options.
type testlistOption func(*TestListMutation)

// newTestListMutation creates new mutation for the TestList entity.
func newTestListMutation(c config, op Op, opts ...testlistOption) *TestListMutation {
	m := &TestListMutation{
		config:        c,
		op:            op,
		typ:           TypeTestList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestListID sets the ID field of the mutation.
func withTestListID(id int) testlistOption {
	return func(m *TestListMutation) {
		var (
			err   error
			once  sync.Once
			value *TestList
		)
		m.oldValue = func(ctx context.Context) (*TestList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestList sets the old TestList of the mutation.
func withTestList(node *TestList) testlistOption {
	return func(m *TestListMutation) {
		m.oldValue = func(context.Context) (*TestList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestList entities.
func (m *TestListMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTestInstrument sets the "test_instrument" field.
func (m *TestListMutation) SetTestInstrument(ti testlist.TestInstrument) {
	m.test_instrument = &ti
}

// TestInstrument returns the value of the "test_instrument" field in the mutation.
func (m *TestListMutation) TestInstrument() (r testlist.TestInstrument, exists bool) {
	v := m.test_instrument
	if v == nil {
		return
	}
	return *v, true
}

// OldTestInstrument returns the old "test_instrument" field's value of the TestList entity.
// If the TestList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestListMutation) OldTestInstrument(ctx context.Context) (v testlist.TestInstrument, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestInstrument is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestInstrument requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestInstrument: %w", err)
	}
	return oldValue.TestInstrument, nil
}

// ClearTestInstrument clears the value of the "test_instrument" field.
func (m *TestListMutation) ClearTestInstrument() {
	m.test_instrument = nil
	m.clearedFields[testlist.FieldTestInstrument] = struct{}{}
}

// TestInstrumentCleared returns if the "test_instrument" field was cleared in this mutation.
func (m *TestListMutation) TestInstrumentCleared() bool {
	_, ok := m.clearedFields[testlist.FieldTestInstrument]
	return ok
}

// ResetTestInstrument resets all changes to the "test_instrument" field.
func (m *TestListMutation) ResetTestInstrument() {
	m.test_instrument = nil
	delete(m.clearedFields, testlist.FieldTestInstrument)
}

// SetTubeType sets the "tube_type" field.
func (m *TestListMutation) SetTubeType(tt testlist.TubeType) {
	m.tube_type = &tt
}

// TubeType returns the value of the "tube_type" field in the mutation.
func (m *TestListMutation) TubeType() (r testlist.TubeType, exists bool) {
	v := m.tube_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeType returns the old "tube_type" field's value of the TestList entity.
// If the TestList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestListMutation) OldTubeType(ctx context.Context) (v testlist.TubeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeType: %w", err)
	}
	return oldValue.TubeType, nil
}

// ResetTubeType resets all changes to the "tube_type" field.
func (m *TestListMutation) ResetTubeType() {
	m.tube_type = nil
}

// SetDIGroupName sets the "DI_group_name" field.
func (m *TestListMutation) SetDIGroupName(s string) {
	m._DI_group_name = &s
}

// DIGroupName returns the value of the "DI_group_name" field in the mutation.
func (m *TestListMutation) DIGroupName() (r string, exists bool) {
	v := m._DI_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDIGroupName returns the old "DI_group_name" field's value of the TestList entity.
// If the TestList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestListMutation) OldDIGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDIGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDIGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDIGroupName: %w", err)
	}
	return oldValue.DIGroupName, nil
}

// ClearDIGroupName clears the value of the "DI_group_name" field.
func (m *TestListMutation) ClearDIGroupName() {
	m._DI_group_name = nil
	m.clearedFields[testlist.FieldDIGroupName] = struct{}{}
}

// DIGroupNameCleared returns if the "DI_group_name" field was cleared in this mutation.
func (m *TestListMutation) DIGroupNameCleared() bool {
	_, ok := m.clearedFields[testlist.FieldDIGroupName]
	return ok
}

// ResetDIGroupName resets all changes to the "DI_group_name" field.
func (m *TestListMutation) ResetDIGroupName() {
	m._DI_group_name = nil
	delete(m.clearedFields, testlist.FieldDIGroupName)
}

// SetVolumeRequired sets the "volume_required" field.
func (m *TestListMutation) SetVolumeRequired(f float64) {
	m.volume_required = &f
	m.addvolume_required = nil
}

// VolumeRequired returns the value of the "volume_required" field in the mutation.
func (m *TestListMutation) VolumeRequired() (r float64, exists bool) {
	v := m.volume_required
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeRequired returns the old "volume_required" field's value of the TestList entity.
// If the TestList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestListMutation) OldVolumeRequired(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeRequired: %w", err)
	}
	return oldValue.VolumeRequired, nil
}

// AddVolumeRequired adds f to the "volume_required" field.
func (m *TestListMutation) AddVolumeRequired(f float64) {
	if m.addvolume_required != nil {
		*m.addvolume_required += f
	} else {
		m.addvolume_required = &f
	}
}

// AddedVolumeRequired returns the value that was added to the "volume_required" field in this mutation.
func (m *TestListMutation) AddedVolumeRequired() (r float64, exists bool) {
	v := m.addvolume_required
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolumeRequired resets all changes to the "volume_required" field.
func (m *TestListMutation) ResetVolumeRequired() {
	m.volume_required = nil
	m.addvolume_required = nil
}

// SetBloodType sets the "blood_type" field.
func (m *TestListMutation) SetBloodType(b bool) {
	m.blood_type = &b
}

// BloodType returns the value of the "blood_type" field in the mutation.
func (m *TestListMutation) BloodType() (r bool, exists bool) {
	v := m.blood_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodType returns the old "blood_type" field's value of the TestList entity.
// If the TestList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestListMutation) OldBloodType(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBloodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBloodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodType: %w", err)
	}
	return oldValue.BloodType, nil
}

// ResetBloodType resets all changes to the "blood_type" field.
func (m *TestListMutation) ResetBloodType() {
	m.blood_type = nil
}

// Where appends a list predicates to the TestListMutation builder.
func (m *TestListMutation) Where(ps ...predicate.TestList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestList).
func (m *TestListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestListMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.test_instrument != nil {
		fields = append(fields, testlist.FieldTestInstrument)
	}
	if m.tube_type != nil {
		fields = append(fields, testlist.FieldTubeType)
	}
	if m._DI_group_name != nil {
		fields = append(fields, testlist.FieldDIGroupName)
	}
	if m.volume_required != nil {
		fields = append(fields, testlist.FieldVolumeRequired)
	}
	if m.blood_type != nil {
		fields = append(fields, testlist.FieldBloodType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testlist.FieldTestInstrument:
		return m.TestInstrument()
	case testlist.FieldTubeType:
		return m.TubeType()
	case testlist.FieldDIGroupName:
		return m.DIGroupName()
	case testlist.FieldVolumeRequired:
		return m.VolumeRequired()
	case testlist.FieldBloodType:
		return m.BloodType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testlist.FieldTestInstrument:
		return m.OldTestInstrument(ctx)
	case testlist.FieldTubeType:
		return m.OldTubeType(ctx)
	case testlist.FieldDIGroupName:
		return m.OldDIGroupName(ctx)
	case testlist.FieldVolumeRequired:
		return m.OldVolumeRequired(ctx)
	case testlist.FieldBloodType:
		return m.OldBloodType(ctx)
	}
	return nil, fmt.Errorf("unknown TestList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testlist.FieldTestInstrument:
		v, ok := value.(testlist.TestInstrument)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestInstrument(v)
		return nil
	case testlist.FieldTubeType:
		v, ok := value.(testlist.TubeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeType(v)
		return nil
	case testlist.FieldDIGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDIGroupName(v)
		return nil
	case testlist.FieldVolumeRequired:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeRequired(v)
		return nil
	case testlist.FieldBloodType:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodType(v)
		return nil
	}
	return fmt.Errorf("unknown TestList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestListMutation) AddedFields() []string {
	var fields []string
	if m.addvolume_required != nil {
		fields = append(fields, testlist.FieldVolumeRequired)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testlist.FieldVolumeRequired:
		return m.AddedVolumeRequired()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testlist.FieldVolumeRequired:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolumeRequired(v)
		return nil
	}
	return fmt.Errorf("unknown TestList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testlist.FieldTestInstrument) {
		fields = append(fields, testlist.FieldTestInstrument)
	}
	if m.FieldCleared(testlist.FieldDIGroupName) {
		fields = append(fields, testlist.FieldDIGroupName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestListMutation) ClearField(name string) error {
	switch name {
	case testlist.FieldTestInstrument:
		m.ClearTestInstrument()
		return nil
	case testlist.FieldDIGroupName:
		m.ClearDIGroupName()
		return nil
	}
	return fmt.Errorf("unknown TestList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestListMutation) ResetField(name string) error {
	switch name {
	case testlist.FieldTestInstrument:
		m.ResetTestInstrument()
		return nil
	case testlist.FieldTubeType:
		m.ResetTubeType()
		return nil
	case testlist.FieldDIGroupName:
		m.ResetDIGroupName()
		return nil
	case testlist.FieldVolumeRequired:
		m.ResetVolumeRequired()
		return nil
	case testlist.FieldBloodType:
		m.ResetBloodType()
		return nil
	}
	return fmt.Errorf("unknown TestList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestList edge %s", name)
}

// TubeMutation represents an operation that mutates the Tube nodes in the graph.
type TubeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	tube_id                 *string
	tube_storage            *string
	tube_receive_time       *time.Time
	tube_turnaround_time    *int
	addtube_turnaround_time *int
	tube_stability          *int
	addtube_stability       *int
	isActive                *bool
	issues                  *string
	tube_collection_time    *time.Time
	clearedFields           map[string]struct{}
	tube_type               map[int]struct{}
	removedtube_type        map[int]struct{}
	clearedtube_type        bool
	sample                  *int
	clearedsample           bool
	done                    bool
	oldValue                func(context.Context) (*Tube, error)
	predicates              []predicate.Tube
}

var _ ent.Mutation = (*TubeMutation)(nil)

// tubeOption allows management of the mutation configuration using functional options.
type tubeOption func(*TubeMutation)

// newTubeMutation creates new mutation for the Tube entity.
func newTubeMutation(c config, op Op, opts ...tubeOption) *TubeMutation {
	m := &TubeMutation{
		config:        c,
		op:            op,
		typ:           TypeTube,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTubeID sets the ID field of the mutation.
func withTubeID(id int) tubeOption {
	return func(m *TubeMutation) {
		var (
			err   error
			once  sync.Once
			value *Tube
		)
		m.oldValue = func(ctx context.Context) (*Tube, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tube.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTube sets the old Tube of the mutation.
func withTube(node *Tube) tubeOption {
	return func(m *TubeMutation) {
		m.oldValue = func(context.Context) (*Tube, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TubeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TubeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TubeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TubeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tube.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTubeID sets the "tube_id" field.
func (m *TubeMutation) SetTubeID(s string) {
	m.tube_id = &s
}

// TubeID returns the value of the "tube_id" field in the mutation.
func (m *TubeMutation) TubeID() (r string, exists bool) {
	v := m.tube_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeID returns the old "tube_id" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeID: %w", err)
	}
	return oldValue.TubeID, nil
}

// ResetTubeID resets all changes to the "tube_id" field.
func (m *TubeMutation) ResetTubeID() {
	m.tube_id = nil
}

// SetSampleID sets the "sample_id" field.
func (m *TubeMutation) SetSampleID(i int) {
	m.sample = &i
}

// SampleID returns the value of the "sample_id" field in the mutation.
func (m *TubeMutation) SampleID() (r int, exists bool) {
	v := m.sample
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleID returns the old "sample_id" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldSampleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleID: %w", err)
	}
	return oldValue.SampleID, nil
}

// ResetSampleID resets all changes to the "sample_id" field.
func (m *TubeMutation) ResetSampleID() {
	m.sample = nil
}

// SetTubeStorage sets the "tube_storage" field.
func (m *TubeMutation) SetTubeStorage(s string) {
	m.tube_storage = &s
}

// TubeStorage returns the value of the "tube_storage" field in the mutation.
func (m *TubeMutation) TubeStorage() (r string, exists bool) {
	v := m.tube_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeStorage returns the old "tube_storage" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeStorage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeStorage: %w", err)
	}
	return oldValue.TubeStorage, nil
}

// ResetTubeStorage resets all changes to the "tube_storage" field.
func (m *TubeMutation) ResetTubeStorage() {
	m.tube_storage = nil
}

// SetTubeReceiveTime sets the "tube_receive_time" field.
func (m *TubeMutation) SetTubeReceiveTime(t time.Time) {
	m.tube_receive_time = &t
}

// TubeReceiveTime returns the value of the "tube_receive_time" field in the mutation.
func (m *TubeMutation) TubeReceiveTime() (r time.Time, exists bool) {
	v := m.tube_receive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeReceiveTime returns the old "tube_receive_time" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeReceiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeReceiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeReceiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeReceiveTime: %w", err)
	}
	return oldValue.TubeReceiveTime, nil
}

// ResetTubeReceiveTime resets all changes to the "tube_receive_time" field.
func (m *TubeMutation) ResetTubeReceiveTime() {
	m.tube_receive_time = nil
}

// SetTubeTurnaroundTime sets the "tube_turnaround_time" field.
func (m *TubeMutation) SetTubeTurnaroundTime(i int) {
	m.tube_turnaround_time = &i
	m.addtube_turnaround_time = nil
}

// TubeTurnaroundTime returns the value of the "tube_turnaround_time" field in the mutation.
func (m *TubeMutation) TubeTurnaroundTime() (r int, exists bool) {
	v := m.tube_turnaround_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeTurnaroundTime returns the old "tube_turnaround_time" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeTurnaroundTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeTurnaroundTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeTurnaroundTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeTurnaroundTime: %w", err)
	}
	return oldValue.TubeTurnaroundTime, nil
}

// AddTubeTurnaroundTime adds i to the "tube_turnaround_time" field.
func (m *TubeMutation) AddTubeTurnaroundTime(i int) {
	if m.addtube_turnaround_time != nil {
		*m.addtube_turnaround_time += i
	} else {
		m.addtube_turnaround_time = &i
	}
}

// AddedTubeTurnaroundTime returns the value that was added to the "tube_turnaround_time" field in this mutation.
func (m *TubeMutation) AddedTubeTurnaroundTime() (r int, exists bool) {
	v := m.addtube_turnaround_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTubeTurnaroundTime resets all changes to the "tube_turnaround_time" field.
func (m *TubeMutation) ResetTubeTurnaroundTime() {
	m.tube_turnaround_time = nil
	m.addtube_turnaround_time = nil
}

// SetTubeStability sets the "tube_stability" field.
func (m *TubeMutation) SetTubeStability(i int) {
	m.tube_stability = &i
	m.addtube_stability = nil
}

// TubeStability returns the value of the "tube_stability" field in the mutation.
func (m *TubeMutation) TubeStability() (r int, exists bool) {
	v := m.tube_stability
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeStability returns the old "tube_stability" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeStability(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeStability: %w", err)
	}
	return oldValue.TubeStability, nil
}

// AddTubeStability adds i to the "tube_stability" field.
func (m *TubeMutation) AddTubeStability(i int) {
	if m.addtube_stability != nil {
		*m.addtube_stability += i
	} else {
		m.addtube_stability = &i
	}
}

// AddedTubeStability returns the value that was added to the "tube_stability" field in this mutation.
func (m *TubeMutation) AddedTubeStability() (r int, exists bool) {
	v := m.addtube_stability
	if v == nil {
		return
	}
	return *v, true
}

// ResetTubeStability resets all changes to the "tube_stability" field.
func (m *TubeMutation) ResetTubeStability() {
	m.tube_stability = nil
	m.addtube_stability = nil
}

// SetIsActive sets the "isActive" field.
func (m *TubeMutation) SetIsActive(b bool) {
	m.isActive = &b
}

// IsActive returns the value of the "isActive" field in the mutation.
func (m *TubeMutation) IsActive() (r bool, exists bool) {
	v := m.isActive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "isActive" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "isActive" field.
func (m *TubeMutation) ResetIsActive() {
	m.isActive = nil
}

// SetIssues sets the "issues" field.
func (m *TubeMutation) SetIssues(s string) {
	m.issues = &s
}

// Issues returns the value of the "issues" field in the mutation.
func (m *TubeMutation) Issues() (r string, exists bool) {
	v := m.issues
	if v == nil {
		return
	}
	return *v, true
}

// OldIssues returns the old "issues" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldIssues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssues: %w", err)
	}
	return oldValue.Issues, nil
}

// ResetIssues resets all changes to the "issues" field.
func (m *TubeMutation) ResetIssues() {
	m.issues = nil
}

// SetTubeCollectionTime sets the "tube_collection_time" field.
func (m *TubeMutation) SetTubeCollectionTime(t time.Time) {
	m.tube_collection_time = &t
}

// TubeCollectionTime returns the value of the "tube_collection_time" field in the mutation.
func (m *TubeMutation) TubeCollectionTime() (r time.Time, exists bool) {
	v := m.tube_collection_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeCollectionTime returns the old "tube_collection_time" field's value of the Tube entity.
// If the Tube object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeMutation) OldTubeCollectionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeCollectionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeCollectionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeCollectionTime: %w", err)
	}
	return oldValue.TubeCollectionTime, nil
}

// ResetTubeCollectionTime resets all changes to the "tube_collection_time" field.
func (m *TubeMutation) ResetTubeCollectionTime() {
	m.tube_collection_time = nil
}

// AddTubeTypeIDs adds the "tube_type" edge to the TubeType entity by ids.
func (m *TubeMutation) AddTubeTypeIDs(ids ...int) {
	if m.tube_type == nil {
		m.tube_type = make(map[int]struct{})
	}
	for i := range ids {
		m.tube_type[ids[i]] = struct{}{}
	}
}

// ClearTubeType clears the "tube_type" edge to the TubeType entity.
func (m *TubeMutation) ClearTubeType() {
	m.clearedtube_type = true
}

// TubeTypeCleared reports if the "tube_type" edge to the TubeType entity was cleared.
func (m *TubeMutation) TubeTypeCleared() bool {
	return m.clearedtube_type
}

// RemoveTubeTypeIDs removes the "tube_type" edge to the TubeType entity by IDs.
func (m *TubeMutation) RemoveTubeTypeIDs(ids ...int) {
	if m.removedtube_type == nil {
		m.removedtube_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tube_type, ids[i])
		m.removedtube_type[ids[i]] = struct{}{}
	}
}

// RemovedTubeType returns the removed IDs of the "tube_type" edge to the TubeType entity.
func (m *TubeMutation) RemovedTubeTypeIDs() (ids []int) {
	for id := range m.removedtube_type {
		ids = append(ids, id)
	}
	return
}

// TubeTypeIDs returns the "tube_type" edge IDs in the mutation.
func (m *TubeMutation) TubeTypeIDs() (ids []int) {
	for id := range m.tube_type {
		ids = append(ids, id)
	}
	return
}

// ResetTubeType resets all changes to the "tube_type" edge.
func (m *TubeMutation) ResetTubeType() {
	m.tube_type = nil
	m.clearedtube_type = false
	m.removedtube_type = nil
}

// ClearSample clears the "sample" edge to the Sample entity.
func (m *TubeMutation) ClearSample() {
	m.clearedsample = true
	m.clearedFields[tube.FieldSampleID] = struct{}{}
}

// SampleCleared reports if the "sample" edge to the Sample entity was cleared.
func (m *TubeMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *TubeMutation) SampleIDs() (ids []int) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *TubeMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the TubeMutation builder.
func (m *TubeMutation) Where(ps ...predicate.Tube) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TubeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TubeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tube, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TubeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TubeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tube).
func (m *TubeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TubeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tube_id != nil {
		fields = append(fields, tube.FieldTubeID)
	}
	if m.sample != nil {
		fields = append(fields, tube.FieldSampleID)
	}
	if m.tube_storage != nil {
		fields = append(fields, tube.FieldTubeStorage)
	}
	if m.tube_receive_time != nil {
		fields = append(fields, tube.FieldTubeReceiveTime)
	}
	if m.tube_turnaround_time != nil {
		fields = append(fields, tube.FieldTubeTurnaroundTime)
	}
	if m.tube_stability != nil {
		fields = append(fields, tube.FieldTubeStability)
	}
	if m.isActive != nil {
		fields = append(fields, tube.FieldIsActive)
	}
	if m.issues != nil {
		fields = append(fields, tube.FieldIssues)
	}
	if m.tube_collection_time != nil {
		fields = append(fields, tube.FieldTubeCollectionTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TubeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tube.FieldTubeID:
		return m.TubeID()
	case tube.FieldSampleID:
		return m.SampleID()
	case tube.FieldTubeStorage:
		return m.TubeStorage()
	case tube.FieldTubeReceiveTime:
		return m.TubeReceiveTime()
	case tube.FieldTubeTurnaroundTime:
		return m.TubeTurnaroundTime()
	case tube.FieldTubeStability:
		return m.TubeStability()
	case tube.FieldIsActive:
		return m.IsActive()
	case tube.FieldIssues:
		return m.Issues()
	case tube.FieldTubeCollectionTime:
		return m.TubeCollectionTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TubeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tube.FieldTubeID:
		return m.OldTubeID(ctx)
	case tube.FieldSampleID:
		return m.OldSampleID(ctx)
	case tube.FieldTubeStorage:
		return m.OldTubeStorage(ctx)
	case tube.FieldTubeReceiveTime:
		return m.OldTubeReceiveTime(ctx)
	case tube.FieldTubeTurnaroundTime:
		return m.OldTubeTurnaroundTime(ctx)
	case tube.FieldTubeStability:
		return m.OldTubeStability(ctx)
	case tube.FieldIsActive:
		return m.OldIsActive(ctx)
	case tube.FieldIssues:
		return m.OldIssues(ctx)
	case tube.FieldTubeCollectionTime:
		return m.OldTubeCollectionTime(ctx)
	}
	return nil, fmt.Errorf("unknown Tube field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tube.FieldTubeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeID(v)
		return nil
	case tube.FieldSampleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleID(v)
		return nil
	case tube.FieldTubeStorage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeStorage(v)
		return nil
	case tube.FieldTubeReceiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeReceiveTime(v)
		return nil
	case tube.FieldTubeTurnaroundTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeTurnaroundTime(v)
		return nil
	case tube.FieldTubeStability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeStability(v)
		return nil
	case tube.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tube.FieldIssues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssues(v)
		return nil
	case tube.FieldTubeCollectionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeCollectionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Tube field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TubeMutation) AddedFields() []string {
	var fields []string
	if m.addtube_turnaround_time != nil {
		fields = append(fields, tube.FieldTubeTurnaroundTime)
	}
	if m.addtube_stability != nil {
		fields = append(fields, tube.FieldTubeStability)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TubeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tube.FieldTubeTurnaroundTime:
		return m.AddedTubeTurnaroundTime()
	case tube.FieldTubeStability:
		return m.AddedTubeStability()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tube.FieldTubeTurnaroundTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTubeTurnaroundTime(v)
		return nil
	case tube.FieldTubeStability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTubeStability(v)
		return nil
	}
	return fmt.Errorf("unknown Tube numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TubeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TubeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TubeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tube nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TubeMutation) ResetField(name string) error {
	switch name {
	case tube.FieldTubeID:
		m.ResetTubeID()
		return nil
	case tube.FieldSampleID:
		m.ResetSampleID()
		return nil
	case tube.FieldTubeStorage:
		m.ResetTubeStorage()
		return nil
	case tube.FieldTubeReceiveTime:
		m.ResetTubeReceiveTime()
		return nil
	case tube.FieldTubeTurnaroundTime:
		m.ResetTubeTurnaroundTime()
		return nil
	case tube.FieldTubeStability:
		m.ResetTubeStability()
		return nil
	case tube.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tube.FieldIssues:
		m.ResetIssues()
		return nil
	case tube.FieldTubeCollectionTime:
		m.ResetTubeCollectionTime()
		return nil
	}
	return fmt.Errorf("unknown Tube field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TubeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tube_type != nil {
		edges = append(edges, tube.EdgeTubeType)
	}
	if m.sample != nil {
		edges = append(edges, tube.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TubeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tube.EdgeTubeType:
		ids := make([]ent.Value, 0, len(m.tube_type))
		for id := range m.tube_type {
			ids = append(ids, id)
		}
		return ids
	case tube.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TubeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtube_type != nil {
		edges = append(edges, tube.EdgeTubeType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TubeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tube.EdgeTubeType:
		ids := make([]ent.Value, 0, len(m.removedtube_type))
		for id := range m.removedtube_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TubeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtube_type {
		edges = append(edges, tube.EdgeTubeType)
	}
	if m.clearedsample {
		edges = append(edges, tube.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TubeMutation) EdgeCleared(name string) bool {
	switch name {
	case tube.EdgeTubeType:
		return m.clearedtube_type
	case tube.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TubeMutation) ClearEdge(name string) error {
	switch name {
	case tube.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown Tube unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TubeMutation) ResetEdge(name string) error {
	switch name {
	case tube.EdgeTubeType:
		m.ResetTubeType()
		return nil
	case tube.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown Tube edge %s", name)
}

// TubeInstructionsMutation represents an operation that mutates the TubeInstructions nodes in the graph.
type TubeInstructionsMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tube_name_enum         *string
	sort_order             *int
	addsort_order          *int
	tube_instructions      *string
	tube_name              *string
	shipping_box           *string
	transfer_tubes_to_send *string
	blood_type             *bool
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*TubeInstructions, error)
	predicates             []predicate.TubeInstructions
}

var _ ent.Mutation = (*TubeInstructionsMutation)(nil)

// tubeinstructionsOption allows management of the mutation configuration using functional options.
type tubeinstructionsOption func(*TubeInstructionsMutation)

// newTubeInstructionsMutation creates new mutation for the TubeInstructions entity.
func newTubeInstructionsMutation(c config, op Op, opts ...tubeinstructionsOption) *TubeInstructionsMutation {
	m := &TubeInstructionsMutation{
		config:        c,
		op:            op,
		typ:           TypeTubeInstructions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTubeInstructionsID sets the ID field of the mutation.
func withTubeInstructionsID(id int) tubeinstructionsOption {
	return func(m *TubeInstructionsMutation) {
		var (
			err   error
			once  sync.Once
			value *TubeInstructions
		)
		m.oldValue = func(ctx context.Context) (*TubeInstructions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TubeInstructions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTubeInstructions sets the old TubeInstructions of the mutation.
func withTubeInstructions(node *TubeInstructions) tubeinstructionsOption {
	return func(m *TubeInstructionsMutation) {
		m.oldValue = func(context.Context) (*TubeInstructions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TubeInstructionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TubeInstructionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TubeInstructionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TubeInstructionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TubeInstructions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTubeNameEnum sets the "tube_name_enum" field.
func (m *TubeInstructionsMutation) SetTubeNameEnum(s string) {
	m.tube_name_enum = &s
}

// TubeNameEnum returns the value of the "tube_name_enum" field in the mutation.
func (m *TubeInstructionsMutation) TubeNameEnum() (r string, exists bool) {
	v := m.tube_name_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeNameEnum returns the old "tube_name_enum" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldTubeNameEnum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeNameEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeNameEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeNameEnum: %w", err)
	}
	return oldValue.TubeNameEnum, nil
}

// ResetTubeNameEnum resets all changes to the "tube_name_enum" field.
func (m *TubeInstructionsMutation) ResetTubeNameEnum() {
	m.tube_name_enum = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *TubeInstructionsMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *TubeInstructionsMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *TubeInstructionsMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *TubeInstructionsMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *TubeInstructionsMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetTubeInstructions sets the "tube_instructions" field.
func (m *TubeInstructionsMutation) SetTubeInstructions(s string) {
	m.tube_instructions = &s
}

// TubeInstructions returns the value of the "tube_instructions" field in the mutation.
func (m *TubeInstructionsMutation) TubeInstructions() (r string, exists bool) {
	v := m.tube_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeInstructions returns the old "tube_instructions" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldTubeInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeInstructions: %w", err)
	}
	return oldValue.TubeInstructions, nil
}

// ResetTubeInstructions resets all changes to the "tube_instructions" field.
func (m *TubeInstructionsMutation) ResetTubeInstructions() {
	m.tube_instructions = nil
}

// SetTubeName sets the "tube_name" field.
func (m *TubeInstructionsMutation) SetTubeName(s string) {
	m.tube_name = &s
}

// TubeName returns the value of the "tube_name" field in the mutation.
func (m *TubeInstructionsMutation) TubeName() (r string, exists bool) {
	v := m.tube_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeName returns the old "tube_name" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldTubeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeName: %w", err)
	}
	return oldValue.TubeName, nil
}

// ResetTubeName resets all changes to the "tube_name" field.
func (m *TubeInstructionsMutation) ResetTubeName() {
	m.tube_name = nil
}

// SetShippingBox sets the "shipping_box" field.
func (m *TubeInstructionsMutation) SetShippingBox(s string) {
	m.shipping_box = &s
}

// ShippingBox returns the value of the "shipping_box" field in the mutation.
func (m *TubeInstructionsMutation) ShippingBox() (r string, exists bool) {
	v := m.shipping_box
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingBox returns the old "shipping_box" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldShippingBox(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingBox: %w", err)
	}
	return oldValue.ShippingBox, nil
}

// ResetShippingBox resets all changes to the "shipping_box" field.
func (m *TubeInstructionsMutation) ResetShippingBox() {
	m.shipping_box = nil
}

// SetTransferTubesToSend sets the "transfer_tubes_to_send" field.
func (m *TubeInstructionsMutation) SetTransferTubesToSend(s string) {
	m.transfer_tubes_to_send = &s
}

// TransferTubesToSend returns the value of the "transfer_tubes_to_send" field in the mutation.
func (m *TubeInstructionsMutation) TransferTubesToSend() (r string, exists bool) {
	v := m.transfer_tubes_to_send
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferTubesToSend returns the old "transfer_tubes_to_send" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldTransferTubesToSend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferTubesToSend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferTubesToSend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferTubesToSend: %w", err)
	}
	return oldValue.TransferTubesToSend, nil
}

// ResetTransferTubesToSend resets all changes to the "transfer_tubes_to_send" field.
func (m *TubeInstructionsMutation) ResetTransferTubesToSend() {
	m.transfer_tubes_to_send = nil
}

// SetBloodType sets the "blood_type" field.
func (m *TubeInstructionsMutation) SetBloodType(b bool) {
	m.blood_type = &b
}

// BloodType returns the value of the "blood_type" field in the mutation.
func (m *TubeInstructionsMutation) BloodType() (r bool, exists bool) {
	v := m.blood_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodType returns the old "blood_type" field's value of the TubeInstructions entity.
// If the TubeInstructions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeInstructionsMutation) OldBloodType(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBloodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBloodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodType: %w", err)
	}
	return oldValue.BloodType, nil
}

// ResetBloodType resets all changes to the "blood_type" field.
func (m *TubeInstructionsMutation) ResetBloodType() {
	m.blood_type = nil
}

// Where appends a list predicates to the TubeInstructionsMutation builder.
func (m *TubeInstructionsMutation) Where(ps ...predicate.TubeInstructions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TubeInstructionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TubeInstructionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TubeInstructions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TubeInstructionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TubeInstructionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TubeInstructions).
func (m *TubeInstructionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TubeInstructionsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tube_name_enum != nil {
		fields = append(fields, tubeinstructions.FieldTubeNameEnum)
	}
	if m.sort_order != nil {
		fields = append(fields, tubeinstructions.FieldSortOrder)
	}
	if m.tube_instructions != nil {
		fields = append(fields, tubeinstructions.FieldTubeInstructions)
	}
	if m.tube_name != nil {
		fields = append(fields, tubeinstructions.FieldTubeName)
	}
	if m.shipping_box != nil {
		fields = append(fields, tubeinstructions.FieldShippingBox)
	}
	if m.transfer_tubes_to_send != nil {
		fields = append(fields, tubeinstructions.FieldTransferTubesToSend)
	}
	if m.blood_type != nil {
		fields = append(fields, tubeinstructions.FieldBloodType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TubeInstructionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tubeinstructions.FieldTubeNameEnum:
		return m.TubeNameEnum()
	case tubeinstructions.FieldSortOrder:
		return m.SortOrder()
	case tubeinstructions.FieldTubeInstructions:
		return m.TubeInstructions()
	case tubeinstructions.FieldTubeName:
		return m.TubeName()
	case tubeinstructions.FieldShippingBox:
		return m.ShippingBox()
	case tubeinstructions.FieldTransferTubesToSend:
		return m.TransferTubesToSend()
	case tubeinstructions.FieldBloodType:
		return m.BloodType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TubeInstructionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tubeinstructions.FieldTubeNameEnum:
		return m.OldTubeNameEnum(ctx)
	case tubeinstructions.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case tubeinstructions.FieldTubeInstructions:
		return m.OldTubeInstructions(ctx)
	case tubeinstructions.FieldTubeName:
		return m.OldTubeName(ctx)
	case tubeinstructions.FieldShippingBox:
		return m.OldShippingBox(ctx)
	case tubeinstructions.FieldTransferTubesToSend:
		return m.OldTransferTubesToSend(ctx)
	case tubeinstructions.FieldBloodType:
		return m.OldBloodType(ctx)
	}
	return nil, fmt.Errorf("unknown TubeInstructions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeInstructionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tubeinstructions.FieldTubeNameEnum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeNameEnum(v)
		return nil
	case tubeinstructions.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case tubeinstructions.FieldTubeInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeInstructions(v)
		return nil
	case tubeinstructions.FieldTubeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeName(v)
		return nil
	case tubeinstructions.FieldShippingBox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingBox(v)
		return nil
	case tubeinstructions.FieldTransferTubesToSend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferTubesToSend(v)
		return nil
	case tubeinstructions.FieldBloodType:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodType(v)
		return nil
	}
	return fmt.Errorf("unknown TubeInstructions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TubeInstructionsMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, tubeinstructions.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TubeInstructionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tubeinstructions.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeInstructionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tubeinstructions.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TubeInstructions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TubeInstructionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TubeInstructionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TubeInstructionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TubeInstructions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TubeInstructionsMutation) ResetField(name string) error {
	switch name {
	case tubeinstructions.FieldTubeNameEnum:
		m.ResetTubeNameEnum()
		return nil
	case tubeinstructions.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case tubeinstructions.FieldTubeInstructions:
		m.ResetTubeInstructions()
		return nil
	case tubeinstructions.FieldTubeName:
		m.ResetTubeName()
		return nil
	case tubeinstructions.FieldShippingBox:
		m.ResetShippingBox()
		return nil
	case tubeinstructions.FieldTransferTubesToSend:
		m.ResetTransferTubesToSend()
		return nil
	case tubeinstructions.FieldBloodType:
		m.ResetBloodType()
		return nil
	}
	return fmt.Errorf("unknown TubeInstructions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TubeInstructionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TubeInstructionsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TubeInstructionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TubeInstructionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TubeInstructionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TubeInstructionsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TubeInstructionsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TubeInstructions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TubeInstructionsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TubeInstructions edge %s", name)
}

// TubeReceiveMutation represents an operation that mutates the TubeReceive nodes in the graph.
type TubeReceiveMutation struct {
	config
	op                Op
	typ               string
	id                *int
	tube_type         *string
	received_count    *int
	addreceived_count *int
	received_time     *time.Time
	received_by       *string
	modified_by       *string
	modified_time     *time.Time
	collection_time   *time.Time
	is_redraw         *bool
	is_rerun          *bool
	clearedFields     map[string]struct{}
	sample            *int
	clearedsample     bool
	done              bool
	oldValue          func(context.Context) (*TubeReceive, error)
	predicates        []predicate.TubeReceive
}

var _ ent.Mutation = (*TubeReceiveMutation)(nil)

// tubereceiveOption allows management of the mutation configuration using functional options.
type tubereceiveOption func(*TubeReceiveMutation)

// newTubeReceiveMutation creates new mutation for the TubeReceive entity.
func newTubeReceiveMutation(c config, op Op, opts ...tubereceiveOption) *TubeReceiveMutation {
	m := &TubeReceiveMutation{
		config:        c,
		op:            op,
		typ:           TypeTubeReceive,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTubeReceiveID sets the ID field of the mutation.
func withTubeReceiveID(id int) tubereceiveOption {
	return func(m *TubeReceiveMutation) {
		var (
			err   error
			once  sync.Once
			value *TubeReceive
		)
		m.oldValue = func(ctx context.Context) (*TubeReceive, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TubeReceive.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTubeReceive sets the old TubeReceive of the mutation.
func withTubeReceive(node *TubeReceive) tubereceiveOption {
	return func(m *TubeReceiveMutation) {
		m.oldValue = func(context.Context) (*TubeReceive, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TubeReceiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TubeReceiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TubeReceiveMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TubeReceiveMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TubeReceive.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSampleID sets the "sample_id" field.
func (m *TubeReceiveMutation) SetSampleID(i int) {
	m.sample = &i
}

// SampleID returns the value of the "sample_id" field in the mutation.
func (m *TubeReceiveMutation) SampleID() (r int, exists bool) {
	v := m.sample
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleID returns the old "sample_id" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldSampleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleID: %w", err)
	}
	return oldValue.SampleID, nil
}

// ResetSampleID resets all changes to the "sample_id" field.
func (m *TubeReceiveMutation) ResetSampleID() {
	m.sample = nil
}

// SetTubeType sets the "tube_type" field.
func (m *TubeReceiveMutation) SetTubeType(s string) {
	m.tube_type = &s
}

// TubeType returns the value of the "tube_type" field in the mutation.
func (m *TubeReceiveMutation) TubeType() (r string, exists bool) {
	v := m.tube_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeType returns the old "tube_type" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldTubeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeType: %w", err)
	}
	return oldValue.TubeType, nil
}

// ResetTubeType resets all changes to the "tube_type" field.
func (m *TubeReceiveMutation) ResetTubeType() {
	m.tube_type = nil
}

// SetReceivedCount sets the "received_count" field.
func (m *TubeReceiveMutation) SetReceivedCount(i int) {
	m.received_count = &i
	m.addreceived_count = nil
}

// ReceivedCount returns the value of the "received_count" field in the mutation.
func (m *TubeReceiveMutation) ReceivedCount() (r int, exists bool) {
	v := m.received_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedCount returns the old "received_count" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldReceivedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedCount: %w", err)
	}
	return oldValue.ReceivedCount, nil
}

// AddReceivedCount adds i to the "received_count" field.
func (m *TubeReceiveMutation) AddReceivedCount(i int) {
	if m.addreceived_count != nil {
		*m.addreceived_count += i
	} else {
		m.addreceived_count = &i
	}
}

// AddedReceivedCount returns the value that was added to the "received_count" field in this mutation.
func (m *TubeReceiveMutation) AddedReceivedCount() (r int, exists bool) {
	v := m.addreceived_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedCount resets all changes to the "received_count" field.
func (m *TubeReceiveMutation) ResetReceivedCount() {
	m.received_count = nil
	m.addreceived_count = nil
}

// SetReceivedTime sets the "received_time" field.
func (m *TubeReceiveMutation) SetReceivedTime(t time.Time) {
	m.received_time = &t
}

// ReceivedTime returns the value of the "received_time" field in the mutation.
func (m *TubeReceiveMutation) ReceivedTime() (r time.Time, exists bool) {
	v := m.received_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedTime returns the old "received_time" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldReceivedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedTime: %w", err)
	}
	return oldValue.ReceivedTime, nil
}

// ResetReceivedTime resets all changes to the "received_time" field.
func (m *TubeReceiveMutation) ResetReceivedTime() {
	m.received_time = nil
}

// SetReceivedBy sets the "received_by" field.
func (m *TubeReceiveMutation) SetReceivedBy(s string) {
	m.received_by = &s
}

// ReceivedBy returns the value of the "received_by" field in the mutation.
func (m *TubeReceiveMutation) ReceivedBy() (r string, exists bool) {
	v := m.received_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedBy returns the old "received_by" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldReceivedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedBy: %w", err)
	}
	return oldValue.ReceivedBy, nil
}

// ResetReceivedBy resets all changes to the "received_by" field.
func (m *TubeReceiveMutation) ResetReceivedBy() {
	m.received_by = nil
}

// SetModifiedBy sets the "modified_by" field.
func (m *TubeReceiveMutation) SetModifiedBy(s string) {
	m.modified_by = &s
}

// ModifiedBy returns the value of the "modified_by" field in the mutation.
func (m *TubeReceiveMutation) ModifiedBy() (r string, exists bool) {
	v := m.modified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedBy returns the old "modified_by" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldModifiedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedBy: %w", err)
	}
	return oldValue.ModifiedBy, nil
}

// ClearModifiedBy clears the value of the "modified_by" field.
func (m *TubeReceiveMutation) ClearModifiedBy() {
	m.modified_by = nil
	m.clearedFields[tubereceive.FieldModifiedBy] = struct{}{}
}

// ModifiedByCleared returns if the "modified_by" field was cleared in this mutation.
func (m *TubeReceiveMutation) ModifiedByCleared() bool {
	_, ok := m.clearedFields[tubereceive.FieldModifiedBy]
	return ok
}

// ResetModifiedBy resets all changes to the "modified_by" field.
func (m *TubeReceiveMutation) ResetModifiedBy() {
	m.modified_by = nil
	delete(m.clearedFields, tubereceive.FieldModifiedBy)
}

// SetModifiedTime sets the "modified_time" field.
func (m *TubeReceiveMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *TubeReceiveMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ClearModifiedTime clears the value of the "modified_time" field.
func (m *TubeReceiveMutation) ClearModifiedTime() {
	m.modified_time = nil
	m.clearedFields[tubereceive.FieldModifiedTime] = struct{}{}
}

// ModifiedTimeCleared returns if the "modified_time" field was cleared in this mutation.
func (m *TubeReceiveMutation) ModifiedTimeCleared() bool {
	_, ok := m.clearedFields[tubereceive.FieldModifiedTime]
	return ok
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *TubeReceiveMutation) ResetModifiedTime() {
	m.modified_time = nil
	delete(m.clearedFields, tubereceive.FieldModifiedTime)
}

// SetCollectionTime sets the "collection_time" field.
func (m *TubeReceiveMutation) SetCollectionTime(t time.Time) {
	m.collection_time = &t
}

// CollectionTime returns the value of the "collection_time" field in the mutation.
func (m *TubeReceiveMutation) CollectionTime() (r time.Time, exists bool) {
	v := m.collection_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionTime returns the old "collection_time" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldCollectionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionTime: %w", err)
	}
	return oldValue.CollectionTime, nil
}

// ResetCollectionTime resets all changes to the "collection_time" field.
func (m *TubeReceiveMutation) ResetCollectionTime() {
	m.collection_time = nil
}

// SetIsRedraw sets the "is_redraw" field.
func (m *TubeReceiveMutation) SetIsRedraw(b bool) {
	m.is_redraw = &b
}

// IsRedraw returns the value of the "is_redraw" field in the mutation.
func (m *TubeReceiveMutation) IsRedraw() (r bool, exists bool) {
	v := m.is_redraw
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRedraw returns the old "is_redraw" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldIsRedraw(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRedraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRedraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRedraw: %w", err)
	}
	return oldValue.IsRedraw, nil
}

// ResetIsRedraw resets all changes to the "is_redraw" field.
func (m *TubeReceiveMutation) ResetIsRedraw() {
	m.is_redraw = nil
}

// SetIsRerun sets the "is_rerun" field.
func (m *TubeReceiveMutation) SetIsRerun(b bool) {
	m.is_rerun = &b
}

// IsRerun returns the value of the "is_rerun" field in the mutation.
func (m *TubeReceiveMutation) IsRerun() (r bool, exists bool) {
	v := m.is_rerun
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRerun returns the old "is_rerun" field's value of the TubeReceive entity.
// If the TubeReceive object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeReceiveMutation) OldIsRerun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRerun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRerun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRerun: %w", err)
	}
	return oldValue.IsRerun, nil
}

// ResetIsRerun resets all changes to the "is_rerun" field.
func (m *TubeReceiveMutation) ResetIsRerun() {
	m.is_rerun = nil
}

// ClearSample clears the "sample" edge to the Sample entity.
func (m *TubeReceiveMutation) ClearSample() {
	m.clearedsample = true
	m.clearedFields[tubereceive.FieldSampleID] = struct{}{}
}

// SampleCleared reports if the "sample" edge to the Sample entity was cleared.
func (m *TubeReceiveMutation) SampleCleared() bool {
	return m.clearedsample
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *TubeReceiveMutation) SampleIDs() (ids []int) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *TubeReceiveMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the TubeReceiveMutation builder.
func (m *TubeReceiveMutation) Where(ps ...predicate.TubeReceive) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TubeReceiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TubeReceiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TubeReceive, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TubeReceiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TubeReceiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TubeReceive).
func (m *TubeReceiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TubeReceiveMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.sample != nil {
		fields = append(fields, tubereceive.FieldSampleID)
	}
	if m.tube_type != nil {
		fields = append(fields, tubereceive.FieldTubeType)
	}
	if m.received_count != nil {
		fields = append(fields, tubereceive.FieldReceivedCount)
	}
	if m.received_time != nil {
		fields = append(fields, tubereceive.FieldReceivedTime)
	}
	if m.received_by != nil {
		fields = append(fields, tubereceive.FieldReceivedBy)
	}
	if m.modified_by != nil {
		fields = append(fields, tubereceive.FieldModifiedBy)
	}
	if m.modified_time != nil {
		fields = append(fields, tubereceive.FieldModifiedTime)
	}
	if m.collection_time != nil {
		fields = append(fields, tubereceive.FieldCollectionTime)
	}
	if m.is_redraw != nil {
		fields = append(fields, tubereceive.FieldIsRedraw)
	}
	if m.is_rerun != nil {
		fields = append(fields, tubereceive.FieldIsRerun)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TubeReceiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tubereceive.FieldSampleID:
		return m.SampleID()
	case tubereceive.FieldTubeType:
		return m.TubeType()
	case tubereceive.FieldReceivedCount:
		return m.ReceivedCount()
	case tubereceive.FieldReceivedTime:
		return m.ReceivedTime()
	case tubereceive.FieldReceivedBy:
		return m.ReceivedBy()
	case tubereceive.FieldModifiedBy:
		return m.ModifiedBy()
	case tubereceive.FieldModifiedTime:
		return m.ModifiedTime()
	case tubereceive.FieldCollectionTime:
		return m.CollectionTime()
	case tubereceive.FieldIsRedraw:
		return m.IsRedraw()
	case tubereceive.FieldIsRerun:
		return m.IsRerun()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TubeReceiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tubereceive.FieldSampleID:
		return m.OldSampleID(ctx)
	case tubereceive.FieldTubeType:
		return m.OldTubeType(ctx)
	case tubereceive.FieldReceivedCount:
		return m.OldReceivedCount(ctx)
	case tubereceive.FieldReceivedTime:
		return m.OldReceivedTime(ctx)
	case tubereceive.FieldReceivedBy:
		return m.OldReceivedBy(ctx)
	case tubereceive.FieldModifiedBy:
		return m.OldModifiedBy(ctx)
	case tubereceive.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	case tubereceive.FieldCollectionTime:
		return m.OldCollectionTime(ctx)
	case tubereceive.FieldIsRedraw:
		return m.OldIsRedraw(ctx)
	case tubereceive.FieldIsRerun:
		return m.OldIsRerun(ctx)
	}
	return nil, fmt.Errorf("unknown TubeReceive field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeReceiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tubereceive.FieldSampleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleID(v)
		return nil
	case tubereceive.FieldTubeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeType(v)
		return nil
	case tubereceive.FieldReceivedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedCount(v)
		return nil
	case tubereceive.FieldReceivedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedTime(v)
		return nil
	case tubereceive.FieldReceivedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedBy(v)
		return nil
	case tubereceive.FieldModifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedBy(v)
		return nil
	case tubereceive.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	case tubereceive.FieldCollectionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionTime(v)
		return nil
	case tubereceive.FieldIsRedraw:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRedraw(v)
		return nil
	case tubereceive.FieldIsRerun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRerun(v)
		return nil
	}
	return fmt.Errorf("unknown TubeReceive field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TubeReceiveMutation) AddedFields() []string {
	var fields []string
	if m.addreceived_count != nil {
		fields = append(fields, tubereceive.FieldReceivedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TubeReceiveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tubereceive.FieldReceivedCount:
		return m.AddedReceivedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeReceiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tubereceive.FieldReceivedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedCount(v)
		return nil
	}
	return fmt.Errorf("unknown TubeReceive numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TubeReceiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tubereceive.FieldModifiedBy) {
		fields = append(fields, tubereceive.FieldModifiedBy)
	}
	if m.FieldCleared(tubereceive.FieldModifiedTime) {
		fields = append(fields, tubereceive.FieldModifiedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TubeReceiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TubeReceiveMutation) ClearField(name string) error {
	switch name {
	case tubereceive.FieldModifiedBy:
		m.ClearModifiedBy()
		return nil
	case tubereceive.FieldModifiedTime:
		m.ClearModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown TubeReceive nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TubeReceiveMutation) ResetField(name string) error {
	switch name {
	case tubereceive.FieldSampleID:
		m.ResetSampleID()
		return nil
	case tubereceive.FieldTubeType:
		m.ResetTubeType()
		return nil
	case tubereceive.FieldReceivedCount:
		m.ResetReceivedCount()
		return nil
	case tubereceive.FieldReceivedTime:
		m.ResetReceivedTime()
		return nil
	case tubereceive.FieldReceivedBy:
		m.ResetReceivedBy()
		return nil
	case tubereceive.FieldModifiedBy:
		m.ResetModifiedBy()
		return nil
	case tubereceive.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	case tubereceive.FieldCollectionTime:
		m.ResetCollectionTime()
		return nil
	case tubereceive.FieldIsRedraw:
		m.ResetIsRedraw()
		return nil
	case tubereceive.FieldIsRerun:
		m.ResetIsRerun()
		return nil
	}
	return fmt.Errorf("unknown TubeReceive field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TubeReceiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sample != nil {
		edges = append(edges, tubereceive.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TubeReceiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tubereceive.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TubeReceiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TubeReceiveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TubeReceiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsample {
		edges = append(edges, tubereceive.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TubeReceiveMutation) EdgeCleared(name string) bool {
	switch name {
	case tubereceive.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TubeReceiveMutation) ClearEdge(name string) error {
	switch name {
	case tubereceive.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown TubeReceive unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TubeReceiveMutation) ResetEdge(name string) error {
	switch name {
	case tubereceive.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown TubeReceive edge %s", name)
}

// TubeRequirementMutation represents an operation that mutates the TubeRequirement nodes in the graph.
type TubeRequirementMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	tube_type                  *string
	required_count             *int
	addrequired_count          *int
	required_count_create_time *time.Time
	required_by                *string
	modified_by                *string
	modified_time              *time.Time
	clearedFields              map[string]struct{}
	sample                     *int
	clearedsample              bool
	done                       bool
	oldValue                   func(context.Context) (*TubeRequirement, error)
	predicates                 []predicate.TubeRequirement
}

var _ ent.Mutation = (*TubeRequirementMutation)(nil)

// tuberequirementOption allows management of the mutation configuration using functional options.
type tuberequirementOption func(*TubeRequirementMutation)

// newTubeRequirementMutation creates new mutation for the TubeRequirement entity.
func newTubeRequirementMutation(c config, op Op, opts ...tuberequirementOption) *TubeRequirementMutation {
	m := &TubeRequirementMutation{
		config:        c,
		op:            op,
		typ:           TypeTubeRequirement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTubeRequirementID sets the ID field of the mutation.
func withTubeRequirementID(id int) tuberequirementOption {
	return func(m *TubeRequirementMutation) {
		var (
			err   error
			once  sync.Once
			value *TubeRequirement
		)
		m.oldValue = func(ctx context.Context) (*TubeRequirement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TubeRequirement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTubeRequirement sets the old TubeRequirement of the mutation.
func withTubeRequirement(node *TubeRequirement) tuberequirementOption {
	return func(m *TubeRequirementMutation) {
		m.oldValue = func(context.Context) (*TubeRequirement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TubeRequirementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TubeRequirementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TubeRequirementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TubeRequirementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TubeRequirement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSampleID sets the "sample_id" field.
func (m *TubeRequirementMutation) SetSampleID(i int) {
	m.sample = &i
}

// SampleID returns the value of the "sample_id" field in the mutation.
func (m *TubeRequirementMutation) SampleID() (r int, exists bool) {
	v := m.sample
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleID returns the old "sample_id" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldSampleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleID: %w", err)
	}
	return oldValue.SampleID, nil
}

// ClearSampleID clears the value of the "sample_id" field.
func (m *TubeRequirementMutation) ClearSampleID() {
	m.sample = nil
	m.clearedFields[tuberequirement.FieldSampleID] = struct{}{}
}

// SampleIDCleared returns if the "sample_id" field was cleared in this mutation.
func (m *TubeRequirementMutation) SampleIDCleared() bool {
	_, ok := m.clearedFields[tuberequirement.FieldSampleID]
	return ok
}

// ResetSampleID resets all changes to the "sample_id" field.
func (m *TubeRequirementMutation) ResetSampleID() {
	m.sample = nil
	delete(m.clearedFields, tuberequirement.FieldSampleID)
}

// SetTubeType sets the "tube_type" field.
func (m *TubeRequirementMutation) SetTubeType(s string) {
	m.tube_type = &s
}

// TubeType returns the value of the "tube_type" field in the mutation.
func (m *TubeRequirementMutation) TubeType() (r string, exists bool) {
	v := m.tube_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeType returns the old "tube_type" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldTubeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeType: %w", err)
	}
	return oldValue.TubeType, nil
}

// ResetTubeType resets all changes to the "tube_type" field.
func (m *TubeRequirementMutation) ResetTubeType() {
	m.tube_type = nil
}

// SetRequiredCount sets the "required_count" field.
func (m *TubeRequirementMutation) SetRequiredCount(i int) {
	m.required_count = &i
	m.addrequired_count = nil
}

// RequiredCount returns the value of the "required_count" field in the mutation.
func (m *TubeRequirementMutation) RequiredCount() (r int, exists bool) {
	v := m.required_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredCount returns the old "required_count" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldRequiredCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredCount: %w", err)
	}
	return oldValue.RequiredCount, nil
}

// AddRequiredCount adds i to the "required_count" field.
func (m *TubeRequirementMutation) AddRequiredCount(i int) {
	if m.addrequired_count != nil {
		*m.addrequired_count += i
	} else {
		m.addrequired_count = &i
	}
}

// AddedRequiredCount returns the value that was added to the "required_count" field in this mutation.
func (m *TubeRequirementMutation) AddedRequiredCount() (r int, exists bool) {
	v := m.addrequired_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequiredCount resets all changes to the "required_count" field.
func (m *TubeRequirementMutation) ResetRequiredCount() {
	m.required_count = nil
	m.addrequired_count = nil
}

// SetRequiredCountCreateTime sets the "required_count_create_time" field.
func (m *TubeRequirementMutation) SetRequiredCountCreateTime(t time.Time) {
	m.required_count_create_time = &t
}

// RequiredCountCreateTime returns the value of the "required_count_create_time" field in the mutation.
func (m *TubeRequirementMutation) RequiredCountCreateTime() (r time.Time, exists bool) {
	v := m.required_count_create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredCountCreateTime returns the old "required_count_create_time" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldRequiredCountCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredCountCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredCountCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredCountCreateTime: %w", err)
	}
	return oldValue.RequiredCountCreateTime, nil
}

// ResetRequiredCountCreateTime resets all changes to the "required_count_create_time" field.
func (m *TubeRequirementMutation) ResetRequiredCountCreateTime() {
	m.required_count_create_time = nil
}

// SetRequiredBy sets the "required_by" field.
func (m *TubeRequirementMutation) SetRequiredBy(s string) {
	m.required_by = &s
}

// RequiredBy returns the value of the "required_by" field in the mutation.
func (m *TubeRequirementMutation) RequiredBy() (r string, exists bool) {
	v := m.required_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredBy returns the old "required_by" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldRequiredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredBy: %w", err)
	}
	return oldValue.RequiredBy, nil
}

// ResetRequiredBy resets all changes to the "required_by" field.
func (m *TubeRequirementMutation) ResetRequiredBy() {
	m.required_by = nil
}

// SetModifiedBy sets the "modified_by" field.
func (m *TubeRequirementMutation) SetModifiedBy(s string) {
	m.modified_by = &s
}

// ModifiedBy returns the value of the "modified_by" field in the mutation.
func (m *TubeRequirementMutation) ModifiedBy() (r string, exists bool) {
	v := m.modified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedBy returns the old "modified_by" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldModifiedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedBy: %w", err)
	}
	return oldValue.ModifiedBy, nil
}

// ClearModifiedBy clears the value of the "modified_by" field.
func (m *TubeRequirementMutation) ClearModifiedBy() {
	m.modified_by = nil
	m.clearedFields[tuberequirement.FieldModifiedBy] = struct{}{}
}

// ModifiedByCleared returns if the "modified_by" field was cleared in this mutation.
func (m *TubeRequirementMutation) ModifiedByCleared() bool {
	_, ok := m.clearedFields[tuberequirement.FieldModifiedBy]
	return ok
}

// ResetModifiedBy resets all changes to the "modified_by" field.
func (m *TubeRequirementMutation) ResetModifiedBy() {
	m.modified_by = nil
	delete(m.clearedFields, tuberequirement.FieldModifiedBy)
}

// SetModifiedTime sets the "modified_time" field.
func (m *TubeRequirementMutation) SetModifiedTime(t time.Time) {
	m.modified_time = &t
}

// ModifiedTime returns the value of the "modified_time" field in the mutation.
func (m *TubeRequirementMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modified_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modified_time" field's value of the TubeRequirement entity.
// If the TubeRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeRequirementMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modified_time" field.
func (m *TubeRequirementMutation) ResetModifiedTime() {
	m.modified_time = nil
}

// ClearSample clears the "sample" edge to the Sample entity.
func (m *TubeRequirementMutation) ClearSample() {
	m.clearedsample = true
	m.clearedFields[tuberequirement.FieldSampleID] = struct{}{}
}

// SampleCleared reports if the "sample" edge to the Sample entity was cleared.
func (m *TubeRequirementMutation) SampleCleared() bool {
	return m.SampleIDCleared() || m.clearedsample
}

// SampleIDs returns the "sample" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SampleID instead. It exists only for internal usage by the builders.
func (m *TubeRequirementMutation) SampleIDs() (ids []int) {
	if id := m.sample; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSample resets all changes to the "sample" edge.
func (m *TubeRequirementMutation) ResetSample() {
	m.sample = nil
	m.clearedsample = false
}

// Where appends a list predicates to the TubeRequirementMutation builder.
func (m *TubeRequirementMutation) Where(ps ...predicate.TubeRequirement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TubeRequirementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TubeRequirementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TubeRequirement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TubeRequirementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TubeRequirementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TubeRequirement).
func (m *TubeRequirementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TubeRequirementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.sample != nil {
		fields = append(fields, tuberequirement.FieldSampleID)
	}
	if m.tube_type != nil {
		fields = append(fields, tuberequirement.FieldTubeType)
	}
	if m.required_count != nil {
		fields = append(fields, tuberequirement.FieldRequiredCount)
	}
	if m.required_count_create_time != nil {
		fields = append(fields, tuberequirement.FieldRequiredCountCreateTime)
	}
	if m.required_by != nil {
		fields = append(fields, tuberequirement.FieldRequiredBy)
	}
	if m.modified_by != nil {
		fields = append(fields, tuberequirement.FieldModifiedBy)
	}
	if m.modified_time != nil {
		fields = append(fields, tuberequirement.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TubeRequirementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tuberequirement.FieldSampleID:
		return m.SampleID()
	case tuberequirement.FieldTubeType:
		return m.TubeType()
	case tuberequirement.FieldRequiredCount:
		return m.RequiredCount()
	case tuberequirement.FieldRequiredCountCreateTime:
		return m.RequiredCountCreateTime()
	case tuberequirement.FieldRequiredBy:
		return m.RequiredBy()
	case tuberequirement.FieldModifiedBy:
		return m.ModifiedBy()
	case tuberequirement.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TubeRequirementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tuberequirement.FieldSampleID:
		return m.OldSampleID(ctx)
	case tuberequirement.FieldTubeType:
		return m.OldTubeType(ctx)
	case tuberequirement.FieldRequiredCount:
		return m.OldRequiredCount(ctx)
	case tuberequirement.FieldRequiredCountCreateTime:
		return m.OldRequiredCountCreateTime(ctx)
	case tuberequirement.FieldRequiredBy:
		return m.OldRequiredBy(ctx)
	case tuberequirement.FieldModifiedBy:
		return m.OldModifiedBy(ctx)
	case tuberequirement.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown TubeRequirement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeRequirementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tuberequirement.FieldSampleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleID(v)
		return nil
	case tuberequirement.FieldTubeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeType(v)
		return nil
	case tuberequirement.FieldRequiredCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredCount(v)
		return nil
	case tuberequirement.FieldRequiredCountCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredCountCreateTime(v)
		return nil
	case tuberequirement.FieldRequiredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredBy(v)
		return nil
	case tuberequirement.FieldModifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedBy(v)
		return nil
	case tuberequirement.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TubeRequirementMutation) AddedFields() []string {
	var fields []string
	if m.addrequired_count != nil {
		fields = append(fields, tuberequirement.FieldRequiredCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TubeRequirementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tuberequirement.FieldRequiredCount:
		return m.AddedRequiredCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeRequirementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tuberequirement.FieldRequiredCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequiredCount(v)
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TubeRequirementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tuberequirement.FieldSampleID) {
		fields = append(fields, tuberequirement.FieldSampleID)
	}
	if m.FieldCleared(tuberequirement.FieldModifiedBy) {
		fields = append(fields, tuberequirement.FieldModifiedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TubeRequirementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TubeRequirementMutation) ClearField(name string) error {
	switch name {
	case tuberequirement.FieldSampleID:
		m.ClearSampleID()
		return nil
	case tuberequirement.FieldModifiedBy:
		m.ClearModifiedBy()
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TubeRequirementMutation) ResetField(name string) error {
	switch name {
	case tuberequirement.FieldSampleID:
		m.ResetSampleID()
		return nil
	case tuberequirement.FieldTubeType:
		m.ResetTubeType()
		return nil
	case tuberequirement.FieldRequiredCount:
		m.ResetRequiredCount()
		return nil
	case tuberequirement.FieldRequiredCountCreateTime:
		m.ResetRequiredCountCreateTime()
		return nil
	case tuberequirement.FieldRequiredBy:
		m.ResetRequiredBy()
		return nil
	case tuberequirement.FieldModifiedBy:
		m.ResetModifiedBy()
		return nil
	case tuberequirement.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TubeRequirementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sample != nil {
		edges = append(edges, tuberequirement.EdgeSample)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TubeRequirementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tuberequirement.EdgeSample:
		if id := m.sample; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TubeRequirementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TubeRequirementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TubeRequirementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsample {
		edges = append(edges, tuberequirement.EdgeSample)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TubeRequirementMutation) EdgeCleared(name string) bool {
	switch name {
	case tuberequirement.EdgeSample:
		return m.clearedsample
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TubeRequirementMutation) ClearEdge(name string) error {
	switch name {
	case tuberequirement.EdgeSample:
		m.ClearSample()
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TubeRequirementMutation) ResetEdge(name string) error {
	switch name {
	case tuberequirement.EdgeSample:
		m.ResetSample()
		return nil
	}
	return fmt.Errorf("unknown TubeRequirement edge %s", name)
}

// TubeTypeMutation represents an operation that mutates the TubeType nodes in the graph.
type TubeTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	tube_name           *string
	tube_type_enum      *string
	tube_type_symbol    *string
	clearedFields       map[string]struct{}
	tube                map[int]struct{}
	removedtube         map[int]struct{}
	clearedtube         bool
	sample_types        map[int]struct{}
	removedsample_types map[int]struct{}
	clearedsample_types bool
	tests               map[int]struct{}
	removedtests        map[int]struct{}
	clearedtests        bool
	done                bool
	oldValue            func(context.Context) (*TubeType, error)
	predicates          []predicate.TubeType
}

var _ ent.Mutation = (*TubeTypeMutation)(nil)

// tubetypeOption allows management of the mutation configuration using functional options.
type tubetypeOption func(*TubeTypeMutation)

// newTubeTypeMutation creates new mutation for the TubeType entity.
func newTubeTypeMutation(c config, op Op, opts ...tubetypeOption) *TubeTypeMutation {
	m := &TubeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTubeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTubeTypeID sets the ID field of the mutation.
func withTubeTypeID(id int) tubetypeOption {
	return func(m *TubeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TubeType
		)
		m.oldValue = func(ctx context.Context) (*TubeType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TubeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTubeType sets the old TubeType of the mutation.
func withTubeType(node *TubeType) tubetypeOption {
	return func(m *TubeTypeMutation) {
		m.oldValue = func(context.Context) (*TubeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TubeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TubeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TubeTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TubeTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TubeType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTubeName sets the "tube_name" field.
func (m *TubeTypeMutation) SetTubeName(s string) {
	m.tube_name = &s
}

// TubeName returns the value of the "tube_name" field in the mutation.
func (m *TubeTypeMutation) TubeName() (r string, exists bool) {
	v := m.tube_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeName returns the old "tube_name" field's value of the TubeType entity.
// If the TubeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeTypeMutation) OldTubeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeName: %w", err)
	}
	return oldValue.TubeName, nil
}

// ResetTubeName resets all changes to the "tube_name" field.
func (m *TubeTypeMutation) ResetTubeName() {
	m.tube_name = nil
}

// SetTubeTypeEnum sets the "tube_type_enum" field.
func (m *TubeTypeMutation) SetTubeTypeEnum(s string) {
	m.tube_type_enum = &s
}

// TubeTypeEnum returns the value of the "tube_type_enum" field in the mutation.
func (m *TubeTypeMutation) TubeTypeEnum() (r string, exists bool) {
	v := m.tube_type_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeTypeEnum returns the old "tube_type_enum" field's value of the TubeType entity.
// If the TubeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeTypeMutation) OldTubeTypeEnum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeTypeEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeTypeEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeTypeEnum: %w", err)
	}
	return oldValue.TubeTypeEnum, nil
}

// ResetTubeTypeEnum resets all changes to the "tube_type_enum" field.
func (m *TubeTypeMutation) ResetTubeTypeEnum() {
	m.tube_type_enum = nil
}

// SetTubeTypeSymbol sets the "tube_type_symbol" field.
func (m *TubeTypeMutation) SetTubeTypeSymbol(s string) {
	m.tube_type_symbol = &s
}

// TubeTypeSymbol returns the value of the "tube_type_symbol" field in the mutation.
func (m *TubeTypeMutation) TubeTypeSymbol() (r string, exists bool) {
	v := m.tube_type_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldTubeTypeSymbol returns the old "tube_type_symbol" field's value of the TubeType entity.
// If the TubeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TubeTypeMutation) OldTubeTypeSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTubeTypeSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTubeTypeSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTubeTypeSymbol: %w", err)
	}
	return oldValue.TubeTypeSymbol, nil
}

// ResetTubeTypeSymbol resets all changes to the "tube_type_symbol" field.
func (m *TubeTypeMutation) ResetTubeTypeSymbol() {
	m.tube_type_symbol = nil
}

// AddTubeIDs adds the "tube" edge to the Tube entity by ids.
func (m *TubeTypeMutation) AddTubeIDs(ids ...int) {
	if m.tube == nil {
		m.tube = make(map[int]struct{})
	}
	for i := range ids {
		m.tube[ids[i]] = struct{}{}
	}
}

// ClearTube clears the "tube" edge to the Tube entity.
func (m *TubeTypeMutation) ClearTube() {
	m.clearedtube = true
}

// TubeCleared reports if the "tube" edge to the Tube entity was cleared.
func (m *TubeTypeMutation) TubeCleared() bool {
	return m.clearedtube
}

// RemoveTubeIDs removes the "tube" edge to the Tube entity by IDs.
func (m *TubeTypeMutation) RemoveTubeIDs(ids ...int) {
	if m.removedtube == nil {
		m.removedtube = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tube, ids[i])
		m.removedtube[ids[i]] = struct{}{}
	}
}

// RemovedTube returns the removed IDs of the "tube" edge to the Tube entity.
func (m *TubeTypeMutation) RemovedTubeIDs() (ids []int) {
	for id := range m.removedtube {
		ids = append(ids, id)
	}
	return
}

// TubeIDs returns the "tube" edge IDs in the mutation.
func (m *TubeTypeMutation) TubeIDs() (ids []int) {
	for id := range m.tube {
		ids = append(ids, id)
	}
	return
}

// ResetTube resets all changes to the "tube" edge.
func (m *TubeTypeMutation) ResetTube() {
	m.tube = nil
	m.clearedtube = false
	m.removedtube = nil
}

// AddSampleTypeIDs adds the "sample_types" edge to the SampleType entity by ids.
func (m *TubeTypeMutation) AddSampleTypeIDs(ids ...int) {
	if m.sample_types == nil {
		m.sample_types = make(map[int]struct{})
	}
	for i := range ids {
		m.sample_types[ids[i]] = struct{}{}
	}
}

// ClearSampleTypes clears the "sample_types" edge to the SampleType entity.
func (m *TubeTypeMutation) ClearSampleTypes() {
	m.clearedsample_types = true
}

// SampleTypesCleared reports if the "sample_types" edge to the SampleType entity was cleared.
func (m *TubeTypeMutation) SampleTypesCleared() bool {
	return m.clearedsample_types
}

// RemoveSampleTypeIDs removes the "sample_types" edge to the SampleType entity by IDs.
func (m *TubeTypeMutation) RemoveSampleTypeIDs(ids ...int) {
	if m.removedsample_types == nil {
		m.removedsample_types = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sample_types, ids[i])
		m.removedsample_types[ids[i]] = struct{}{}
	}
}

// RemovedSampleTypes returns the removed IDs of the "sample_types" edge to the SampleType entity.
func (m *TubeTypeMutation) RemovedSampleTypesIDs() (ids []int) {
	for id := range m.removedsample_types {
		ids = append(ids, id)
	}
	return
}

// SampleTypesIDs returns the "sample_types" edge IDs in the mutation.
func (m *TubeTypeMutation) SampleTypesIDs() (ids []int) {
	for id := range m.sample_types {
		ids = append(ids, id)
	}
	return
}

// ResetSampleTypes resets all changes to the "sample_types" edge.
func (m *TubeTypeMutation) ResetSampleTypes() {
	m.sample_types = nil
	m.clearedsample_types = false
	m.removedsample_types = nil
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *TubeTypeMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *TubeTypeMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *TubeTypeMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *TubeTypeMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *TubeTypeMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *TubeTypeMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *TubeTypeMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the TubeTypeMutation builder.
func (m *TubeTypeMutation) Where(ps ...predicate.TubeType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TubeTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TubeTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TubeType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TubeTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TubeTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TubeType).
func (m *TubeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TubeTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tube_name != nil {
		fields = append(fields, tubetype.FieldTubeName)
	}
	if m.tube_type_enum != nil {
		fields = append(fields, tubetype.FieldTubeTypeEnum)
	}
	if m.tube_type_symbol != nil {
		fields = append(fields, tubetype.FieldTubeTypeSymbol)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TubeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tubetype.FieldTubeName:
		return m.TubeName()
	case tubetype.FieldTubeTypeEnum:
		return m.TubeTypeEnum()
	case tubetype.FieldTubeTypeSymbol:
		return m.TubeTypeSymbol()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TubeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tubetype.FieldTubeName:
		return m.OldTubeName(ctx)
	case tubetype.FieldTubeTypeEnum:
		return m.OldTubeTypeEnum(ctx)
	case tubetype.FieldTubeTypeSymbol:
		return m.OldTubeTypeSymbol(ctx)
	}
	return nil, fmt.Errorf("unknown TubeType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tubetype.FieldTubeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeName(v)
		return nil
	case tubetype.FieldTubeTypeEnum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeTypeEnum(v)
		return nil
	case tubetype.FieldTubeTypeSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTubeTypeSymbol(v)
		return nil
	}
	return fmt.Errorf("unknown TubeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TubeTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TubeTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TubeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TubeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TubeTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TubeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TubeTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TubeType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TubeTypeMutation) ResetField(name string) error {
	switch name {
	case tubetype.FieldTubeName:
		m.ResetTubeName()
		return nil
	case tubetype.FieldTubeTypeEnum:
		m.ResetTubeTypeEnum()
		return nil
	case tubetype.FieldTubeTypeSymbol:
		m.ResetTubeTypeSymbol()
		return nil
	}
	return fmt.Errorf("unknown TubeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TubeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tube != nil {
		edges = append(edges, tubetype.EdgeTube)
	}
	if m.sample_types != nil {
		edges = append(edges, tubetype.EdgeSampleTypes)
	}
	if m.tests != nil {
		edges = append(edges, tubetype.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TubeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tubetype.EdgeTube:
		ids := make([]ent.Value, 0, len(m.tube))
		for id := range m.tube {
			ids = append(ids, id)
		}
		return ids
	case tubetype.EdgeSampleTypes:
		ids := make([]ent.Value, 0, len(m.sample_types))
		for id := range m.sample_types {
			ids = append(ids, id)
		}
		return ids
	case tubetype.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TubeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtube != nil {
		edges = append(edges, tubetype.EdgeTube)
	}
	if m.removedsample_types != nil {
		edges = append(edges, tubetype.EdgeSampleTypes)
	}
	if m.removedtests != nil {
		edges = append(edges, tubetype.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TubeTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tubetype.EdgeTube:
		ids := make([]ent.Value, 0, len(m.removedtube))
		for id := range m.removedtube {
			ids = append(ids, id)
		}
		return ids
	case tubetype.EdgeSampleTypes:
		ids := make([]ent.Value, 0, len(m.removedsample_types))
		for id := range m.removedsample_types {
			ids = append(ids, id)
		}
		return ids
	case tubetype.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TubeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtube {
		edges = append(edges, tubetype.EdgeTube)
	}
	if m.clearedsample_types {
		edges = append(edges, tubetype.EdgeSampleTypes)
	}
	if m.clearedtests {
		edges = append(edges, tubetype.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TubeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case tubetype.EdgeTube:
		return m.clearedtube
	case tubetype.EdgeSampleTypes:
		return m.clearedsample_types
	case tubetype.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TubeTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TubeType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TubeTypeMutation) ResetEdge(name string) error {
	switch name {
	case tubetype.EdgeTube:
		m.ResetTube()
		return nil
	case tubetype.EdgeSampleTypes:
		m.ResetSampleTypes()
		return nil
	case tubetype.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown TubeType edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	user_name                            *string
	email_user_id                        *string
	password                             *string
	two_factor_authentication_secret     *string
	is_two_factor_authentication_enabled *bool
	user_group                           *string
	imported_user_with_salt_password     *bool
	is_active                            *bool
	clearedFields                        map[string]struct{}
	clinic                               map[int]struct{}
	removedclinic                        map[int]struct{}
	clearedclinic                        bool
	customer                             map[int]struct{}
	removedcustomer                      map[int]struct{}
	clearedcustomer                      bool
	patient                              map[int]struct{}
	removedpatient                       map[int]struct{}
	clearedpatient                       bool
	internal_user                        map[int]struct{}
	removedinternal_user                 map[int]struct{}
	clearedinternal_user                 bool
	done                                 bool
	oldValue                             func(context.Context) (*User, error)
	predicates                           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserName sets the "user_name" field.
func (m *UserMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *UserMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "user_name" field.
func (m *UserMutation) ResetUserName() {
	m.user_name = nil
}

// SetEmailUserID sets the "email_user_id" field.
func (m *UserMutation) SetEmailUserID(s string) {
	m.email_user_id = &s
}

// EmailUserID returns the value of the "email_user_id" field in the mutation.
func (m *UserMutation) EmailUserID() (r string, exists bool) {
	v := m.email_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailUserID returns the old "email_user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailUserID: %w", err)
	}
	return oldValue.EmailUserID, nil
}

// ClearEmailUserID clears the value of the "email_user_id" field.
func (m *UserMutation) ClearEmailUserID() {
	m.email_user_id = nil
	m.clearedFields[user.FieldEmailUserID] = struct{}{}
}

// EmailUserIDCleared returns if the "email_user_id" field was cleared in this mutation.
func (m *UserMutation) EmailUserIDCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailUserID]
	return ok
}

// ResetEmailUserID resets all changes to the "email_user_id" field.
func (m *UserMutation) ResetEmailUserID() {
	m.email_user_id = nil
	delete(m.clearedFields, user.FieldEmailUserID)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetTwoFactorAuthenticationSecret sets the "two_factor_authentication_secret" field.
func (m *UserMutation) SetTwoFactorAuthenticationSecret(s string) {
	m.two_factor_authentication_secret = &s
}

// TwoFactorAuthenticationSecret returns the value of the "two_factor_authentication_secret" field in the mutation.
func (m *UserMutation) TwoFactorAuthenticationSecret() (r string, exists bool) {
	v := m.two_factor_authentication_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthenticationSecret returns the old "two_factor_authentication_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTwoFactorAuthenticationSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthenticationSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthenticationSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthenticationSecret: %w", err)
	}
	return oldValue.TwoFactorAuthenticationSecret, nil
}

// ClearTwoFactorAuthenticationSecret clears the value of the "two_factor_authentication_secret" field.
func (m *UserMutation) ClearTwoFactorAuthenticationSecret() {
	m.two_factor_authentication_secret = nil
	m.clearedFields[user.FieldTwoFactorAuthenticationSecret] = struct{}{}
}

// TwoFactorAuthenticationSecretCleared returns if the "two_factor_authentication_secret" field was cleared in this mutation.
func (m *UserMutation) TwoFactorAuthenticationSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTwoFactorAuthenticationSecret]
	return ok
}

// ResetTwoFactorAuthenticationSecret resets all changes to the "two_factor_authentication_secret" field.
func (m *UserMutation) ResetTwoFactorAuthenticationSecret() {
	m.two_factor_authentication_secret = nil
	delete(m.clearedFields, user.FieldTwoFactorAuthenticationSecret)
}

// SetIsTwoFactorAuthenticationEnabled sets the "is_two_factor_authentication_enabled" field.
func (m *UserMutation) SetIsTwoFactorAuthenticationEnabled(b bool) {
	m.is_two_factor_authentication_enabled = &b
}

// IsTwoFactorAuthenticationEnabled returns the value of the "is_two_factor_authentication_enabled" field in the mutation.
func (m *UserMutation) IsTwoFactorAuthenticationEnabled() (r bool, exists bool) {
	v := m.is_two_factor_authentication_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTwoFactorAuthenticationEnabled returns the old "is_two_factor_authentication_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsTwoFactorAuthenticationEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTwoFactorAuthenticationEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTwoFactorAuthenticationEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTwoFactorAuthenticationEnabled: %w", err)
	}
	return oldValue.IsTwoFactorAuthenticationEnabled, nil
}

// ResetIsTwoFactorAuthenticationEnabled resets all changes to the "is_two_factor_authentication_enabled" field.
func (m *UserMutation) ResetIsTwoFactorAuthenticationEnabled() {
	m.is_two_factor_authentication_enabled = nil
}

// SetUserGroup sets the "user_group" field.
func (m *UserMutation) SetUserGroup(s string) {
	m.user_group = &s
}

// UserGroup returns the value of the "user_group" field in the mutation.
func (m *UserMutation) UserGroup() (r string, exists bool) {
	v := m.user_group
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroup returns the old "user_group" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroup: %w", err)
	}
	return oldValue.UserGroup, nil
}

// ClearUserGroup clears the value of the "user_group" field.
func (m *UserMutation) ClearUserGroup() {
	m.user_group = nil
	m.clearedFields[user.FieldUserGroup] = struct{}{}
}

// UserGroupCleared returns if the "user_group" field was cleared in this mutation.
func (m *UserMutation) UserGroupCleared() bool {
	_, ok := m.clearedFields[user.FieldUserGroup]
	return ok
}

// ResetUserGroup resets all changes to the "user_group" field.
func (m *UserMutation) ResetUserGroup() {
	m.user_group = nil
	delete(m.clearedFields, user.FieldUserGroup)
}

// SetImportedUserWithSaltPassword sets the "imported_user_with_salt_password" field.
func (m *UserMutation) SetImportedUserWithSaltPassword(b bool) {
	m.imported_user_with_salt_password = &b
}

// ImportedUserWithSaltPassword returns the value of the "imported_user_with_salt_password" field in the mutation.
func (m *UserMutation) ImportedUserWithSaltPassword() (r bool, exists bool) {
	v := m.imported_user_with_salt_password
	if v == nil {
		return
	}
	return *v, true
}

// OldImportedUserWithSaltPassword returns the old "imported_user_with_salt_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldImportedUserWithSaltPassword(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportedUserWithSaltPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportedUserWithSaltPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportedUserWithSaltPassword: %w", err)
	}
	return oldValue.ImportedUserWithSaltPassword, nil
}

// ResetImportedUserWithSaltPassword resets all changes to the "imported_user_with_salt_password" field.
func (m *UserMutation) ResetImportedUserWithSaltPassword() {
	m.imported_user_with_salt_password = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// AddClinicIDs adds the "clinic" edge to the Clinic entity by ids.
func (m *UserMutation) AddClinicIDs(ids ...int) {
	if m.clinic == nil {
		m.clinic = make(map[int]struct{})
	}
	for i := range ids {
		m.clinic[ids[i]] = struct{}{}
	}
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *UserMutation) ClearClinic() {
	m.clearedclinic = true
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *UserMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// RemoveClinicIDs removes the "clinic" edge to the Clinic entity by IDs.
func (m *UserMutation) RemoveClinicIDs(ids ...int) {
	if m.removedclinic == nil {
		m.removedclinic = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clinic, ids[i])
		m.removedclinic[ids[i]] = struct{}{}
	}
}

// RemovedClinic returns the removed IDs of the "clinic" edge to the Clinic entity.
func (m *UserMutation) RemovedClinicIDs() (ids []int) {
	for id := range m.removedclinic {
		ids = append(ids, id)
	}
	return
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
func (m *UserMutation) ClinicIDs() (ids []int) {
	for id := range m.clinic {
		ids = append(ids, id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *UserMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
	m.removedclinic = nil
}

// AddCustomerIDs adds the "customer" edge to the Customer entity by ids.
func (m *UserMutation) AddCustomerIDs(ids ...int) {
	if m.customer == nil {
		m.customer = make(map[int]struct{})
	}
	for i := range ids {
		m.customer[ids[i]] = struct{}{}
	}
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *UserMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *UserMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// RemoveCustomerIDs removes the "customer" edge to the Customer entity by IDs.
func (m *UserMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomer == nil {
		m.removedcustomer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer, ids[i])
		m.removedcustomer[ids[i]] = struct{}{}
	}
}

// RemovedCustomer returns the removed IDs of the "customer" edge to the Customer entity.
func (m *UserMutation) RemovedCustomerIDs() (ids []int) {
	for id := range m.removedcustomer {
		ids = append(ids, id)
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
func (m *UserMutation) CustomerIDs() (ids []int) {
	for id := range m.customer {
		ids = append(ids, id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *UserMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
	m.removedcustomer = nil
}

// AddPatientIDs adds the "patient" edge to the Patient entity by ids.
func (m *UserMutation) AddPatientIDs(ids ...int) {
	if m.patient == nil {
		m.patient = make(map[int]struct{})
	}
	for i := range ids {
		m.patient[ids[i]] = struct{}{}
	}
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *UserMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *UserMutation) PatientCleared() bool {
	return m.clearedpatient
}

// RemovePatientIDs removes the "patient" edge to the Patient entity by IDs.
func (m *UserMutation) RemovePatientIDs(ids ...int) {
	if m.removedpatient == nil {
		m.removedpatient = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.patient, ids[i])
		m.removedpatient[ids[i]] = struct{}{}
	}
}

// RemovedPatient returns the removed IDs of the "patient" edge to the Patient entity.
func (m *UserMutation) RemovedPatientIDs() (ids []int) {
	for id := range m.removedpatient {
		ids = append(ids, id)
	}
	return
}

// PatientIDs returns the "patient" edge IDs in the mutation.
func (m *UserMutation) PatientIDs() (ids []int) {
	for id := range m.patient {
		ids = append(ids, id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *UserMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
	m.removedpatient = nil
}

// AddInternalUserIDs adds the "internal_user" edge to the InternalUser entity by ids.
func (m *UserMutation) AddInternalUserIDs(ids ...int) {
	if m.internal_user == nil {
		m.internal_user = make(map[int]struct{})
	}
	for i := range ids {
		m.internal_user[ids[i]] = struct{}{}
	}
}

// ClearInternalUser clears the "internal_user" edge to the InternalUser entity.
func (m *UserMutation) ClearInternalUser() {
	m.clearedinternal_user = true
}

// InternalUserCleared reports if the "internal_user" edge to the InternalUser entity was cleared.
func (m *UserMutation) InternalUserCleared() bool {
	return m.clearedinternal_user
}

// RemoveInternalUserIDs removes the "internal_user" edge to the InternalUser entity by IDs.
func (m *UserMutation) RemoveInternalUserIDs(ids ...int) {
	if m.removedinternal_user == nil {
		m.removedinternal_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.internal_user, ids[i])
		m.removedinternal_user[ids[i]] = struct{}{}
	}
}

// RemovedInternalUser returns the removed IDs of the "internal_user" edge to the InternalUser entity.
func (m *UserMutation) RemovedInternalUserIDs() (ids []int) {
	for id := range m.removedinternal_user {
		ids = append(ids, id)
	}
	return
}

// InternalUserIDs returns the "internal_user" edge IDs in the mutation.
func (m *UserMutation) InternalUserIDs() (ids []int) {
	for id := range m.internal_user {
		ids = append(ids, id)
	}
	return
}

// ResetInternalUser resets all changes to the "internal_user" edge.
func (m *UserMutation) ResetInternalUser() {
	m.internal_user = nil
	m.clearedinternal_user = false
	m.removedinternal_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_name != nil {
		fields = append(fields, user.FieldUserName)
	}
	if m.email_user_id != nil {
		fields = append(fields, user.FieldEmailUserID)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.two_factor_authentication_secret != nil {
		fields = append(fields, user.FieldTwoFactorAuthenticationSecret)
	}
	if m.is_two_factor_authentication_enabled != nil {
		fields = append(fields, user.FieldIsTwoFactorAuthenticationEnabled)
	}
	if m.user_group != nil {
		fields = append(fields, user.FieldUserGroup)
	}
	if m.imported_user_with_salt_password != nil {
		fields = append(fields, user.FieldImportedUserWithSaltPassword)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserName:
		return m.UserName()
	case user.FieldEmailUserID:
		return m.EmailUserID()
	case user.FieldPassword:
		return m.Password()
	case user.FieldTwoFactorAuthenticationSecret:
		return m.TwoFactorAuthenticationSecret()
	case user.FieldIsTwoFactorAuthenticationEnabled:
		return m.IsTwoFactorAuthenticationEnabled()
	case user.FieldUserGroup:
		return m.UserGroup()
	case user.FieldImportedUserWithSaltPassword:
		return m.ImportedUserWithSaltPassword()
	case user.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserName:
		return m.OldUserName(ctx)
	case user.FieldEmailUserID:
		return m.OldEmailUserID(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldTwoFactorAuthenticationSecret:
		return m.OldTwoFactorAuthenticationSecret(ctx)
	case user.FieldIsTwoFactorAuthenticationEnabled:
		return m.OldIsTwoFactorAuthenticationEnabled(ctx)
	case user.FieldUserGroup:
		return m.OldUserGroup(ctx)
	case user.FieldImportedUserWithSaltPassword:
		return m.OldImportedUserWithSaltPassword(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case user.FieldEmailUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailUserID(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldTwoFactorAuthenticationSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthenticationSecret(v)
		return nil
	case user.FieldIsTwoFactorAuthenticationEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTwoFactorAuthenticationEnabled(v)
		return nil
	case user.FieldUserGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroup(v)
		return nil
	case user.FieldImportedUserWithSaltPassword:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportedUserWithSaltPassword(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmailUserID) {
		fields = append(fields, user.FieldEmailUserID)
	}
	if m.FieldCleared(user.FieldTwoFactorAuthenticationSecret) {
		fields = append(fields, user.FieldTwoFactorAuthenticationSecret)
	}
	if m.FieldCleared(user.FieldUserGroup) {
		fields = append(fields, user.FieldUserGroup)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmailUserID:
		m.ClearEmailUserID()
		return nil
	case user.FieldTwoFactorAuthenticationSecret:
		m.ClearTwoFactorAuthenticationSecret()
		return nil
	case user.FieldUserGroup:
		m.ClearUserGroup()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserName:
		m.ResetUserName()
		return nil
	case user.FieldEmailUserID:
		m.ResetEmailUserID()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldTwoFactorAuthenticationSecret:
		m.ResetTwoFactorAuthenticationSecret()
		return nil
	case user.FieldIsTwoFactorAuthenticationEnabled:
		m.ResetIsTwoFactorAuthenticationEnabled()
		return nil
	case user.FieldUserGroup:
		m.ResetUserGroup()
		return nil
	case user.FieldImportedUserWithSaltPassword:
		m.ResetImportedUserWithSaltPassword()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clinic != nil {
		edges = append(edges, user.EdgeClinic)
	}
	if m.customer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	if m.patient != nil {
		edges = append(edges, user.EdgePatient)
	}
	if m.internal_user != nil {
		edges = append(edges, user.EdgeInternalUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeClinic:
		ids := make([]ent.Value, 0, len(m.clinic))
		for id := range m.clinic {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.customer))
		for id := range m.customer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePatient:
		ids := make([]ent.Value, 0, len(m.patient))
		for id := range m.patient {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInternalUser:
		ids := make([]ent.Value, 0, len(m.internal_user))
		for id := range m.internal_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedclinic != nil {
		edges = append(edges, user.EdgeClinic)
	}
	if m.removedcustomer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	if m.removedpatient != nil {
		edges = append(edges, user.EdgePatient)
	}
	if m.removedinternal_user != nil {
		edges = append(edges, user.EdgeInternalUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeClinic:
		ids := make([]ent.Value, 0, len(m.removedclinic))
		for id := range m.removedclinic {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.removedcustomer))
		for id := range m.removedcustomer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePatient:
		ids := make([]ent.Value, 0, len(m.removedpatient))
		for id := range m.removedpatient {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInternalUser:
		ids := make([]ent.Value, 0, len(m.removedinternal_user))
		for id := range m.removedinternal_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedclinic {
		edges = append(edges, user.EdgeClinic)
	}
	if m.clearedcustomer {
		edges = append(edges, user.EdgeCustomer)
	}
	if m.clearedpatient {
		edges = append(edges, user.EdgePatient)
	}
	if m.clearedinternal_user {
		edges = append(edges, user.EdgeInternalUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeClinic:
		return m.clearedclinic
	case user.EdgeCustomer:
		return m.clearedcustomer
	case user.EdgePatient:
		return m.clearedpatient
	case user.EdgeInternalUser:
		return m.clearedinternal_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeClinic:
		m.ResetClinic()
		return nil
	case user.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case user.EdgePatient:
		m.ResetPatient()
		return nil
	case user.EdgeInternalUser:
		m.ResetInternalUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserInvitationRecordMutation represents an operation that mutates the UserInvitationRecord nodes in the graph.
type UserInvitationRecordMutation struct {
	config
	op              Op
	typ             string
	id              *int
	customer_id     *int
	addcustomer_id  *int
	invitation_link *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UserInvitationRecord, error)
	predicates      []predicate.UserInvitationRecord
}

var _ ent.Mutation = (*UserInvitationRecordMutation)(nil)

// userinvitationrecordOption allows management of the mutation configuration using functional options.
type userinvitationrecordOption func(*UserInvitationRecordMutation)

// newUserInvitationRecordMutation creates new mutation for the UserInvitationRecord entity.
func newUserInvitationRecordMutation(c config, op Op, opts ...userinvitationrecordOption) *UserInvitationRecordMutation {
	m := &UserInvitationRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserInvitationRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserInvitationRecordID sets the ID field of the mutation.
func withUserInvitationRecordID(id int) userinvitationrecordOption {
	return func(m *UserInvitationRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserInvitationRecord
		)
		m.oldValue = func(ctx context.Context) (*UserInvitationRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserInvitationRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserInvitationRecord sets the old UserInvitationRecord of the mutation.
func withUserInvitationRecord(node *UserInvitationRecord) userinvitationrecordOption {
	return func(m *UserInvitationRecordMutation) {
		m.oldValue = func(context.Context) (*UserInvitationRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserInvitationRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserInvitationRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserInvitationRecord entities.
func (m *UserInvitationRecordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserInvitationRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserInvitationRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserInvitationRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCustomerID sets the "customer_id" field.
func (m *UserInvitationRecordMutation) SetCustomerID(i int) {
	m.customer_id = &i
	m.addcustomer_id = nil
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *UserInvitationRecordMutation) CustomerID() (r int, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the UserInvitationRecord entity.
// If the UserInvitationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInvitationRecordMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// AddCustomerID adds i to the "customer_id" field.
func (m *UserInvitationRecordMutation) AddCustomerID(i int) {
	if m.addcustomer_id != nil {
		*m.addcustomer_id += i
	} else {
		m.addcustomer_id = &i
	}
}

// AddedCustomerID returns the value that was added to the "customer_id" field in this mutation.
func (m *UserInvitationRecordMutation) AddedCustomerID() (r int, exists bool) {
	v := m.addcustomer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *UserInvitationRecordMutation) ResetCustomerID() {
	m.customer_id = nil
	m.addcustomer_id = nil
}

// SetInvitationLink sets the "invitation_link" field.
func (m *UserInvitationRecordMutation) SetInvitationLink(s string) {
	m.invitation_link = &s
}

// InvitationLink returns the value of the "invitation_link" field in the mutation.
func (m *UserInvitationRecordMutation) InvitationLink() (r string, exists bool) {
	v := m.invitation_link
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationLink returns the old "invitation_link" field's value of the UserInvitationRecord entity.
// If the UserInvitationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInvitationRecordMutation) OldInvitationLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationLink: %w", err)
	}
	return oldValue.InvitationLink, nil
}

// ResetInvitationLink resets all changes to the "invitation_link" field.
func (m *UserInvitationRecordMutation) ResetInvitationLink() {
	m.invitation_link = nil
}

// Where appends a list predicates to the UserInvitationRecordMutation builder.
func (m *UserInvitationRecordMutation) Where(ps ...predicate.UserInvitationRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserInvitationRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserInvitationRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserInvitationRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserInvitationRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserInvitationRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserInvitationRecord).
func (m *UserInvitationRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserInvitationRecordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.customer_id != nil {
		fields = append(fields, userinvitationrecord.FieldCustomerID)
	}
	if m.invitation_link != nil {
		fields = append(fields, userinvitationrecord.FieldInvitationLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserInvitationRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		return m.CustomerID()
	case userinvitationrecord.FieldInvitationLink:
		return m.InvitationLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserInvitationRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case userinvitationrecord.FieldInvitationLink:
		return m.OldInvitationLink(ctx)
	}
	return nil, fmt.Errorf("unknown UserInvitationRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInvitationRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case userinvitationrecord.FieldInvitationLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationLink(v)
		return nil
	}
	return fmt.Errorf("unknown UserInvitationRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserInvitationRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcustomer_id != nil {
		fields = append(fields, userinvitationrecord.FieldCustomerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserInvitationRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		return m.AddedCustomerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInvitationRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown UserInvitationRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserInvitationRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserInvitationRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserInvitationRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserInvitationRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserInvitationRecordMutation) ResetField(name string) error {
	switch name {
	case userinvitationrecord.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case userinvitationrecord.FieldInvitationLink:
		m.ResetInvitationLink()
		return nil
	}
	return fmt.Errorf("unknown UserInvitationRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserInvitationRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserInvitationRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserInvitationRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserInvitationRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserInvitationRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserInvitationRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserInvitationRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserInvitationRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserInvitationRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserInvitationRecord edge %s", name)
}

// ZipcodeMutation represents an operation that mutates the Zipcode nodes in the graph.
type ZipcodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_ZipCodeType  *string
	_City         *string
	_State        *string
	_LocationType *string
	_Lat          *float64
	add_Lat       *float64
	_Long         *float64
	add_Long      *float64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Zipcode, error)
	predicates    []predicate.Zipcode
}

var _ ent.Mutation = (*ZipcodeMutation)(nil)

// zipcodeOption allows management of the mutation configuration using functional options.
type zipcodeOption func(*ZipcodeMutation)

// newZipcodeMutation creates new mutation for the Zipcode entity.
func newZipcodeMutation(c config, op Op, opts ...zipcodeOption) *ZipcodeMutation {
	m := &ZipcodeMutation{
		config:        c,
		op:            op,
		typ:           TypeZipcode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withZipcodeID sets the ID field of the mutation.
func withZipcodeID(id int) zipcodeOption {
	return func(m *ZipcodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Zipcode
		)
		m.oldValue = func(ctx context.Context) (*Zipcode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Zipcode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withZipcode sets the old Zipcode of the mutation.
func withZipcode(node *Zipcode) zipcodeOption {
	return func(m *ZipcodeMutation) {
		m.oldValue = func(context.Context) (*Zipcode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ZipcodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ZipcodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Zipcode entities.
func (m *ZipcodeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ZipcodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ZipcodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Zipcode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetZipCodeType sets the "ZipCodeType" field.
func (m *ZipcodeMutation) SetZipCodeType(s string) {
	m._ZipCodeType = &s
}

// ZipCodeType returns the value of the "ZipCodeType" field in the mutation.
func (m *ZipcodeMutation) ZipCodeType() (r string, exists bool) {
	v := m._ZipCodeType
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCodeType returns the old "ZipCodeType" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldZipCodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCodeType: %w", err)
	}
	return oldValue.ZipCodeType, nil
}

// ResetZipCodeType resets all changes to the "ZipCodeType" field.
func (m *ZipcodeMutation) ResetZipCodeType() {
	m._ZipCodeType = nil
}

// SetCity sets the "City" field.
func (m *ZipcodeMutation) SetCity(s string) {
	m._City = &s
}

// City returns the value of the "City" field in the mutation.
func (m *ZipcodeMutation) City() (r string, exists bool) {
	v := m._City
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "City" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "City" field.
func (m *ZipcodeMutation) ResetCity() {
	m._City = nil
}

// SetState sets the "State" field.
func (m *ZipcodeMutation) SetState(s string) {
	m._State = &s
}

// State returns the value of the "State" field in the mutation.
func (m *ZipcodeMutation) State() (r string, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "State" field.
func (m *ZipcodeMutation) ResetState() {
	m._State = nil
}

// SetLocationType sets the "LocationType" field.
func (m *ZipcodeMutation) SetLocationType(s string) {
	m._LocationType = &s
}

// LocationType returns the value of the "LocationType" field in the mutation.
func (m *ZipcodeMutation) LocationType() (r string, exists bool) {
	v := m._LocationType
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationType returns the old "LocationType" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldLocationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationType: %w", err)
	}
	return oldValue.LocationType, nil
}

// ResetLocationType resets all changes to the "LocationType" field.
func (m *ZipcodeMutation) ResetLocationType() {
	m._LocationType = nil
}

// SetLat sets the "Lat" field.
func (m *ZipcodeMutation) SetLat(f float64) {
	m._Lat = &f
	m.add_Lat = nil
}

// Lat returns the value of the "Lat" field in the mutation.
func (m *ZipcodeMutation) Lat() (r float64, exists bool) {
	v := m._Lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "Lat" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "Lat" field.
func (m *ZipcodeMutation) AddLat(f float64) {
	if m.add_Lat != nil {
		*m.add_Lat += f
	} else {
		m.add_Lat = &f
	}
}

// AddedLat returns the value that was added to the "Lat" field in this mutation.
func (m *ZipcodeMutation) AddedLat() (r float64, exists bool) {
	v := m.add_Lat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "Lat" field.
func (m *ZipcodeMutation) ClearLat() {
	m._Lat = nil
	m.add_Lat = nil
	m.clearedFields[zipcode.FieldLat] = struct{}{}
}

// LatCleared returns if the "Lat" field was cleared in this mutation.
func (m *ZipcodeMutation) LatCleared() bool {
	_, ok := m.clearedFields[zipcode.FieldLat]
	return ok
}

// ResetLat resets all changes to the "Lat" field.
func (m *ZipcodeMutation) ResetLat() {
	m._Lat = nil
	m.add_Lat = nil
	delete(m.clearedFields, zipcode.FieldLat)
}

// SetLong sets the "Long" field.
func (m *ZipcodeMutation) SetLong(f float64) {
	m._Long = &f
	m.add_Long = nil
}

// Long returns the value of the "Long" field in the mutation.
func (m *ZipcodeMutation) Long() (r float64, exists bool) {
	v := m._Long
	if v == nil {
		return
	}
	return *v, true
}

// OldLong returns the old "Long" field's value of the Zipcode entity.
// If the Zipcode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ZipcodeMutation) OldLong(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLong: %w", err)
	}
	return oldValue.Long, nil
}

// AddLong adds f to the "Long" field.
func (m *ZipcodeMutation) AddLong(f float64) {
	if m.add_Long != nil {
		*m.add_Long += f
	} else {
		m.add_Long = &f
	}
}

// AddedLong returns the value that was added to the "Long" field in this mutation.
func (m *ZipcodeMutation) AddedLong() (r float64, exists bool) {
	v := m.add_Long
	if v == nil {
		return
	}
	return *v, true
}

// ClearLong clears the value of the "Long" field.
func (m *ZipcodeMutation) ClearLong() {
	m._Long = nil
	m.add_Long = nil
	m.clearedFields[zipcode.FieldLong] = struct{}{}
}

// LongCleared returns if the "Long" field was cleared in this mutation.
func (m *ZipcodeMutation) LongCleared() bool {
	_, ok := m.clearedFields[zipcode.FieldLong]
	return ok
}

// ResetLong resets all changes to the "Long" field.
func (m *ZipcodeMutation) ResetLong() {
	m._Long = nil
	m.add_Long = nil
	delete(m.clearedFields, zipcode.FieldLong)
}

// Where appends a list predicates to the ZipcodeMutation builder.
func (m *ZipcodeMutation) Where(ps ...predicate.Zipcode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ZipcodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ZipcodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Zipcode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ZipcodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ZipcodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Zipcode).
func (m *ZipcodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ZipcodeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._ZipCodeType != nil {
		fields = append(fields, zipcode.FieldZipCodeType)
	}
	if m._City != nil {
		fields = append(fields, zipcode.FieldCity)
	}
	if m._State != nil {
		fields = append(fields, zipcode.FieldState)
	}
	if m._LocationType != nil {
		fields = append(fields, zipcode.FieldLocationType)
	}
	if m._Lat != nil {
		fields = append(fields, zipcode.FieldLat)
	}
	if m._Long != nil {
		fields = append(fields, zipcode.FieldLong)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ZipcodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case zipcode.FieldZipCodeType:
		return m.ZipCodeType()
	case zipcode.FieldCity:
		return m.City()
	case zipcode.FieldState:
		return m.State()
	case zipcode.FieldLocationType:
		return m.LocationType()
	case zipcode.FieldLat:
		return m.Lat()
	case zipcode.FieldLong:
		return m.Long()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ZipcodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case zipcode.FieldZipCodeType:
		return m.OldZipCodeType(ctx)
	case zipcode.FieldCity:
		return m.OldCity(ctx)
	case zipcode.FieldState:
		return m.OldState(ctx)
	case zipcode.FieldLocationType:
		return m.OldLocationType(ctx)
	case zipcode.FieldLat:
		return m.OldLat(ctx)
	case zipcode.FieldLong:
		return m.OldLong(ctx)
	}
	return nil, fmt.Errorf("unknown Zipcode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ZipcodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case zipcode.FieldZipCodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCodeType(v)
		return nil
	case zipcode.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case zipcode.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case zipcode.FieldLocationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationType(v)
		return nil
	case zipcode.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case zipcode.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLong(v)
		return nil
	}
	return fmt.Errorf("unknown Zipcode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ZipcodeMutation) AddedFields() []string {
	var fields []string
	if m.add_Lat != nil {
		fields = append(fields, zipcode.FieldLat)
	}
	if m.add_Long != nil {
		fields = append(fields, zipcode.FieldLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ZipcodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case zipcode.FieldLat:
		return m.AddedLat()
	case zipcode.FieldLong:
		return m.AddedLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ZipcodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case zipcode.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case zipcode.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLong(v)
		return nil
	}
	return fmt.Errorf("unknown Zipcode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ZipcodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(zipcode.FieldLat) {
		fields = append(fields, zipcode.FieldLat)
	}
	if m.FieldCleared(zipcode.FieldLong) {
		fields = append(fields, zipcode.FieldLong)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ZipcodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ZipcodeMutation) ClearField(name string) error {
	switch name {
	case zipcode.FieldLat:
		m.ClearLat()
		return nil
	case zipcode.FieldLong:
		m.ClearLong()
		return nil
	}
	return fmt.Errorf("unknown Zipcode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ZipcodeMutation) ResetField(name string) error {
	switch name {
	case zipcode.FieldZipCodeType:
		m.ResetZipCodeType()
		return nil
	case zipcode.FieldCity:
		m.ResetCity()
		return nil
	case zipcode.FieldState:
		m.ResetState()
		return nil
	case zipcode.FieldLocationType:
		m.ResetLocationType()
		return nil
	case zipcode.FieldLat:
		m.ResetLat()
		return nil
	case zipcode.FieldLong:
		m.ResetLong()
		return nil
	}
	return fmt.Errorf("unknown Zipcode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ZipcodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ZipcodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ZipcodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ZipcodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ZipcodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ZipcodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ZipcodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Zipcode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ZipcodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Zipcode edge %s", name)
}
