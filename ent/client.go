// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"coresamples/ent/migrate"

	"coresamples/ent/accountsubscription"
	"coresamples/ent/address"
	"coresamples/ent/betaprogram"
	"coresamples/ent/betaprogramparticipation"
	"coresamples/ent/clinic"
	"coresamples/ent/contact"
	"coresamples/ent/countrylist"
	"coresamples/ent/customer"
	"coresamples/ent/customeraddressonclinics"
	"coresamples/ent/customercontactonclinics"
	"coresamples/ent/customersettingonclinics"
	"coresamples/ent/internaluser"
	"coresamples/ent/labordersendhistory"
	"coresamples/ent/loginhistory"
	"coresamples/ent/orderflag"
	"coresamples/ent/orderinfo"
	"coresamples/ent/patient"
	"coresamples/ent/patientflag"
	"coresamples/ent/patientweightheight"
	"coresamples/ent/pendingordercredits"
	"coresamples/ent/rbacactions"
	"coresamples/ent/rbacresources"
	"coresamples/ent/rbacroles"
	"coresamples/ent/salesteam"
	"coresamples/ent/salesterritory"
	"coresamples/ent/salestitle"
	"coresamples/ent/sample"
	"coresamples/ent/sampleidgenerate"
	"coresamples/ent/sampletype"
	"coresamples/ent/serviceship"
	"coresamples/ent/serviceshipbillingplan"
	"coresamples/ent/setting"
	"coresamples/ent/test"
	"coresamples/ent/testdetail"
	"coresamples/ent/testlist"
	"coresamples/ent/tube"
	"coresamples/ent/tubeinstructions"
	"coresamples/ent/tubereceive"
	"coresamples/ent/tuberequirement"
	"coresamples/ent/tubetype"
	"coresamples/ent/user"
	"coresamples/ent/userinvitationrecord"
	"coresamples/ent/zipcode"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccountSubscription is the client for interacting with the AccountSubscription builders.
	AccountSubscription *AccountSubscriptionClient
	// Address is the client for interacting with the Address builders.
	Address *AddressClient
	// BetaProgram is the client for interacting with the BetaProgram builders.
	BetaProgram *BetaProgramClient
	// BetaProgramParticipation is the client for interacting with the BetaProgramParticipation builders.
	BetaProgramParticipation *BetaProgramParticipationClient
	// Clinic is the client for interacting with the Clinic builders.
	Clinic *ClinicClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// CountryList is the client for interacting with the CountryList builders.
	CountryList *CountryListClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// CustomerAddressOnClinics is the client for interacting with the CustomerAddressOnClinics builders.
	CustomerAddressOnClinics *CustomerAddressOnClinicsClient
	// CustomerContactOnClinics is the client for interacting with the CustomerContactOnClinics builders.
	CustomerContactOnClinics *CustomerContactOnClinicsClient
	// CustomerSettingOnClinics is the client for interacting with the CustomerSettingOnClinics builders.
	CustomerSettingOnClinics *CustomerSettingOnClinicsClient
	// InternalUser is the client for interacting with the InternalUser builders.
	InternalUser *InternalUserClient
	// LabOrderSendHistory is the client for interacting with the LabOrderSendHistory builders.
	LabOrderSendHistory *LabOrderSendHistoryClient
	// LoginHistory is the client for interacting with the LoginHistory builders.
	LoginHistory *LoginHistoryClient
	// OrderFlag is the client for interacting with the OrderFlag builders.
	OrderFlag *OrderFlagClient
	// OrderInfo is the client for interacting with the OrderInfo builders.
	OrderInfo *OrderInfoClient
	// Patient is the client for interacting with the Patient builders.
	Patient *PatientClient
	// PatientFlag is the client for interacting with the PatientFlag builders.
	PatientFlag *PatientFlagClient
	// PatientWeightHeight is the client for interacting with the PatientWeightHeight builders.
	PatientWeightHeight *PatientWeightHeightClient
	// PendingOrderCredits is the client for interacting with the PendingOrderCredits builders.
	PendingOrderCredits *PendingOrderCreditsClient
	// RBACActions is the client for interacting with the RBACActions builders.
	RBACActions *RBACActionsClient
	// RBACResources is the client for interacting with the RBACResources builders.
	RBACResources *RBACResourcesClient
	// RBACRoles is the client for interacting with the RBACRoles builders.
	RBACRoles *RBACRolesClient
	// SalesTeam is the client for interacting with the SalesTeam builders.
	SalesTeam *SalesTeamClient
	// SalesTerritory is the client for interacting with the SalesTerritory builders.
	SalesTerritory *SalesTerritoryClient
	// SalesTitle is the client for interacting with the SalesTitle builders.
	SalesTitle *SalesTitleClient
	// Sample is the client for interacting with the Sample builders.
	Sample *SampleClient
	// SampleIDGenerate is the client for interacting with the SampleIDGenerate builders.
	SampleIDGenerate *SampleIDGenerateClient
	// SampleType is the client for interacting with the SampleType builders.
	SampleType *SampleTypeClient
	// Serviceship is the client for interacting with the Serviceship builders.
	Serviceship *ServiceshipClient
	// ServiceshipBillingPlan is the client for interacting with the ServiceshipBillingPlan builders.
	ServiceshipBillingPlan *ServiceshipBillingPlanClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Test is the client for interacting with the Test builders.
	Test *TestClient
	// TestDetail is the client for interacting with the TestDetail builders.
	TestDetail *TestDetailClient
	// TestList is the client for interacting with the TestList builders.
	TestList *TestListClient
	// Tube is the client for interacting with the Tube builders.
	Tube *TubeClient
	// TubeInstructions is the client for interacting with the TubeInstructions builders.
	TubeInstructions *TubeInstructionsClient
	// TubeReceive is the client for interacting with the TubeReceive builders.
	TubeReceive *TubeReceiveClient
	// TubeRequirement is the client for interacting with the TubeRequirement builders.
	TubeRequirement *TubeRequirementClient
	// TubeType is the client for interacting with the TubeType builders.
	TubeType *TubeTypeClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserInvitationRecord is the client for interacting with the UserInvitationRecord builders.
	UserInvitationRecord *UserInvitationRecordClient
	// Zipcode is the client for interacting with the Zipcode builders.
	Zipcode *ZipcodeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccountSubscription = NewAccountSubscriptionClient(c.config)
	c.Address = NewAddressClient(c.config)
	c.BetaProgram = NewBetaProgramClient(c.config)
	c.BetaProgramParticipation = NewBetaProgramParticipationClient(c.config)
	c.Clinic = NewClinicClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.CountryList = NewCountryListClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.CustomerAddressOnClinics = NewCustomerAddressOnClinicsClient(c.config)
	c.CustomerContactOnClinics = NewCustomerContactOnClinicsClient(c.config)
	c.CustomerSettingOnClinics = NewCustomerSettingOnClinicsClient(c.config)
	c.InternalUser = NewInternalUserClient(c.config)
	c.LabOrderSendHistory = NewLabOrderSendHistoryClient(c.config)
	c.LoginHistory = NewLoginHistoryClient(c.config)
	c.OrderFlag = NewOrderFlagClient(c.config)
	c.OrderInfo = NewOrderInfoClient(c.config)
	c.Patient = NewPatientClient(c.config)
	c.PatientFlag = NewPatientFlagClient(c.config)
	c.PatientWeightHeight = NewPatientWeightHeightClient(c.config)
	c.PendingOrderCredits = NewPendingOrderCreditsClient(c.config)
	c.RBACActions = NewRBACActionsClient(c.config)
	c.RBACResources = NewRBACResourcesClient(c.config)
	c.RBACRoles = NewRBACRolesClient(c.config)
	c.SalesTeam = NewSalesTeamClient(c.config)
	c.SalesTerritory = NewSalesTerritoryClient(c.config)
	c.SalesTitle = NewSalesTitleClient(c.config)
	c.Sample = NewSampleClient(c.config)
	c.SampleIDGenerate = NewSampleIDGenerateClient(c.config)
	c.SampleType = NewSampleTypeClient(c.config)
	c.Serviceship = NewServiceshipClient(c.config)
	c.ServiceshipBillingPlan = NewServiceshipBillingPlanClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Test = NewTestClient(c.config)
	c.TestDetail = NewTestDetailClient(c.config)
	c.TestList = NewTestListClient(c.config)
	c.Tube = NewTubeClient(c.config)
	c.TubeInstructions = NewTubeInstructionsClient(c.config)
	c.TubeReceive = NewTubeReceiveClient(c.config)
	c.TubeRequirement = NewTubeRequirementClient(c.config)
	c.TubeType = NewTubeTypeClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserInvitationRecord = NewUserInvitationRecordClient(c.config)
	c.Zipcode = NewZipcodeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AccountSubscription:      NewAccountSubscriptionClient(cfg),
		Address:                  NewAddressClient(cfg),
		BetaProgram:              NewBetaProgramClient(cfg),
		BetaProgramParticipation: NewBetaProgramParticipationClient(cfg),
		Clinic:                   NewClinicClient(cfg),
		Contact:                  NewContactClient(cfg),
		CountryList:              NewCountryListClient(cfg),
		Customer:                 NewCustomerClient(cfg),
		CustomerAddressOnClinics: NewCustomerAddressOnClinicsClient(cfg),
		CustomerContactOnClinics: NewCustomerContactOnClinicsClient(cfg),
		CustomerSettingOnClinics: NewCustomerSettingOnClinicsClient(cfg),
		InternalUser:             NewInternalUserClient(cfg),
		LabOrderSendHistory:      NewLabOrderSendHistoryClient(cfg),
		LoginHistory:             NewLoginHistoryClient(cfg),
		OrderFlag:                NewOrderFlagClient(cfg),
		OrderInfo:                NewOrderInfoClient(cfg),
		Patient:                  NewPatientClient(cfg),
		PatientFlag:              NewPatientFlagClient(cfg),
		PatientWeightHeight:      NewPatientWeightHeightClient(cfg),
		PendingOrderCredits:      NewPendingOrderCreditsClient(cfg),
		RBACActions:              NewRBACActionsClient(cfg),
		RBACResources:            NewRBACResourcesClient(cfg),
		RBACRoles:                NewRBACRolesClient(cfg),
		SalesTeam:                NewSalesTeamClient(cfg),
		SalesTerritory:           NewSalesTerritoryClient(cfg),
		SalesTitle:               NewSalesTitleClient(cfg),
		Sample:                   NewSampleClient(cfg),
		SampleIDGenerate:         NewSampleIDGenerateClient(cfg),
		SampleType:               NewSampleTypeClient(cfg),
		Serviceship:              NewServiceshipClient(cfg),
		ServiceshipBillingPlan:   NewServiceshipBillingPlanClient(cfg),
		Setting:                  NewSettingClient(cfg),
		Test:                     NewTestClient(cfg),
		TestDetail:               NewTestDetailClient(cfg),
		TestList:                 NewTestListClient(cfg),
		Tube:                     NewTubeClient(cfg),
		TubeInstructions:         NewTubeInstructionsClient(cfg),
		TubeReceive:              NewTubeReceiveClient(cfg),
		TubeRequirement:          NewTubeRequirementClient(cfg),
		TubeType:                 NewTubeTypeClient(cfg),
		User:                     NewUserClient(cfg),
		UserInvitationRecord:     NewUserInvitationRecordClient(cfg),
		Zipcode:                  NewZipcodeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AccountSubscription:      NewAccountSubscriptionClient(cfg),
		Address:                  NewAddressClient(cfg),
		BetaProgram:              NewBetaProgramClient(cfg),
		BetaProgramParticipation: NewBetaProgramParticipationClient(cfg),
		Clinic:                   NewClinicClient(cfg),
		Contact:                  NewContactClient(cfg),
		CountryList:              NewCountryListClient(cfg),
		Customer:                 NewCustomerClient(cfg),
		CustomerAddressOnClinics: NewCustomerAddressOnClinicsClient(cfg),
		CustomerContactOnClinics: NewCustomerContactOnClinicsClient(cfg),
		CustomerSettingOnClinics: NewCustomerSettingOnClinicsClient(cfg),
		InternalUser:             NewInternalUserClient(cfg),
		LabOrderSendHistory:      NewLabOrderSendHistoryClient(cfg),
		LoginHistory:             NewLoginHistoryClient(cfg),
		OrderFlag:                NewOrderFlagClient(cfg),
		OrderInfo:                NewOrderInfoClient(cfg),
		Patient:                  NewPatientClient(cfg),
		PatientFlag:              NewPatientFlagClient(cfg),
		PatientWeightHeight:      NewPatientWeightHeightClient(cfg),
		PendingOrderCredits:      NewPendingOrderCreditsClient(cfg),
		RBACActions:              NewRBACActionsClient(cfg),
		RBACResources:            NewRBACResourcesClient(cfg),
		RBACRoles:                NewRBACRolesClient(cfg),
		SalesTeam:                NewSalesTeamClient(cfg),
		SalesTerritory:           NewSalesTerritoryClient(cfg),
		SalesTitle:               NewSalesTitleClient(cfg),
		Sample:                   NewSampleClient(cfg),
		SampleIDGenerate:         NewSampleIDGenerateClient(cfg),
		SampleType:               NewSampleTypeClient(cfg),
		Serviceship:              NewServiceshipClient(cfg),
		ServiceshipBillingPlan:   NewServiceshipBillingPlanClient(cfg),
		Setting:                  NewSettingClient(cfg),
		Test:                     NewTestClient(cfg),
		TestDetail:               NewTestDetailClient(cfg),
		TestList:                 NewTestListClient(cfg),
		Tube:                     NewTubeClient(cfg),
		TubeInstructions:         NewTubeInstructionsClient(cfg),
		TubeReceive:              NewTubeReceiveClient(cfg),
		TubeRequirement:          NewTubeRequirementClient(cfg),
		TubeType:                 NewTubeTypeClient(cfg),
		User:                     NewUserClient(cfg),
		UserInvitationRecord:     NewUserInvitationRecordClient(cfg),
		Zipcode:                  NewZipcodeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccountSubscription.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccountSubscription, c.Address, c.BetaProgram, c.BetaProgramParticipation,
		c.Clinic, c.Contact, c.CountryList, c.Customer, c.CustomerAddressOnClinics,
		c.CustomerContactOnClinics, c.CustomerSettingOnClinics, c.InternalUser,
		c.LabOrderSendHistory, c.LoginHistory, c.OrderFlag, c.OrderInfo, c.Patient,
		c.PatientFlag, c.PatientWeightHeight, c.PendingOrderCredits, c.RBACActions,
		c.RBACResources, c.RBACRoles, c.SalesTeam, c.SalesTerritory, c.SalesTitle,
		c.Sample, c.SampleIDGenerate, c.SampleType, c.Serviceship,
		c.ServiceshipBillingPlan, c.Setting, c.Test, c.TestDetail, c.TestList, c.Tube,
		c.TubeInstructions, c.TubeReceive, c.TubeRequirement, c.TubeType, c.User,
		c.UserInvitationRecord, c.Zipcode,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccountSubscription, c.Address, c.BetaProgram, c.BetaProgramParticipation,
		c.Clinic, c.Contact, c.CountryList, c.Customer, c.CustomerAddressOnClinics,
		c.CustomerContactOnClinics, c.CustomerSettingOnClinics, c.InternalUser,
		c.LabOrderSendHistory, c.LoginHistory, c.OrderFlag, c.OrderInfo, c.Patient,
		c.PatientFlag, c.PatientWeightHeight, c.PendingOrderCredits, c.RBACActions,
		c.RBACResources, c.RBACRoles, c.SalesTeam, c.SalesTerritory, c.SalesTitle,
		c.Sample, c.SampleIDGenerate, c.SampleType, c.Serviceship,
		c.ServiceshipBillingPlan, c.Setting, c.Test, c.TestDetail, c.TestList, c.Tube,
		c.TubeInstructions, c.TubeReceive, c.TubeRequirement, c.TubeType, c.User,
		c.UserInvitationRecord, c.Zipcode,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountSubscriptionMutation:
		return c.AccountSubscription.mutate(ctx, m)
	case *AddressMutation:
		return c.Address.mutate(ctx, m)
	case *BetaProgramMutation:
		return c.BetaProgram.mutate(ctx, m)
	case *BetaProgramParticipationMutation:
		return c.BetaProgramParticipation.mutate(ctx, m)
	case *ClinicMutation:
		return c.Clinic.mutate(ctx, m)
	case *ContactMutation:
		return c.Contact.mutate(ctx, m)
	case *CountryListMutation:
		return c.CountryList.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *CustomerAddressOnClinicsMutation:
		return c.CustomerAddressOnClinics.mutate(ctx, m)
	case *CustomerContactOnClinicsMutation:
		return c.CustomerContactOnClinics.mutate(ctx, m)
	case *CustomerSettingOnClinicsMutation:
		return c.CustomerSettingOnClinics.mutate(ctx, m)
	case *InternalUserMutation:
		return c.InternalUser.mutate(ctx, m)
	case *LabOrderSendHistoryMutation:
		return c.LabOrderSendHistory.mutate(ctx, m)
	case *LoginHistoryMutation:
		return c.LoginHistory.mutate(ctx, m)
	case *OrderFlagMutation:
		return c.OrderFlag.mutate(ctx, m)
	case *OrderInfoMutation:
		return c.OrderInfo.mutate(ctx, m)
	case *PatientMutation:
		return c.Patient.mutate(ctx, m)
	case *PatientFlagMutation:
		return c.PatientFlag.mutate(ctx, m)
	case *PatientWeightHeightMutation:
		return c.PatientWeightHeight.mutate(ctx, m)
	case *PendingOrderCreditsMutation:
		return c.PendingOrderCredits.mutate(ctx, m)
	case *RBACActionsMutation:
		return c.RBACActions.mutate(ctx, m)
	case *RBACResourcesMutation:
		return c.RBACResources.mutate(ctx, m)
	case *RBACRolesMutation:
		return c.RBACRoles.mutate(ctx, m)
	case *SalesTeamMutation:
		return c.SalesTeam.mutate(ctx, m)
	case *SalesTerritoryMutation:
		return c.SalesTerritory.mutate(ctx, m)
	case *SalesTitleMutation:
		return c.SalesTitle.mutate(ctx, m)
	case *SampleMutation:
		return c.Sample.mutate(ctx, m)
	case *SampleIDGenerateMutation:
		return c.SampleIDGenerate.mutate(ctx, m)
	case *SampleTypeMutation:
		return c.SampleType.mutate(ctx, m)
	case *ServiceshipMutation:
		return c.Serviceship.mutate(ctx, m)
	case *ServiceshipBillingPlanMutation:
		return c.ServiceshipBillingPlan.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *TestMutation:
		return c.Test.mutate(ctx, m)
	case *TestDetailMutation:
		return c.TestDetail.mutate(ctx, m)
	case *TestListMutation:
		return c.TestList.mutate(ctx, m)
	case *TubeMutation:
		return c.Tube.mutate(ctx, m)
	case *TubeInstructionsMutation:
		return c.TubeInstructions.mutate(ctx, m)
	case *TubeReceiveMutation:
		return c.TubeReceive.mutate(ctx, m)
	case *TubeRequirementMutation:
		return c.TubeRequirement.mutate(ctx, m)
	case *TubeTypeMutation:
		return c.TubeType.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserInvitationRecordMutation:
		return c.UserInvitationRecord.mutate(ctx, m)
	case *ZipcodeMutation:
		return c.Zipcode.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccountSubscriptionClient is a client for the AccountSubscription schema.
type AccountSubscriptionClient struct {
	config
}

// NewAccountSubscriptionClient returns a client for the AccountSubscription from the given config.
func NewAccountSubscriptionClient(c config) *AccountSubscriptionClient {
	return &AccountSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountsubscription.Hooks(f(g(h())))`.
func (c *AccountSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.AccountSubscription = append(c.hooks.AccountSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountsubscription.Intercept(f(g(h())))`.
func (c *AccountSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountSubscription = append(c.inters.AccountSubscription, interceptors...)
}

// Create returns a builder for creating a AccountSubscription entity.
func (c *AccountSubscriptionClient) Create() *AccountSubscriptionCreate {
	mutation := newAccountSubscriptionMutation(c.config, OpCreate)
	return &AccountSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountSubscription entities.
func (c *AccountSubscriptionClient) CreateBulk(builders ...*AccountSubscriptionCreate) *AccountSubscriptionCreateBulk {
	return &AccountSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountSubscriptionClient) MapCreateBulk(slice any, setFunc func(*AccountSubscriptionCreate, int)) *AccountSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountSubscriptionCreateBulk{err: fmt.Errorf("calling to AccountSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountSubscription.
func (c *AccountSubscriptionClient) Update() *AccountSubscriptionUpdate {
	mutation := newAccountSubscriptionMutation(c.config, OpUpdate)
	return &AccountSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountSubscriptionClient) UpdateOne(as *AccountSubscription) *AccountSubscriptionUpdateOne {
	mutation := newAccountSubscriptionMutation(c.config, OpUpdateOne, withAccountSubscription(as))
	return &AccountSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountSubscriptionClient) UpdateOneID(id int) *AccountSubscriptionUpdateOne {
	mutation := newAccountSubscriptionMutation(c.config, OpUpdateOne, withAccountSubscriptionID(id))
	return &AccountSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountSubscription.
func (c *AccountSubscriptionClient) Delete() *AccountSubscriptionDelete {
	mutation := newAccountSubscriptionMutation(c.config, OpDelete)
	return &AccountSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountSubscriptionClient) DeleteOne(as *AccountSubscription) *AccountSubscriptionDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountSubscriptionClient) DeleteOneID(id int) *AccountSubscriptionDeleteOne {
	builder := c.Delete().Where(accountsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountSubscriptionDeleteOne{builder}
}

// Query returns a query builder for AccountSubscription.
func (c *AccountSubscriptionClient) Query() *AccountSubscriptionQuery {
	return &AccountSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountSubscription entity by its id.
func (c *AccountSubscriptionClient) Get(ctx context.Context, id int) (*AccountSubscription, error) {
	return c.Query().Where(accountsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountSubscriptionClient) GetX(ctx context.Context, id int) *AccountSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServiceshipBillingPlan queries the serviceship_billing_plan edge of a AccountSubscription.
func (c *AccountSubscriptionClient) QueryServiceshipBillingPlan(as *AccountSubscription) *ServiceshipBillingPlanQuery {
	query := (&ServiceshipBillingPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsubscription.Table, accountsubscription.FieldID, id),
			sqlgraph.To(serviceshipbillingplan.Table, serviceshipbillingplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountsubscription.ServiceshipBillingPlanTable, accountsubscription.ServiceshipBillingPlanColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceship queries the serviceship edge of a AccountSubscription.
func (c *AccountSubscriptionClient) QueryServiceship(as *AccountSubscription) *ServiceshipQuery {
	query := (&ServiceshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsubscription.Table, accountsubscription.FieldID, id),
			sqlgraph.To(serviceship.Table, serviceship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountsubscription.ServiceshipTable, accountsubscription.ServiceshipColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountSubscriptionClient) Hooks() []Hook {
	return c.hooks.AccountSubscription
}

// Interceptors returns the client interceptors.
func (c *AccountSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.AccountSubscription
}

func (c *AccountSubscriptionClient) mutate(ctx context.Context, m *AccountSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountSubscription mutation op: %q", m.Op())
	}
}

// AddressClient is a client for the Address schema.
type AddressClient struct {
	config
}

// NewAddressClient returns a client for the Address from the given config.
func NewAddressClient(c config) *AddressClient {
	return &AddressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `address.Hooks(f(g(h())))`.
func (c *AddressClient) Use(hooks ...Hook) {
	c.hooks.Address = append(c.hooks.Address, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `address.Intercept(f(g(h())))`.
func (c *AddressClient) Intercept(interceptors ...Interceptor) {
	c.inters.Address = append(c.inters.Address, interceptors...)
}

// Create returns a builder for creating a Address entity.
func (c *AddressClient) Create() *AddressCreate {
	mutation := newAddressMutation(c.config, OpCreate)
	return &AddressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Address entities.
func (c *AddressClient) CreateBulk(builders ...*AddressCreate) *AddressCreateBulk {
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AddressClient) MapCreateBulk(slice any, setFunc func(*AddressCreate, int)) *AddressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AddressCreateBulk{err: fmt.Errorf("calling to AddressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AddressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Address.
func (c *AddressClient) Update() *AddressUpdate {
	mutation := newAddressMutation(c.config, OpUpdate)
	return &AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AddressClient) UpdateOne(a *Address) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddress(a))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AddressClient) UpdateOneID(id int) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddressID(id))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Address.
func (c *AddressClient) Delete() *AddressDelete {
	mutation := newAddressMutation(c.config, OpDelete)
	return &AddressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AddressClient) DeleteOne(a *Address) *AddressDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AddressClient) DeleteOneID(id int) *AddressDeleteOne {
	builder := c.Delete().Where(address.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AddressDeleteOne{builder}
}

// Query returns a query builder for Address.
func (c *AddressClient) Query() *AddressQuery {
	return &AddressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAddress},
		inters: c.Interceptors(),
	}
}

// Get returns a Address entity by its id.
func (c *AddressClient) Get(ctx context.Context, id int) (*Address, error) {
	return c.Query().Where(address.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AddressClient) GetX(ctx context.Context, id int) *Address {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClinic queries the clinic edge of a Address.
func (c *AddressClient) QueryClinic(a *Address) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, address.ClinicTable, address.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Address.
func (c *AddressClient) QueryCustomer(a *Address) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, address.CustomerTable, address.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerClinicMappings queries the customer_clinic_mappings edge of a Address.
func (c *AddressClient) QueryCustomerClinicMappings(a *Address) *CustomerAddressOnClinicsQuery {
	query := (&CustomerAddressOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(customeraddressonclinics.Table, customeraddressonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, address.CustomerClinicMappingsTable, address.CustomerClinicMappingsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberAddresses queries the member_addresses edge of a Address.
func (c *AddressClient) QueryMemberAddresses(a *Address) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, address.MemberAddressesTable, address.MemberAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupAddress queries the group_address edge of a Address.
func (c *AddressClient) QueryGroupAddress(a *Address) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, address.GroupAddressTable, address.GroupAddressColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUser queries the internal_user edge of a Address.
func (c *AddressClient) QueryInternalUser(a *Address) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, address.InternalUserTable, address.InternalUserColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatient queries the patient edge of a Address.
func (c *AddressClient) QueryPatient(a *Address) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, address.PatientTable, address.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a Address.
func (c *AddressClient) QueryOrders(a *Address) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, address.OrdersTable, address.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AddressClient) Hooks() []Hook {
	return c.hooks.Address
}

// Interceptors returns the client interceptors.
func (c *AddressClient) Interceptors() []Interceptor {
	return c.inters.Address
}

func (c *AddressClient) mutate(ctx context.Context, m *AddressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AddressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AddressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Address mutation op: %q", m.Op())
	}
}

// BetaProgramClient is a client for the BetaProgram schema.
type BetaProgramClient struct {
	config
}

// NewBetaProgramClient returns a client for the BetaProgram from the given config.
func NewBetaProgramClient(c config) *BetaProgramClient {
	return &BetaProgramClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `betaprogram.Hooks(f(g(h())))`.
func (c *BetaProgramClient) Use(hooks ...Hook) {
	c.hooks.BetaProgram = append(c.hooks.BetaProgram, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `betaprogram.Intercept(f(g(h())))`.
func (c *BetaProgramClient) Intercept(interceptors ...Interceptor) {
	c.inters.BetaProgram = append(c.inters.BetaProgram, interceptors...)
}

// Create returns a builder for creating a BetaProgram entity.
func (c *BetaProgramClient) Create() *BetaProgramCreate {
	mutation := newBetaProgramMutation(c.config, OpCreate)
	return &BetaProgramCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BetaProgram entities.
func (c *BetaProgramClient) CreateBulk(builders ...*BetaProgramCreate) *BetaProgramCreateBulk {
	return &BetaProgramCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BetaProgramClient) MapCreateBulk(slice any, setFunc func(*BetaProgramCreate, int)) *BetaProgramCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BetaProgramCreateBulk{err: fmt.Errorf("calling to BetaProgramClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BetaProgramCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BetaProgramCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BetaProgram.
func (c *BetaProgramClient) Update() *BetaProgramUpdate {
	mutation := newBetaProgramMutation(c.config, OpUpdate)
	return &BetaProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BetaProgramClient) UpdateOne(bp *BetaProgram) *BetaProgramUpdateOne {
	mutation := newBetaProgramMutation(c.config, OpUpdateOne, withBetaProgram(bp))
	return &BetaProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BetaProgramClient) UpdateOneID(id int) *BetaProgramUpdateOne {
	mutation := newBetaProgramMutation(c.config, OpUpdateOne, withBetaProgramID(id))
	return &BetaProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BetaProgram.
func (c *BetaProgramClient) Delete() *BetaProgramDelete {
	mutation := newBetaProgramMutation(c.config, OpDelete)
	return &BetaProgramDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BetaProgramClient) DeleteOne(bp *BetaProgram) *BetaProgramDeleteOne {
	return c.DeleteOneID(bp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BetaProgramClient) DeleteOneID(id int) *BetaProgramDeleteOne {
	builder := c.Delete().Where(betaprogram.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BetaProgramDeleteOne{builder}
}

// Query returns a query builder for BetaProgram.
func (c *BetaProgramClient) Query() *BetaProgramQuery {
	return &BetaProgramQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBetaProgram},
		inters: c.Interceptors(),
	}
}

// Get returns a BetaProgram entity by its id.
func (c *BetaProgramClient) Get(ctx context.Context, id int) (*BetaProgram, error) {
	return c.Query().Where(betaprogram.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BetaProgramClient) GetX(ctx context.Context, id int) *BetaProgram {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParticipations queries the participations edge of a BetaProgram.
func (c *BetaProgramClient) QueryParticipations(bp *BetaProgram) *BetaProgramParticipationQuery {
	query := (&BetaProgramParticipationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(betaprogram.Table, betaprogram.FieldID, id),
			sqlgraph.To(betaprogramparticipation.Table, betaprogramparticipation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, betaprogram.ParticipationsTable, betaprogram.ParticipationsColumn),
		)
		fromV = sqlgraph.Neighbors(bp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BetaProgramClient) Hooks() []Hook {
	return c.hooks.BetaProgram
}

// Interceptors returns the client interceptors.
func (c *BetaProgramClient) Interceptors() []Interceptor {
	return c.inters.BetaProgram
}

func (c *BetaProgramClient) mutate(ctx context.Context, m *BetaProgramMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BetaProgramCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BetaProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BetaProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BetaProgramDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BetaProgram mutation op: %q", m.Op())
	}
}

// BetaProgramParticipationClient is a client for the BetaProgramParticipation schema.
type BetaProgramParticipationClient struct {
	config
}

// NewBetaProgramParticipationClient returns a client for the BetaProgramParticipation from the given config.
func NewBetaProgramParticipationClient(c config) *BetaProgramParticipationClient {
	return &BetaProgramParticipationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `betaprogramparticipation.Hooks(f(g(h())))`.
func (c *BetaProgramParticipationClient) Use(hooks ...Hook) {
	c.hooks.BetaProgramParticipation = append(c.hooks.BetaProgramParticipation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `betaprogramparticipation.Intercept(f(g(h())))`.
func (c *BetaProgramParticipationClient) Intercept(interceptors ...Interceptor) {
	c.inters.BetaProgramParticipation = append(c.inters.BetaProgramParticipation, interceptors...)
}

// Create returns a builder for creating a BetaProgramParticipation entity.
func (c *BetaProgramParticipationClient) Create() *BetaProgramParticipationCreate {
	mutation := newBetaProgramParticipationMutation(c.config, OpCreate)
	return &BetaProgramParticipationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BetaProgramParticipation entities.
func (c *BetaProgramParticipationClient) CreateBulk(builders ...*BetaProgramParticipationCreate) *BetaProgramParticipationCreateBulk {
	return &BetaProgramParticipationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BetaProgramParticipationClient) MapCreateBulk(slice any, setFunc func(*BetaProgramParticipationCreate, int)) *BetaProgramParticipationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BetaProgramParticipationCreateBulk{err: fmt.Errorf("calling to BetaProgramParticipationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BetaProgramParticipationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BetaProgramParticipationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BetaProgramParticipation.
func (c *BetaProgramParticipationClient) Update() *BetaProgramParticipationUpdate {
	mutation := newBetaProgramParticipationMutation(c.config, OpUpdate)
	return &BetaProgramParticipationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BetaProgramParticipationClient) UpdateOne(bpp *BetaProgramParticipation) *BetaProgramParticipationUpdateOne {
	mutation := newBetaProgramParticipationMutation(c.config, OpUpdateOne, withBetaProgramParticipation(bpp))
	return &BetaProgramParticipationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BetaProgramParticipationClient) UpdateOneID(id int) *BetaProgramParticipationUpdateOne {
	mutation := newBetaProgramParticipationMutation(c.config, OpUpdateOne, withBetaProgramParticipationID(id))
	return &BetaProgramParticipationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BetaProgramParticipation.
func (c *BetaProgramParticipationClient) Delete() *BetaProgramParticipationDelete {
	mutation := newBetaProgramParticipationMutation(c.config, OpDelete)
	return &BetaProgramParticipationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BetaProgramParticipationClient) DeleteOne(bpp *BetaProgramParticipation) *BetaProgramParticipationDeleteOne {
	return c.DeleteOneID(bpp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BetaProgramParticipationClient) DeleteOneID(id int) *BetaProgramParticipationDeleteOne {
	builder := c.Delete().Where(betaprogramparticipation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BetaProgramParticipationDeleteOne{builder}
}

// Query returns a query builder for BetaProgramParticipation.
func (c *BetaProgramParticipationClient) Query() *BetaProgramParticipationQuery {
	return &BetaProgramParticipationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBetaProgramParticipation},
		inters: c.Interceptors(),
	}
}

// Get returns a BetaProgramParticipation entity by its id.
func (c *BetaProgramParticipationClient) Get(ctx context.Context, id int) (*BetaProgramParticipation, error) {
	return c.Query().Where(betaprogramparticipation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BetaProgramParticipationClient) GetX(ctx context.Context, id int) *BetaProgramParticipation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBetaProgram queries the beta_program edge of a BetaProgramParticipation.
func (c *BetaProgramParticipationClient) QueryBetaProgram(bpp *BetaProgramParticipation) *BetaProgramQuery {
	query := (&BetaProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(betaprogramparticipation.Table, betaprogramparticipation.FieldID, id),
			sqlgraph.To(betaprogram.Table, betaprogram.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, betaprogramparticipation.BetaProgramTable, betaprogramparticipation.BetaProgramColumn),
		)
		fromV = sqlgraph.Neighbors(bpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a BetaProgramParticipation.
func (c *BetaProgramParticipationClient) QueryCustomer(bpp *BetaProgramParticipation) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(betaprogramparticipation.Table, betaprogramparticipation.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, betaprogramparticipation.CustomerTable, betaprogramparticipation.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(bpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinic queries the clinic edge of a BetaProgramParticipation.
func (c *BetaProgramParticipationClient) QueryClinic(bpp *BetaProgramParticipation) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(betaprogramparticipation.Table, betaprogramparticipation.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, betaprogramparticipation.ClinicTable, betaprogramparticipation.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(bpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BetaProgramParticipationClient) Hooks() []Hook {
	return c.hooks.BetaProgramParticipation
}

// Interceptors returns the client interceptors.
func (c *BetaProgramParticipationClient) Interceptors() []Interceptor {
	return c.inters.BetaProgramParticipation
}

func (c *BetaProgramParticipationClient) mutate(ctx context.Context, m *BetaProgramParticipationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BetaProgramParticipationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BetaProgramParticipationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BetaProgramParticipationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BetaProgramParticipationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BetaProgramParticipation mutation op: %q", m.Op())
	}
}

// ClinicClient is a client for the Clinic schema.
type ClinicClient struct {
	config
}

// NewClinicClient returns a client for the Clinic from the given config.
func NewClinicClient(c config) *ClinicClient {
	return &ClinicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clinic.Hooks(f(g(h())))`.
func (c *ClinicClient) Use(hooks ...Hook) {
	c.hooks.Clinic = append(c.hooks.Clinic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clinic.Intercept(f(g(h())))`.
func (c *ClinicClient) Intercept(interceptors ...Interceptor) {
	c.inters.Clinic = append(c.inters.Clinic, interceptors...)
}

// Create returns a builder for creating a Clinic entity.
func (c *ClinicClient) Create() *ClinicCreate {
	mutation := newClinicMutation(c.config, OpCreate)
	return &ClinicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Clinic entities.
func (c *ClinicClient) CreateBulk(builders ...*ClinicCreate) *ClinicCreateBulk {
	return &ClinicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClinicClient) MapCreateBulk(slice any, setFunc func(*ClinicCreate, int)) *ClinicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClinicCreateBulk{err: fmt.Errorf("calling to ClinicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClinicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClinicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Clinic.
func (c *ClinicClient) Update() *ClinicUpdate {
	mutation := newClinicMutation(c.config, OpUpdate)
	return &ClinicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClinicClient) UpdateOne(cl *Clinic) *ClinicUpdateOne {
	mutation := newClinicMutation(c.config, OpUpdateOne, withClinic(cl))
	return &ClinicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClinicClient) UpdateOneID(id int) *ClinicUpdateOne {
	mutation := newClinicMutation(c.config, OpUpdateOne, withClinicID(id))
	return &ClinicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Clinic.
func (c *ClinicClient) Delete() *ClinicDelete {
	mutation := newClinicMutation(c.config, OpDelete)
	return &ClinicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClinicClient) DeleteOne(cl *Clinic) *ClinicDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClinicClient) DeleteOneID(id int) *ClinicDeleteOne {
	builder := c.Delete().Where(clinic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClinicDeleteOne{builder}
}

// Query returns a query builder for Clinic.
func (c *ClinicClient) Query() *ClinicQuery {
	return &ClinicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClinic},
		inters: c.Interceptors(),
	}
}

// Get returns a Clinic entity by its id.
func (c *ClinicClient) Get(ctx context.Context, id int) (*Clinic, error) {
	return c.Query().Where(clinic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClinicClient) GetX(ctx context.Context, id int) *Clinic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Clinic.
func (c *ClinicClient) QueryUser(cl *Clinic) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, clinic.UserTable, clinic.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicContacts queries the clinic_contacts edge of a Clinic.
func (c *ClinicClient) QueryClinicContacts(cl *Clinic) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicContactsTable, clinic.ClinicContactsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicAddresses queries the clinic_addresses edge of a Clinic.
func (c *ClinicClient) QueryClinicAddresses(cl *Clinic) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicAddressesTable, clinic.ClinicAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomers queries the customers edge of a Clinic.
func (c *ClinicClient) QueryCustomers(cl *Clinic) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, clinic.CustomersTable, clinic.CustomersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicSettings queries the clinic_settings edge of a Clinic.
func (c *ClinicClient) QueryClinicSettings(cl *Clinic) *SettingQuery {
	query := (&SettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(setting.Table, setting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, clinic.ClinicSettingsTable, clinic.ClinicSettingsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicOrders queries the clinic_orders edge of a Clinic.
func (c *ClinicClient) QueryClinicOrders(cl *Clinic) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicOrdersTable, clinic.ClinicOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicPatients queries the clinic_patients edge of a Clinic.
func (c *ClinicClient) QueryClinicPatients(cl *Clinic) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, clinic.ClinicPatientsTable, clinic.ClinicPatientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicBetaProgramParticipations queries the clinic_beta_program_participations edge of a Clinic.
func (c *ClinicClient) QueryClinicBetaProgramParticipations(cl *Clinic) *BetaProgramParticipationQuery {
	query := (&BetaProgramParticipationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(betaprogramparticipation.Table, betaprogramparticipation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicBetaProgramParticipationsTable, clinic.ClinicBetaProgramParticipationsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicCustomerSettings queries the clinic_customer_settings edge of a Clinic.
func (c *ClinicClient) QueryClinicCustomerSettings(cl *Clinic) *CustomerSettingOnClinicsQuery {
	query := (&CustomerSettingOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(customersettingonclinics.Table, customersettingonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicCustomerSettingsTable, clinic.ClinicCustomerSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicCustomerAddresses queries the clinic_customer_addresses edge of a Clinic.
func (c *ClinicClient) QueryClinicCustomerAddresses(cl *Clinic) *CustomerAddressOnClinicsQuery {
	query := (&CustomerAddressOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(customeraddressonclinics.Table, customeraddressonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicCustomerAddressesTable, clinic.ClinicCustomerAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicCustomerContacts queries the clinic_customer_contacts edge of a Clinic.
func (c *ClinicClient) QueryClinicCustomerContacts(cl *Clinic) *CustomerContactOnClinicsQuery {
	query := (&CustomerContactOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clinic.Table, clinic.FieldID, id),
			sqlgraph.To(customercontactonclinics.Table, customercontactonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clinic.ClinicCustomerContactsTable, clinic.ClinicCustomerContactsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClinicClient) Hooks() []Hook {
	return c.hooks.Clinic
}

// Interceptors returns the client interceptors.
func (c *ClinicClient) Interceptors() []Interceptor {
	return c.inters.Clinic
}

func (c *ClinicClient) mutate(ctx context.Context, m *ClinicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClinicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClinicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClinicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClinicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Clinic mutation op: %q", m.Op())
	}
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contact.Intercept(f(g(h())))`.
func (c *ContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contact = append(c.inters.Contact, interceptors...)
}

// Create returns a builder for creating a Contact entity.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contact entities.
func (c *ContactClient) CreateBulk(builders ...*ContactCreate) *ContactCreateBulk {
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactClient) MapCreateBulk(slice any, setFunc func(*ContactCreate, int)) *ContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactCreateBulk{err: fmt.Errorf("calling to ContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContact(co))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id int) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContactID(id))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactClient) DeleteOneID(id int) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Query returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContact},
		inters: c.Interceptors(),
	}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id int) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id int) *Contact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClinic queries the clinic edge of a Contact.
func (c *ContactClient) QueryClinic(co *Contact) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.ClinicTable, contact.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatient queries the patient edge of a Contact.
func (c *ContactClient) QueryPatient(co *Contact) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.PatientTable, contact.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Contact.
func (c *ContactClient) QueryCustomer(co *Contact) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.CustomerTable, contact.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerClinicMappings queries the customer_clinic_mappings edge of a Contact.
func (c *ContactClient) QueryCustomerClinicMappings(co *Contact) *CustomerContactOnClinicsQuery {
	query := (&CustomerContactOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(customercontactonclinics.Table, customercontactonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, contact.CustomerClinicMappingsTable, contact.CustomerClinicMappingsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberContacts queries the member_contacts edge of a Contact.
func (c *ContactClient) QueryMemberContacts(co *Contact) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, contact.MemberContactsTable, contact.MemberContactsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupContact queries the group_contact edge of a Contact.
func (c *ContactClient) QueryGroupContact(co *Contact) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, contact.GroupContactTable, contact.GroupContactColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUser queries the internal_user edge of a Contact.
func (c *ContactClient) QueryInternalUser(co *Contact) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.InternalUserTable, contact.InternalUserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a Contact.
func (c *ContactClient) QueryOrders(co *Contact) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, contact.OrdersTable, contact.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	return c.hooks.Contact
}

// Interceptors returns the client interceptors.
func (c *ContactClient) Interceptors() []Interceptor {
	return c.inters.Contact
}

func (c *ContactClient) mutate(ctx context.Context, m *ContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contact mutation op: %q", m.Op())
	}
}

// CountryListClient is a client for the CountryList schema.
type CountryListClient struct {
	config
}

// NewCountryListClient returns a client for the CountryList from the given config.
func NewCountryListClient(c config) *CountryListClient {
	return &CountryListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `countrylist.Hooks(f(g(h())))`.
func (c *CountryListClient) Use(hooks ...Hook) {
	c.hooks.CountryList = append(c.hooks.CountryList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `countrylist.Intercept(f(g(h())))`.
func (c *CountryListClient) Intercept(interceptors ...Interceptor) {
	c.inters.CountryList = append(c.inters.CountryList, interceptors...)
}

// Create returns a builder for creating a CountryList entity.
func (c *CountryListClient) Create() *CountryListCreate {
	mutation := newCountryListMutation(c.config, OpCreate)
	return &CountryListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CountryList entities.
func (c *CountryListClient) CreateBulk(builders ...*CountryListCreate) *CountryListCreateBulk {
	return &CountryListCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CountryListClient) MapCreateBulk(slice any, setFunc func(*CountryListCreate, int)) *CountryListCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CountryListCreateBulk{err: fmt.Errorf("calling to CountryListClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CountryListCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CountryListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CountryList.
func (c *CountryListClient) Update() *CountryListUpdate {
	mutation := newCountryListMutation(c.config, OpUpdate)
	return &CountryListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryListClient) UpdateOne(cl *CountryList) *CountryListUpdateOne {
	mutation := newCountryListMutation(c.config, OpUpdateOne, withCountryList(cl))
	return &CountryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryListClient) UpdateOneID(id int) *CountryListUpdateOne {
	mutation := newCountryListMutation(c.config, OpUpdateOne, withCountryListID(id))
	return &CountryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CountryList.
func (c *CountryListClient) Delete() *CountryListDelete {
	mutation := newCountryListMutation(c.config, OpDelete)
	return &CountryListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryListClient) DeleteOne(cl *CountryList) *CountryListDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryListClient) DeleteOneID(id int) *CountryListDeleteOne {
	builder := c.Delete().Where(countrylist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryListDeleteOne{builder}
}

// Query returns a query builder for CountryList.
func (c *CountryListClient) Query() *CountryListQuery {
	return &CountryListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountryList},
		inters: c.Interceptors(),
	}
}

// Get returns a CountryList entity by its id.
func (c *CountryListClient) Get(ctx context.Context, id int) (*CountryList, error) {
	return c.Query().Where(countrylist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryListClient) GetX(ctx context.Context, id int) *CountryList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CountryListClient) Hooks() []Hook {
	return c.hooks.CountryList
}

// Interceptors returns the client interceptors.
func (c *CountryListClient) Interceptors() []Interceptor {
	return c.inters.CountryList
}

func (c *CountryListClient) mutate(ctx context.Context, m *CountryListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CountryList mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySamples queries the samples edge of a Customer.
func (c *CustomerClient) QuerySamples(cu *Customer) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.SamplesTable, customer.SamplesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerContacts queries the customer_contacts edge of a Customer.
func (c *CustomerClient) QueryCustomerContacts(cu *Customer) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerContactsTable, customer.CustomerContactsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerAddresses queries the customer_addresses edge of a Customer.
func (c *CustomerClient) QueryCustomerAddresses(cu *Customer) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerAddressesTable, customer.CustomerAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinics queries the clinics edge of a Customer.
func (c *CustomerClient) QueryClinics(cu *Customer) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, customer.ClinicsTable, customer.ClinicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a Customer.
func (c *CustomerClient) QuerySales(cu *Customer) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.SalesTable, customer.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Customer.
func (c *CustomerClient) QueryUser(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.UserTable, customer.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a Customer.
func (c *CustomerClient) QueryOrders(cu *Customer) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.OrdersTable, customer.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrentPatients queries the current_patients edge of a Customer.
func (c *CustomerClient) QueryCurrentPatients(cu *Customer) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CurrentPatientsTable, customer.CurrentPatientsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatients queries the patients edge of a Customer.
func (c *CustomerClient) QueryPatients(cu *Customer) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, customer.PatientsTable, customer.PatientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerBetaProgramParticipations queries the customer_beta_program_participations edge of a Customer.
func (c *CustomerClient) QueryCustomerBetaProgramParticipations(cu *Customer) *BetaProgramParticipationQuery {
	query := (&BetaProgramParticipationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(betaprogramparticipation.Table, betaprogramparticipation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerBetaProgramParticipationsTable, customer.CustomerBetaProgramParticipationsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerSettingsOnClinics queries the customer_settings_on_clinics edge of a Customer.
func (c *CustomerClient) QueryCustomerSettingsOnClinics(cu *Customer) *CustomerSettingOnClinicsQuery {
	query := (&CustomerSettingOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customersettingonclinics.Table, customersettingonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerSettingsOnClinicsTable, customer.CustomerSettingsOnClinicsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerAddressesOnClinics queries the customer_addresses_on_clinics edge of a Customer.
func (c *CustomerClient) QueryCustomerAddressesOnClinics(cu *Customer) *CustomerAddressOnClinicsQuery {
	query := (&CustomerAddressOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customeraddressonclinics.Table, customeraddressonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerAddressesOnClinicsTable, customer.CustomerAddressesOnClinicsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerContactsOnClinics queries the customer_contacts_on_clinics edge of a Customer.
func (c *CustomerClient) QueryCustomerContactsOnClinics(cu *Customer) *CustomerContactOnClinicsQuery {
	query := (&CustomerContactOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customercontactonclinics.Table, customercontactonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.CustomerContactsOnClinicsTable, customer.CustomerContactsOnClinicsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	return c.inters.Customer
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Customer mutation op: %q", m.Op())
	}
}

// CustomerAddressOnClinicsClient is a client for the CustomerAddressOnClinics schema.
type CustomerAddressOnClinicsClient struct {
	config
}

// NewCustomerAddressOnClinicsClient returns a client for the CustomerAddressOnClinics from the given config.
func NewCustomerAddressOnClinicsClient(c config) *CustomerAddressOnClinicsClient {
	return &CustomerAddressOnClinicsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customeraddressonclinics.Hooks(f(g(h())))`.
func (c *CustomerAddressOnClinicsClient) Use(hooks ...Hook) {
	c.hooks.CustomerAddressOnClinics = append(c.hooks.CustomerAddressOnClinics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customeraddressonclinics.Intercept(f(g(h())))`.
func (c *CustomerAddressOnClinicsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerAddressOnClinics = append(c.inters.CustomerAddressOnClinics, interceptors...)
}

// Create returns a builder for creating a CustomerAddressOnClinics entity.
func (c *CustomerAddressOnClinicsClient) Create() *CustomerAddressOnClinicsCreate {
	mutation := newCustomerAddressOnClinicsMutation(c.config, OpCreate)
	return &CustomerAddressOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerAddressOnClinics entities.
func (c *CustomerAddressOnClinicsClient) CreateBulk(builders ...*CustomerAddressOnClinicsCreate) *CustomerAddressOnClinicsCreateBulk {
	return &CustomerAddressOnClinicsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerAddressOnClinicsClient) MapCreateBulk(slice any, setFunc func(*CustomerAddressOnClinicsCreate, int)) *CustomerAddressOnClinicsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerAddressOnClinicsCreateBulk{err: fmt.Errorf("calling to CustomerAddressOnClinicsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerAddressOnClinicsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerAddressOnClinicsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) Update() *CustomerAddressOnClinicsUpdate {
	mutation := newCustomerAddressOnClinicsMutation(c.config, OpUpdate)
	return &CustomerAddressOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerAddressOnClinicsClient) UpdateOne(caoc *CustomerAddressOnClinics) *CustomerAddressOnClinicsUpdateOne {
	mutation := newCustomerAddressOnClinicsMutation(c.config, OpUpdateOne, withCustomerAddressOnClinics(caoc))
	return &CustomerAddressOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerAddressOnClinicsClient) UpdateOneID(id int) *CustomerAddressOnClinicsUpdateOne {
	mutation := newCustomerAddressOnClinicsMutation(c.config, OpUpdateOne, withCustomerAddressOnClinicsID(id))
	return &CustomerAddressOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) Delete() *CustomerAddressOnClinicsDelete {
	mutation := newCustomerAddressOnClinicsMutation(c.config, OpDelete)
	return &CustomerAddressOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerAddressOnClinicsClient) DeleteOne(caoc *CustomerAddressOnClinics) *CustomerAddressOnClinicsDeleteOne {
	return c.DeleteOneID(caoc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerAddressOnClinicsClient) DeleteOneID(id int) *CustomerAddressOnClinicsDeleteOne {
	builder := c.Delete().Where(customeraddressonclinics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerAddressOnClinicsDeleteOne{builder}
}

// Query returns a query builder for CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) Query() *CustomerAddressOnClinicsQuery {
	return &CustomerAddressOnClinicsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerAddressOnClinics},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerAddressOnClinics entity by its id.
func (c *CustomerAddressOnClinicsClient) Get(ctx context.Context, id int) (*CustomerAddressOnClinics, error) {
	return c.Query().Where(customeraddressonclinics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerAddressOnClinicsClient) GetX(ctx context.Context, id int) *CustomerAddressOnClinics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) QueryCustomer(caoc *CustomerAddressOnClinics) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := caoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customeraddressonclinics.Table, customeraddressonclinics.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customeraddressonclinics.CustomerTable, customeraddressonclinics.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(caoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinic queries the clinic edge of a CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) QueryClinic(caoc *CustomerAddressOnClinics) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := caoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customeraddressonclinics.Table, customeraddressonclinics.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customeraddressonclinics.ClinicTable, customeraddressonclinics.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(caoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddress queries the address edge of a CustomerAddressOnClinics.
func (c *CustomerAddressOnClinicsClient) QueryAddress(caoc *CustomerAddressOnClinics) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := caoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customeraddressonclinics.Table, customeraddressonclinics.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customeraddressonclinics.AddressTable, customeraddressonclinics.AddressColumn),
		)
		fromV = sqlgraph.Neighbors(caoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerAddressOnClinicsClient) Hooks() []Hook {
	return c.hooks.CustomerAddressOnClinics
}

// Interceptors returns the client interceptors.
func (c *CustomerAddressOnClinicsClient) Interceptors() []Interceptor {
	return c.inters.CustomerAddressOnClinics
}

func (c *CustomerAddressOnClinicsClient) mutate(ctx context.Context, m *CustomerAddressOnClinicsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerAddressOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerAddressOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerAddressOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerAddressOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerAddressOnClinics mutation op: %q", m.Op())
	}
}

// CustomerContactOnClinicsClient is a client for the CustomerContactOnClinics schema.
type CustomerContactOnClinicsClient struct {
	config
}

// NewCustomerContactOnClinicsClient returns a client for the CustomerContactOnClinics from the given config.
func NewCustomerContactOnClinicsClient(c config) *CustomerContactOnClinicsClient {
	return &CustomerContactOnClinicsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customercontactonclinics.Hooks(f(g(h())))`.
func (c *CustomerContactOnClinicsClient) Use(hooks ...Hook) {
	c.hooks.CustomerContactOnClinics = append(c.hooks.CustomerContactOnClinics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customercontactonclinics.Intercept(f(g(h())))`.
func (c *CustomerContactOnClinicsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerContactOnClinics = append(c.inters.CustomerContactOnClinics, interceptors...)
}

// Create returns a builder for creating a CustomerContactOnClinics entity.
func (c *CustomerContactOnClinicsClient) Create() *CustomerContactOnClinicsCreate {
	mutation := newCustomerContactOnClinicsMutation(c.config, OpCreate)
	return &CustomerContactOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerContactOnClinics entities.
func (c *CustomerContactOnClinicsClient) CreateBulk(builders ...*CustomerContactOnClinicsCreate) *CustomerContactOnClinicsCreateBulk {
	return &CustomerContactOnClinicsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerContactOnClinicsClient) MapCreateBulk(slice any, setFunc func(*CustomerContactOnClinicsCreate, int)) *CustomerContactOnClinicsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerContactOnClinicsCreateBulk{err: fmt.Errorf("calling to CustomerContactOnClinicsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerContactOnClinicsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerContactOnClinicsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) Update() *CustomerContactOnClinicsUpdate {
	mutation := newCustomerContactOnClinicsMutation(c.config, OpUpdate)
	return &CustomerContactOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerContactOnClinicsClient) UpdateOne(ccoc *CustomerContactOnClinics) *CustomerContactOnClinicsUpdateOne {
	mutation := newCustomerContactOnClinicsMutation(c.config, OpUpdateOne, withCustomerContactOnClinics(ccoc))
	return &CustomerContactOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerContactOnClinicsClient) UpdateOneID(id int) *CustomerContactOnClinicsUpdateOne {
	mutation := newCustomerContactOnClinicsMutation(c.config, OpUpdateOne, withCustomerContactOnClinicsID(id))
	return &CustomerContactOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) Delete() *CustomerContactOnClinicsDelete {
	mutation := newCustomerContactOnClinicsMutation(c.config, OpDelete)
	return &CustomerContactOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerContactOnClinicsClient) DeleteOne(ccoc *CustomerContactOnClinics) *CustomerContactOnClinicsDeleteOne {
	return c.DeleteOneID(ccoc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerContactOnClinicsClient) DeleteOneID(id int) *CustomerContactOnClinicsDeleteOne {
	builder := c.Delete().Where(customercontactonclinics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerContactOnClinicsDeleteOne{builder}
}

// Query returns a query builder for CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) Query() *CustomerContactOnClinicsQuery {
	return &CustomerContactOnClinicsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerContactOnClinics},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerContactOnClinics entity by its id.
func (c *CustomerContactOnClinicsClient) Get(ctx context.Context, id int) (*CustomerContactOnClinics, error) {
	return c.Query().Where(customercontactonclinics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerContactOnClinicsClient) GetX(ctx context.Context, id int) *CustomerContactOnClinics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) QueryCustomer(ccoc *CustomerContactOnClinics) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ccoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customercontactonclinics.Table, customercontactonclinics.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customercontactonclinics.CustomerTable, customercontactonclinics.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(ccoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinic queries the clinic edge of a CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) QueryClinic(ccoc *CustomerContactOnClinics) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ccoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customercontactonclinics.Table, customercontactonclinics.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customercontactonclinics.ClinicTable, customercontactonclinics.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(ccoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a CustomerContactOnClinics.
func (c *CustomerContactOnClinicsClient) QueryContact(ccoc *CustomerContactOnClinics) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ccoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customercontactonclinics.Table, customercontactonclinics.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customercontactonclinics.ContactTable, customercontactonclinics.ContactColumn),
		)
		fromV = sqlgraph.Neighbors(ccoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerContactOnClinicsClient) Hooks() []Hook {
	return c.hooks.CustomerContactOnClinics
}

// Interceptors returns the client interceptors.
func (c *CustomerContactOnClinicsClient) Interceptors() []Interceptor {
	return c.inters.CustomerContactOnClinics
}

func (c *CustomerContactOnClinicsClient) mutate(ctx context.Context, m *CustomerContactOnClinicsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerContactOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerContactOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerContactOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerContactOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerContactOnClinics mutation op: %q", m.Op())
	}
}

// CustomerSettingOnClinicsClient is a client for the CustomerSettingOnClinics schema.
type CustomerSettingOnClinicsClient struct {
	config
}

// NewCustomerSettingOnClinicsClient returns a client for the CustomerSettingOnClinics from the given config.
func NewCustomerSettingOnClinicsClient(c config) *CustomerSettingOnClinicsClient {
	return &CustomerSettingOnClinicsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customersettingonclinics.Hooks(f(g(h())))`.
func (c *CustomerSettingOnClinicsClient) Use(hooks ...Hook) {
	c.hooks.CustomerSettingOnClinics = append(c.hooks.CustomerSettingOnClinics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customersettingonclinics.Intercept(f(g(h())))`.
func (c *CustomerSettingOnClinicsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerSettingOnClinics = append(c.inters.CustomerSettingOnClinics, interceptors...)
}

// Create returns a builder for creating a CustomerSettingOnClinics entity.
func (c *CustomerSettingOnClinicsClient) Create() *CustomerSettingOnClinicsCreate {
	mutation := newCustomerSettingOnClinicsMutation(c.config, OpCreate)
	return &CustomerSettingOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerSettingOnClinics entities.
func (c *CustomerSettingOnClinicsClient) CreateBulk(builders ...*CustomerSettingOnClinicsCreate) *CustomerSettingOnClinicsCreateBulk {
	return &CustomerSettingOnClinicsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerSettingOnClinicsClient) MapCreateBulk(slice any, setFunc func(*CustomerSettingOnClinicsCreate, int)) *CustomerSettingOnClinicsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerSettingOnClinicsCreateBulk{err: fmt.Errorf("calling to CustomerSettingOnClinicsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerSettingOnClinicsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerSettingOnClinicsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) Update() *CustomerSettingOnClinicsUpdate {
	mutation := newCustomerSettingOnClinicsMutation(c.config, OpUpdate)
	return &CustomerSettingOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerSettingOnClinicsClient) UpdateOne(csoc *CustomerSettingOnClinics) *CustomerSettingOnClinicsUpdateOne {
	mutation := newCustomerSettingOnClinicsMutation(c.config, OpUpdateOne, withCustomerSettingOnClinics(csoc))
	return &CustomerSettingOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerSettingOnClinicsClient) UpdateOneID(id int) *CustomerSettingOnClinicsUpdateOne {
	mutation := newCustomerSettingOnClinicsMutation(c.config, OpUpdateOne, withCustomerSettingOnClinicsID(id))
	return &CustomerSettingOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) Delete() *CustomerSettingOnClinicsDelete {
	mutation := newCustomerSettingOnClinicsMutation(c.config, OpDelete)
	return &CustomerSettingOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerSettingOnClinicsClient) DeleteOne(csoc *CustomerSettingOnClinics) *CustomerSettingOnClinicsDeleteOne {
	return c.DeleteOneID(csoc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerSettingOnClinicsClient) DeleteOneID(id int) *CustomerSettingOnClinicsDeleteOne {
	builder := c.Delete().Where(customersettingonclinics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerSettingOnClinicsDeleteOne{builder}
}

// Query returns a query builder for CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) Query() *CustomerSettingOnClinicsQuery {
	return &CustomerSettingOnClinicsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerSettingOnClinics},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerSettingOnClinics entity by its id.
func (c *CustomerSettingOnClinicsClient) Get(ctx context.Context, id int) (*CustomerSettingOnClinics, error) {
	return c.Query().Where(customersettingonclinics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerSettingOnClinicsClient) GetX(ctx context.Context, id int) *CustomerSettingOnClinics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) QueryCustomer(csoc *CustomerSettingOnClinics) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := csoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customersettingonclinics.Table, customersettingonclinics.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customersettingonclinics.CustomerTable, customersettingonclinics.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(csoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinic queries the clinic edge of a CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) QueryClinic(csoc *CustomerSettingOnClinics) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := csoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customersettingonclinics.Table, customersettingonclinics.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customersettingonclinics.ClinicTable, customersettingonclinics.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(csoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a CustomerSettingOnClinics.
func (c *CustomerSettingOnClinicsClient) QuerySetting(csoc *CustomerSettingOnClinics) *SettingQuery {
	query := (&SettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := csoc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customersettingonclinics.Table, customersettingonclinics.FieldID, id),
			sqlgraph.To(setting.Table, setting.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customersettingonclinics.SettingTable, customersettingonclinics.SettingColumn),
		)
		fromV = sqlgraph.Neighbors(csoc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerSettingOnClinicsClient) Hooks() []Hook {
	return c.hooks.CustomerSettingOnClinics
}

// Interceptors returns the client interceptors.
func (c *CustomerSettingOnClinicsClient) Interceptors() []Interceptor {
	return c.inters.CustomerSettingOnClinics
}

func (c *CustomerSettingOnClinicsClient) mutate(ctx context.Context, m *CustomerSettingOnClinicsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerSettingOnClinicsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerSettingOnClinicsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerSettingOnClinicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerSettingOnClinicsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerSettingOnClinics mutation op: %q", m.Op())
	}
}

// InternalUserClient is a client for the InternalUser schema.
type InternalUserClient struct {
	config
}

// NewInternalUserClient returns a client for the InternalUser from the given config.
func NewInternalUserClient(c config) *InternalUserClient {
	return &InternalUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internaluser.Hooks(f(g(h())))`.
func (c *InternalUserClient) Use(hooks ...Hook) {
	c.hooks.InternalUser = append(c.hooks.InternalUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internaluser.Intercept(f(g(h())))`.
func (c *InternalUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalUser = append(c.inters.InternalUser, interceptors...)
}

// Create returns a builder for creating a InternalUser entity.
func (c *InternalUserClient) Create() *InternalUserCreate {
	mutation := newInternalUserMutation(c.config, OpCreate)
	return &InternalUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalUser entities.
func (c *InternalUserClient) CreateBulk(builders ...*InternalUserCreate) *InternalUserCreateBulk {
	return &InternalUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalUserClient) MapCreateBulk(slice any, setFunc func(*InternalUserCreate, int)) *InternalUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalUserCreateBulk{err: fmt.Errorf("calling to InternalUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalUser.
func (c *InternalUserClient) Update() *InternalUserUpdate {
	mutation := newInternalUserMutation(c.config, OpUpdate)
	return &InternalUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalUserClient) UpdateOne(iu *InternalUser) *InternalUserUpdateOne {
	mutation := newInternalUserMutation(c.config, OpUpdateOne, withInternalUser(iu))
	return &InternalUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalUserClient) UpdateOneID(id int) *InternalUserUpdateOne {
	mutation := newInternalUserMutation(c.config, OpUpdateOne, withInternalUserID(id))
	return &InternalUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalUser.
func (c *InternalUserClient) Delete() *InternalUserDelete {
	mutation := newInternalUserMutation(c.config, OpDelete)
	return &InternalUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalUserClient) DeleteOne(iu *InternalUser) *InternalUserDeleteOne {
	return c.DeleteOneID(iu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalUserClient) DeleteOneID(id int) *InternalUserDeleteOne {
	builder := c.Delete().Where(internaluser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalUserDeleteOne{builder}
}

// Query returns a query builder for InternalUser.
func (c *InternalUserClient) Query() *InternalUserQuery {
	return &InternalUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalUser},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalUser entity by its id.
func (c *InternalUserClient) Get(ctx context.Context, id int) (*InternalUser, error) {
	return c.Query().Where(internaluser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalUserClient) GetX(ctx context.Context, id int) *InternalUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySalesTeam queries the sales_team edge of a InternalUser.
func (c *InternalUserClient) QuerySalesTeam(iu *InternalUser) *SalesTeamQuery {
	query := (&SalesTeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(salesteam.Table, salesteam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, internaluser.SalesTeamTable, internaluser.SalesTeamColumn),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUserContacts queries the internal_user_contacts edge of a InternalUser.
func (c *InternalUserClient) QueryInternalUserContacts(iu *InternalUser) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internaluser.InternalUserContactsTable, internaluser.InternalUserContactsColumn),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUserAddresses queries the internal_user_addresses edge of a InternalUser.
func (c *InternalUserClient) QueryInternalUserAddresses(iu *InternalUser) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internaluser.InternalUserAddressesTable, internaluser.InternalUserAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomers queries the customers edge of a InternalUser.
func (c *InternalUserClient) QueryCustomers(iu *InternalUser) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internaluser.CustomersTable, internaluser.CustomersColumn),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a InternalUser.
func (c *InternalUserClient) QueryUser(iu *InternalUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, internaluser.UserTable, internaluser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUserSettings queries the internal_user_settings edge of a InternalUser.
func (c *InternalUserClient) QueryInternalUserSettings(iu *InternalUser) *SettingQuery {
	query := (&SettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internaluser.Table, internaluser.FieldID, id),
			sqlgraph.To(setting.Table, setting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internaluser.InternalUserSettingsTable, internaluser.InternalUserSettingsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(iu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InternalUserClient) Hooks() []Hook {
	return c.hooks.InternalUser
}

// Interceptors returns the client interceptors.
func (c *InternalUserClient) Interceptors() []Interceptor {
	return c.inters.InternalUser
}

func (c *InternalUserClient) mutate(ctx context.Context, m *InternalUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InternalUser mutation op: %q", m.Op())
	}
}

// LabOrderSendHistoryClient is a client for the LabOrderSendHistory schema.
type LabOrderSendHistoryClient struct {
	config
}

// NewLabOrderSendHistoryClient returns a client for the LabOrderSendHistory from the given config.
func NewLabOrderSendHistoryClient(c config) *LabOrderSendHistoryClient {
	return &LabOrderSendHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `labordersendhistory.Hooks(f(g(h())))`.
func (c *LabOrderSendHistoryClient) Use(hooks ...Hook) {
	c.hooks.LabOrderSendHistory = append(c.hooks.LabOrderSendHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `labordersendhistory.Intercept(f(g(h())))`.
func (c *LabOrderSendHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LabOrderSendHistory = append(c.inters.LabOrderSendHistory, interceptors...)
}

// Create returns a builder for creating a LabOrderSendHistory entity.
func (c *LabOrderSendHistoryClient) Create() *LabOrderSendHistoryCreate {
	mutation := newLabOrderSendHistoryMutation(c.config, OpCreate)
	return &LabOrderSendHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LabOrderSendHistory entities.
func (c *LabOrderSendHistoryClient) CreateBulk(builders ...*LabOrderSendHistoryCreate) *LabOrderSendHistoryCreateBulk {
	return &LabOrderSendHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LabOrderSendHistoryClient) MapCreateBulk(slice any, setFunc func(*LabOrderSendHistoryCreate, int)) *LabOrderSendHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LabOrderSendHistoryCreateBulk{err: fmt.Errorf("calling to LabOrderSendHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LabOrderSendHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LabOrderSendHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LabOrderSendHistory.
func (c *LabOrderSendHistoryClient) Update() *LabOrderSendHistoryUpdate {
	mutation := newLabOrderSendHistoryMutation(c.config, OpUpdate)
	return &LabOrderSendHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LabOrderSendHistoryClient) UpdateOne(losh *LabOrderSendHistory) *LabOrderSendHistoryUpdateOne {
	mutation := newLabOrderSendHistoryMutation(c.config, OpUpdateOne, withLabOrderSendHistory(losh))
	return &LabOrderSendHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LabOrderSendHistoryClient) UpdateOneID(id int) *LabOrderSendHistoryUpdateOne {
	mutation := newLabOrderSendHistoryMutation(c.config, OpUpdateOne, withLabOrderSendHistoryID(id))
	return &LabOrderSendHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LabOrderSendHistory.
func (c *LabOrderSendHistoryClient) Delete() *LabOrderSendHistoryDelete {
	mutation := newLabOrderSendHistoryMutation(c.config, OpDelete)
	return &LabOrderSendHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LabOrderSendHistoryClient) DeleteOne(losh *LabOrderSendHistory) *LabOrderSendHistoryDeleteOne {
	return c.DeleteOneID(losh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LabOrderSendHistoryClient) DeleteOneID(id int) *LabOrderSendHistoryDeleteOne {
	builder := c.Delete().Where(labordersendhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LabOrderSendHistoryDeleteOne{builder}
}

// Query returns a query builder for LabOrderSendHistory.
func (c *LabOrderSendHistoryClient) Query() *LabOrderSendHistoryQuery {
	return &LabOrderSendHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLabOrderSendHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a LabOrderSendHistory entity by its id.
func (c *LabOrderSendHistoryClient) Get(ctx context.Context, id int) (*LabOrderSendHistory, error) {
	return c.Query().Where(labordersendhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LabOrderSendHistoryClient) GetX(ctx context.Context, id int) *LabOrderSendHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySample queries the sample edge of a LabOrderSendHistory.
func (c *LabOrderSendHistoryClient) QuerySample(losh *LabOrderSendHistory) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := losh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(labordersendhistory.Table, labordersendhistory.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, labordersendhistory.SampleTable, labordersendhistory.SampleColumn),
		)
		fromV = sqlgraph.Neighbors(losh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LabOrderSendHistoryClient) Hooks() []Hook {
	return c.hooks.LabOrderSendHistory
}

// Interceptors returns the client interceptors.
func (c *LabOrderSendHistoryClient) Interceptors() []Interceptor {
	return c.inters.LabOrderSendHistory
}

func (c *LabOrderSendHistoryClient) mutate(ctx context.Context, m *LabOrderSendHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LabOrderSendHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LabOrderSendHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LabOrderSendHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LabOrderSendHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LabOrderSendHistory mutation op: %q", m.Op())
	}
}

// LoginHistoryClient is a client for the LoginHistory schema.
type LoginHistoryClient struct {
	config
}

// NewLoginHistoryClient returns a client for the LoginHistory from the given config.
func NewLoginHistoryClient(c config) *LoginHistoryClient {
	return &LoginHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginhistory.Hooks(f(g(h())))`.
func (c *LoginHistoryClient) Use(hooks ...Hook) {
	c.hooks.LoginHistory = append(c.hooks.LoginHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginhistory.Intercept(f(g(h())))`.
func (c *LoginHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginHistory = append(c.inters.LoginHistory, interceptors...)
}

// Create returns a builder for creating a LoginHistory entity.
func (c *LoginHistoryClient) Create() *LoginHistoryCreate {
	mutation := newLoginHistoryMutation(c.config, OpCreate)
	return &LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginHistory entities.
func (c *LoginHistoryClient) CreateBulk(builders ...*LoginHistoryCreate) *LoginHistoryCreateBulk {
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginHistoryClient) MapCreateBulk(slice any, setFunc func(*LoginHistoryCreate, int)) *LoginHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginHistoryCreateBulk{err: fmt.Errorf("calling to LoginHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginHistory.
func (c *LoginHistoryClient) Update() *LoginHistoryUpdate {
	mutation := newLoginHistoryMutation(c.config, OpUpdate)
	return &LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginHistoryClient) UpdateOne(lh *LoginHistory) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistory(lh))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginHistoryClient) UpdateOneID(id int) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistoryID(id))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginHistory.
func (c *LoginHistoryClient) Delete() *LoginHistoryDelete {
	mutation := newLoginHistoryMutation(c.config, OpDelete)
	return &LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginHistoryClient) DeleteOne(lh *LoginHistory) *LoginHistoryDeleteOne {
	return c.DeleteOneID(lh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginHistoryClient) DeleteOneID(id int) *LoginHistoryDeleteOne {
	builder := c.Delete().Where(loginhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginHistoryDeleteOne{builder}
}

// Query returns a query builder for LoginHistory.
func (c *LoginHistoryClient) Query() *LoginHistoryQuery {
	return &LoginHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginHistory entity by its id.
func (c *LoginHistoryClient) Get(ctx context.Context, id int) (*LoginHistory, error) {
	return c.Query().Where(loginhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginHistoryClient) GetX(ctx context.Context, id int) *LoginHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoginHistoryClient) Hooks() []Hook {
	return c.hooks.LoginHistory
}

// Interceptors returns the client interceptors.
func (c *LoginHistoryClient) Interceptors() []Interceptor {
	return c.inters.LoginHistory
}

func (c *LoginHistoryClient) mutate(ctx context.Context, m *LoginHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginHistory mutation op: %q", m.Op())
	}
}

// OrderFlagClient is a client for the OrderFlag schema.
type OrderFlagClient struct {
	config
}

// NewOrderFlagClient returns a client for the OrderFlag from the given config.
func NewOrderFlagClient(c config) *OrderFlagClient {
	return &OrderFlagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderflag.Hooks(f(g(h())))`.
func (c *OrderFlagClient) Use(hooks ...Hook) {
	c.hooks.OrderFlag = append(c.hooks.OrderFlag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderflag.Intercept(f(g(h())))`.
func (c *OrderFlagClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderFlag = append(c.inters.OrderFlag, interceptors...)
}

// Create returns a builder for creating a OrderFlag entity.
func (c *OrderFlagClient) Create() *OrderFlagCreate {
	mutation := newOrderFlagMutation(c.config, OpCreate)
	return &OrderFlagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderFlag entities.
func (c *OrderFlagClient) CreateBulk(builders ...*OrderFlagCreate) *OrderFlagCreateBulk {
	return &OrderFlagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderFlagClient) MapCreateBulk(slice any, setFunc func(*OrderFlagCreate, int)) *OrderFlagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderFlagCreateBulk{err: fmt.Errorf("calling to OrderFlagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderFlagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderFlagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderFlag.
func (c *OrderFlagClient) Update() *OrderFlagUpdate {
	mutation := newOrderFlagMutation(c.config, OpUpdate)
	return &OrderFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderFlagClient) UpdateOne(of *OrderFlag) *OrderFlagUpdateOne {
	mutation := newOrderFlagMutation(c.config, OpUpdateOne, withOrderFlag(of))
	return &OrderFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderFlagClient) UpdateOneID(id int) *OrderFlagUpdateOne {
	mutation := newOrderFlagMutation(c.config, OpUpdateOne, withOrderFlagID(id))
	return &OrderFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderFlag.
func (c *OrderFlagClient) Delete() *OrderFlagDelete {
	mutation := newOrderFlagMutation(c.config, OpDelete)
	return &OrderFlagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderFlagClient) DeleteOne(of *OrderFlag) *OrderFlagDeleteOne {
	return c.DeleteOneID(of.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderFlagClient) DeleteOneID(id int) *OrderFlagDeleteOne {
	builder := c.Delete().Where(orderflag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderFlagDeleteOne{builder}
}

// Query returns a query builder for OrderFlag.
func (c *OrderFlagClient) Query() *OrderFlagQuery {
	return &OrderFlagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderFlag},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderFlag entity by its id.
func (c *OrderFlagClient) Get(ctx context.Context, id int) (*OrderFlag, error) {
	return c.Query().Where(orderflag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderFlagClient) GetX(ctx context.Context, id int) *OrderFlag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFlaggedOrders queries the flagged_orders edge of a OrderFlag.
func (c *OrderFlagClient) QueryFlaggedOrders(of *OrderFlag) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := of.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderflag.Table, orderflag.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orderflag.FlaggedOrdersTable, orderflag.FlaggedOrdersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(of.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderFlagClient) Hooks() []Hook {
	return c.hooks.OrderFlag
}

// Interceptors returns the client interceptors.
func (c *OrderFlagClient) Interceptors() []Interceptor {
	return c.inters.OrderFlag
}

func (c *OrderFlagClient) mutate(ctx context.Context, m *OrderFlagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderFlagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderFlagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderFlag mutation op: %q", m.Op())
	}
}

// OrderInfoClient is a client for the OrderInfo schema.
type OrderInfoClient struct {
	config
}

// NewOrderInfoClient returns a client for the OrderInfo from the given config.
func NewOrderInfoClient(c config) *OrderInfoClient {
	return &OrderInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderinfo.Hooks(f(g(h())))`.
func (c *OrderInfoClient) Use(hooks ...Hook) {
	c.hooks.OrderInfo = append(c.hooks.OrderInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderinfo.Intercept(f(g(h())))`.
func (c *OrderInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderInfo = append(c.inters.OrderInfo, interceptors...)
}

// Create returns a builder for creating a OrderInfo entity.
func (c *OrderInfoClient) Create() *OrderInfoCreate {
	mutation := newOrderInfoMutation(c.config, OpCreate)
	return &OrderInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderInfo entities.
func (c *OrderInfoClient) CreateBulk(builders ...*OrderInfoCreate) *OrderInfoCreateBulk {
	return &OrderInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderInfoClient) MapCreateBulk(slice any, setFunc func(*OrderInfoCreate, int)) *OrderInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderInfoCreateBulk{err: fmt.Errorf("calling to OrderInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderInfo.
func (c *OrderInfoClient) Update() *OrderInfoUpdate {
	mutation := newOrderInfoMutation(c.config, OpUpdate)
	return &OrderInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderInfoClient) UpdateOne(oi *OrderInfo) *OrderInfoUpdateOne {
	mutation := newOrderInfoMutation(c.config, OpUpdateOne, withOrderInfo(oi))
	return &OrderInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderInfoClient) UpdateOneID(id int) *OrderInfoUpdateOne {
	mutation := newOrderInfoMutation(c.config, OpUpdateOne, withOrderInfoID(id))
	return &OrderInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderInfo.
func (c *OrderInfoClient) Delete() *OrderInfoDelete {
	mutation := newOrderInfoMutation(c.config, OpDelete)
	return &OrderInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderInfoClient) DeleteOne(oi *OrderInfo) *OrderInfoDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderInfoClient) DeleteOneID(id int) *OrderInfoDeleteOne {
	builder := c.Delete().Where(orderinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderInfoDeleteOne{builder}
}

// Query returns a query builder for OrderInfo.
func (c *OrderInfoClient) Query() *OrderInfoQuery {
	return &OrderInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderInfo entity by its id.
func (c *OrderInfoClient) Get(ctx context.Context, id int) (*OrderInfo, error) {
	return c.Query().Where(orderinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderInfoClient) GetX(ctx context.Context, id int) *OrderInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTests queries the tests edge of a OrderInfo.
func (c *OrderInfoClient) QueryTests(oi *OrderInfo) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orderinfo.TestsTable, orderinfo.TestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderFlags queries the order_flags edge of a OrderInfo.
func (c *OrderInfoClient) QueryOrderFlags(oi *OrderInfo) *OrderFlagQuery {
	query := (&OrderFlagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(orderflag.Table, orderflag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, orderinfo.OrderFlagsTable, orderinfo.OrderFlagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySample queries the sample edge of a OrderInfo.
func (c *OrderInfoClient) QuerySample(oi *OrderInfo) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, orderinfo.SampleTable, orderinfo.SampleColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a OrderInfo.
func (c *OrderInfoClient) QueryContact(oi *OrderInfo) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderinfo.ContactTable, orderinfo.ContactColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddress queries the address edge of a OrderInfo.
func (c *OrderInfoClient) QueryAddress(oi *OrderInfo) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderinfo.AddressTable, orderinfo.AddressColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinic queries the clinic edge of a OrderInfo.
func (c *OrderInfoClient) QueryClinic(oi *OrderInfo) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderinfo.ClinicTable, orderinfo.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerInfo queries the customer_info edge of a OrderInfo.
func (c *OrderInfoClient) QueryCustomerInfo(oi *OrderInfo) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderinfo.Table, orderinfo.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderinfo.CustomerInfoTable, orderinfo.CustomerInfoColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderInfoClient) Hooks() []Hook {
	return c.hooks.OrderInfo
}

// Interceptors returns the client interceptors.
func (c *OrderInfoClient) Interceptors() []Interceptor {
	return c.inters.OrderInfo
}

func (c *OrderInfoClient) mutate(ctx context.Context, m *OrderInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderInfo mutation op: %q", m.Op())
	}
}

// PatientClient is a client for the Patient schema.
type PatientClient struct {
	config
}

// NewPatientClient returns a client for the Patient from the given config.
func NewPatientClient(c config) *PatientClient {
	return &PatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patient.Hooks(f(g(h())))`.
func (c *PatientClient) Use(hooks ...Hook) {
	c.hooks.Patient = append(c.hooks.Patient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patient.Intercept(f(g(h())))`.
func (c *PatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Patient = append(c.inters.Patient, interceptors...)
}

// Create returns a builder for creating a Patient entity.
func (c *PatientClient) Create() *PatientCreate {
	mutation := newPatientMutation(c.config, OpCreate)
	return &PatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Patient entities.
func (c *PatientClient) CreateBulk(builders ...*PatientCreate) *PatientCreateBulk {
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientClient) MapCreateBulk(slice any, setFunc func(*PatientCreate, int)) *PatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientCreateBulk{err: fmt.Errorf("calling to PatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Patient.
func (c *PatientClient) Update() *PatientUpdate {
	mutation := newPatientMutation(c.config, OpUpdate)
	return &PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientClient) UpdateOne(pa *Patient) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatient(pa))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientClient) UpdateOneID(id int) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatientID(id))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Patient.
func (c *PatientClient) Delete() *PatientDelete {
	mutation := newPatientMutation(c.config, OpDelete)
	return &PatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientClient) DeleteOne(pa *Patient) *PatientDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientClient) DeleteOneID(id int) *PatientDeleteOne {
	builder := c.Delete().Where(patient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientDeleteOne{builder}
}

// Query returns a query builder for Patient.
func (c *PatientClient) Query() *PatientQuery {
	return &PatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Patient entity by its id.
func (c *PatientClient) Get(ctx context.Context, id int) (*Patient, error) {
	return c.Query().Where(patient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientClient) GetX(ctx context.Context, id int) *Patient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCurrentCustomer queries the current_customer edge of a Patient.
func (c *PatientClient) QueryCurrentCustomer(pa *Patient) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, patient.CurrentCustomerTable, patient.CurrentCustomerColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientCustomers queries the patient_customers edge of a Patient.
func (c *PatientClient) QueryPatientCustomers(pa *Patient) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, patient.PatientCustomersTable, patient.PatientCustomersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySamples queries the samples edge of a Patient.
func (c *PatientClient) QuerySamples(pa *Patient) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.SamplesTable, patient.SamplesColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientContacts queries the patient_contacts edge of a Patient.
func (c *PatientClient) QueryPatientContacts(pa *Patient) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.PatientContactsTable, patient.PatientContactsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientAddresses queries the patient_addresses edge of a Patient.
func (c *PatientClient) QueryPatientAddresses(pa *Patient) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.PatientAddressesTable, patient.PatientAddressesColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientClinics queries the patient_clinics edge of a Patient.
func (c *PatientClient) QueryPatientClinics(pa *Patient) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, patient.PatientClinicsTable, patient.PatientClinicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Patient.
func (c *PatientClient) QueryUser(pa *Patient) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, patient.UserTable, patient.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientWeightHeightHistory queries the patient_weight_height_history edge of a Patient.
func (c *PatientClient) QueryPatientWeightHeightHistory(pa *Patient) *PatientWeightHeightQuery {
	query := (&PatientWeightHeightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(patientweightheight.Table, patientweightheight.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.PatientWeightHeightHistoryTable, patient.PatientWeightHeightHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientSettings queries the patient_settings edge of a Patient.
func (c *PatientClient) QueryPatientSettings(pa *Patient) *SettingQuery {
	query := (&SettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(setting.Table, setting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, patient.PatientSettingsTable, patient.PatientSettingsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PatientClient) Hooks() []Hook {
	return c.hooks.Patient
}

// Interceptors returns the client interceptors.
func (c *PatientClient) Interceptors() []Interceptor {
	return c.inters.Patient
}

func (c *PatientClient) mutate(ctx context.Context, m *PatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Patient mutation op: %q", m.Op())
	}
}

// PatientFlagClient is a client for the PatientFlag schema.
type PatientFlagClient struct {
	config
}

// NewPatientFlagClient returns a client for the PatientFlag from the given config.
func NewPatientFlagClient(c config) *PatientFlagClient {
	return &PatientFlagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patientflag.Hooks(f(g(h())))`.
func (c *PatientFlagClient) Use(hooks ...Hook) {
	c.hooks.PatientFlag = append(c.hooks.PatientFlag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patientflag.Intercept(f(g(h())))`.
func (c *PatientFlagClient) Intercept(interceptors ...Interceptor) {
	c.inters.PatientFlag = append(c.inters.PatientFlag, interceptors...)
}

// Create returns a builder for creating a PatientFlag entity.
func (c *PatientFlagClient) Create() *PatientFlagCreate {
	mutation := newPatientFlagMutation(c.config, OpCreate)
	return &PatientFlagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PatientFlag entities.
func (c *PatientFlagClient) CreateBulk(builders ...*PatientFlagCreate) *PatientFlagCreateBulk {
	return &PatientFlagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientFlagClient) MapCreateBulk(slice any, setFunc func(*PatientFlagCreate, int)) *PatientFlagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientFlagCreateBulk{err: fmt.Errorf("calling to PatientFlagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientFlagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientFlagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PatientFlag.
func (c *PatientFlagClient) Update() *PatientFlagUpdate {
	mutation := newPatientFlagMutation(c.config, OpUpdate)
	return &PatientFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientFlagClient) UpdateOne(pf *PatientFlag) *PatientFlagUpdateOne {
	mutation := newPatientFlagMutation(c.config, OpUpdateOne, withPatientFlag(pf))
	return &PatientFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientFlagClient) UpdateOneID(id int) *PatientFlagUpdateOne {
	mutation := newPatientFlagMutation(c.config, OpUpdateOne, withPatientFlagID(id))
	return &PatientFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PatientFlag.
func (c *PatientFlagClient) Delete() *PatientFlagDelete {
	mutation := newPatientFlagMutation(c.config, OpDelete)
	return &PatientFlagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientFlagClient) DeleteOne(pf *PatientFlag) *PatientFlagDeleteOne {
	return c.DeleteOneID(pf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientFlagClient) DeleteOneID(id int) *PatientFlagDeleteOne {
	builder := c.Delete().Where(patientflag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientFlagDeleteOne{builder}
}

// Query returns a query builder for PatientFlag.
func (c *PatientFlagClient) Query() *PatientFlagQuery {
	return &PatientFlagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatientFlag},
		inters: c.Interceptors(),
	}
}

// Get returns a PatientFlag entity by its id.
func (c *PatientFlagClient) Get(ctx context.Context, id int) (*PatientFlag, error) {
	return c.Query().Where(patientflag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientFlagClient) GetX(ctx context.Context, id int) *PatientFlag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PatientFlagClient) Hooks() []Hook {
	return c.hooks.PatientFlag
}

// Interceptors returns the client interceptors.
func (c *PatientFlagClient) Interceptors() []Interceptor {
	return c.inters.PatientFlag
}

func (c *PatientFlagClient) mutate(ctx context.Context, m *PatientFlagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientFlagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientFlagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PatientFlag mutation op: %q", m.Op())
	}
}

// PatientWeightHeightClient is a client for the PatientWeightHeight schema.
type PatientWeightHeightClient struct {
	config
}

// NewPatientWeightHeightClient returns a client for the PatientWeightHeight from the given config.
func NewPatientWeightHeightClient(c config) *PatientWeightHeightClient {
	return &PatientWeightHeightClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patientweightheight.Hooks(f(g(h())))`.
func (c *PatientWeightHeightClient) Use(hooks ...Hook) {
	c.hooks.PatientWeightHeight = append(c.hooks.PatientWeightHeight, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patientweightheight.Intercept(f(g(h())))`.
func (c *PatientWeightHeightClient) Intercept(interceptors ...Interceptor) {
	c.inters.PatientWeightHeight = append(c.inters.PatientWeightHeight, interceptors...)
}

// Create returns a builder for creating a PatientWeightHeight entity.
func (c *PatientWeightHeightClient) Create() *PatientWeightHeightCreate {
	mutation := newPatientWeightHeightMutation(c.config, OpCreate)
	return &PatientWeightHeightCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PatientWeightHeight entities.
func (c *PatientWeightHeightClient) CreateBulk(builders ...*PatientWeightHeightCreate) *PatientWeightHeightCreateBulk {
	return &PatientWeightHeightCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientWeightHeightClient) MapCreateBulk(slice any, setFunc func(*PatientWeightHeightCreate, int)) *PatientWeightHeightCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientWeightHeightCreateBulk{err: fmt.Errorf("calling to PatientWeightHeightClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientWeightHeightCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientWeightHeightCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PatientWeightHeight.
func (c *PatientWeightHeightClient) Update() *PatientWeightHeightUpdate {
	mutation := newPatientWeightHeightMutation(c.config, OpUpdate)
	return &PatientWeightHeightUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientWeightHeightClient) UpdateOne(pwh *PatientWeightHeight) *PatientWeightHeightUpdateOne {
	mutation := newPatientWeightHeightMutation(c.config, OpUpdateOne, withPatientWeightHeight(pwh))
	return &PatientWeightHeightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientWeightHeightClient) UpdateOneID(id int) *PatientWeightHeightUpdateOne {
	mutation := newPatientWeightHeightMutation(c.config, OpUpdateOne, withPatientWeightHeightID(id))
	return &PatientWeightHeightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PatientWeightHeight.
func (c *PatientWeightHeightClient) Delete() *PatientWeightHeightDelete {
	mutation := newPatientWeightHeightMutation(c.config, OpDelete)
	return &PatientWeightHeightDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientWeightHeightClient) DeleteOne(pwh *PatientWeightHeight) *PatientWeightHeightDeleteOne {
	return c.DeleteOneID(pwh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientWeightHeightClient) DeleteOneID(id int) *PatientWeightHeightDeleteOne {
	builder := c.Delete().Where(patientweightheight.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientWeightHeightDeleteOne{builder}
}

// Query returns a query builder for PatientWeightHeight.
func (c *PatientWeightHeightClient) Query() *PatientWeightHeightQuery {
	return &PatientWeightHeightQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatientWeightHeight},
		inters: c.Interceptors(),
	}
}

// Get returns a PatientWeightHeight entity by its id.
func (c *PatientWeightHeightClient) Get(ctx context.Context, id int) (*PatientWeightHeight, error) {
	return c.Query().Where(patientweightheight.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientWeightHeightClient) GetX(ctx context.Context, id int) *PatientWeightHeight {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPatient queries the patient edge of a PatientWeightHeight.
func (c *PatientWeightHeightClient) QueryPatient(pwh *PatientWeightHeight) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pwh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patientweightheight.Table, patientweightheight.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, patientweightheight.PatientTable, patientweightheight.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(pwh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PatientWeightHeightClient) Hooks() []Hook {
	return c.hooks.PatientWeightHeight
}

// Interceptors returns the client interceptors.
func (c *PatientWeightHeightClient) Interceptors() []Interceptor {
	return c.inters.PatientWeightHeight
}

func (c *PatientWeightHeightClient) mutate(ctx context.Context, m *PatientWeightHeightMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientWeightHeightCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientWeightHeightUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientWeightHeightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientWeightHeightDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PatientWeightHeight mutation op: %q", m.Op())
	}
}

// PendingOrderCreditsClient is a client for the PendingOrderCredits schema.
type PendingOrderCreditsClient struct {
	config
}

// NewPendingOrderCreditsClient returns a client for the PendingOrderCredits from the given config.
func NewPendingOrderCreditsClient(c config) *PendingOrderCreditsClient {
	return &PendingOrderCreditsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pendingordercredits.Hooks(f(g(h())))`.
func (c *PendingOrderCreditsClient) Use(hooks ...Hook) {
	c.hooks.PendingOrderCredits = append(c.hooks.PendingOrderCredits, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pendingordercredits.Intercept(f(g(h())))`.
func (c *PendingOrderCreditsClient) Intercept(interceptors ...Interceptor) {
	c.inters.PendingOrderCredits = append(c.inters.PendingOrderCredits, interceptors...)
}

// Create returns a builder for creating a PendingOrderCredits entity.
func (c *PendingOrderCreditsClient) Create() *PendingOrderCreditsCreate {
	mutation := newPendingOrderCreditsMutation(c.config, OpCreate)
	return &PendingOrderCreditsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PendingOrderCredits entities.
func (c *PendingOrderCreditsClient) CreateBulk(builders ...*PendingOrderCreditsCreate) *PendingOrderCreditsCreateBulk {
	return &PendingOrderCreditsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PendingOrderCreditsClient) MapCreateBulk(slice any, setFunc func(*PendingOrderCreditsCreate, int)) *PendingOrderCreditsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PendingOrderCreditsCreateBulk{err: fmt.Errorf("calling to PendingOrderCreditsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PendingOrderCreditsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PendingOrderCreditsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PendingOrderCredits.
func (c *PendingOrderCreditsClient) Update() *PendingOrderCreditsUpdate {
	mutation := newPendingOrderCreditsMutation(c.config, OpUpdate)
	return &PendingOrderCreditsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PendingOrderCreditsClient) UpdateOne(poc *PendingOrderCredits) *PendingOrderCreditsUpdateOne {
	mutation := newPendingOrderCreditsMutation(c.config, OpUpdateOne, withPendingOrderCredits(poc))
	return &PendingOrderCreditsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PendingOrderCreditsClient) UpdateOneID(id int) *PendingOrderCreditsUpdateOne {
	mutation := newPendingOrderCreditsMutation(c.config, OpUpdateOne, withPendingOrderCreditsID(id))
	return &PendingOrderCreditsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PendingOrderCredits.
func (c *PendingOrderCreditsClient) Delete() *PendingOrderCreditsDelete {
	mutation := newPendingOrderCreditsMutation(c.config, OpDelete)
	return &PendingOrderCreditsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PendingOrderCreditsClient) DeleteOne(poc *PendingOrderCredits) *PendingOrderCreditsDeleteOne {
	return c.DeleteOneID(poc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PendingOrderCreditsClient) DeleteOneID(id int) *PendingOrderCreditsDeleteOne {
	builder := c.Delete().Where(pendingordercredits.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PendingOrderCreditsDeleteOne{builder}
}

// Query returns a query builder for PendingOrderCredits.
func (c *PendingOrderCreditsClient) Query() *PendingOrderCreditsQuery {
	return &PendingOrderCreditsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePendingOrderCredits},
		inters: c.Interceptors(),
	}
}

// Get returns a PendingOrderCredits entity by its id.
func (c *PendingOrderCreditsClient) Get(ctx context.Context, id int) (*PendingOrderCredits, error) {
	return c.Query().Where(pendingordercredits.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PendingOrderCreditsClient) GetX(ctx context.Context, id int) *PendingOrderCredits {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PendingOrderCreditsClient) Hooks() []Hook {
	return c.hooks.PendingOrderCredits
}

// Interceptors returns the client interceptors.
func (c *PendingOrderCreditsClient) Interceptors() []Interceptor {
	return c.inters.PendingOrderCredits
}

func (c *PendingOrderCreditsClient) mutate(ctx context.Context, m *PendingOrderCreditsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PendingOrderCreditsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PendingOrderCreditsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PendingOrderCreditsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PendingOrderCreditsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PendingOrderCredits mutation op: %q", m.Op())
	}
}

// RBACActionsClient is a client for the RBACActions schema.
type RBACActionsClient struct {
	config
}

// NewRBACActionsClient returns a client for the RBACActions from the given config.
func NewRBACActionsClient(c config) *RBACActionsClient {
	return &RBACActionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rbacactions.Hooks(f(g(h())))`.
func (c *RBACActionsClient) Use(hooks ...Hook) {
	c.hooks.RBACActions = append(c.hooks.RBACActions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rbacactions.Intercept(f(g(h())))`.
func (c *RBACActionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.RBACActions = append(c.inters.RBACActions, interceptors...)
}

// Create returns a builder for creating a RBACActions entity.
func (c *RBACActionsClient) Create() *RBACActionsCreate {
	mutation := newRBACActionsMutation(c.config, OpCreate)
	return &RBACActionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RBACActions entities.
func (c *RBACActionsClient) CreateBulk(builders ...*RBACActionsCreate) *RBACActionsCreateBulk {
	return &RBACActionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RBACActionsClient) MapCreateBulk(slice any, setFunc func(*RBACActionsCreate, int)) *RBACActionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RBACActionsCreateBulk{err: fmt.Errorf("calling to RBACActionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RBACActionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RBACActionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RBACActions.
func (c *RBACActionsClient) Update() *RBACActionsUpdate {
	mutation := newRBACActionsMutation(c.config, OpUpdate)
	return &RBACActionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RBACActionsClient) UpdateOne(ra *RBACActions) *RBACActionsUpdateOne {
	mutation := newRBACActionsMutation(c.config, OpUpdateOne, withRBACActions(ra))
	return &RBACActionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RBACActionsClient) UpdateOneID(id int) *RBACActionsUpdateOne {
	mutation := newRBACActionsMutation(c.config, OpUpdateOne, withRBACActionsID(id))
	return &RBACActionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RBACActions.
func (c *RBACActionsClient) Delete() *RBACActionsDelete {
	mutation := newRBACActionsMutation(c.config, OpDelete)
	return &RBACActionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RBACActionsClient) DeleteOne(ra *RBACActions) *RBACActionsDeleteOne {
	return c.DeleteOneID(ra.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RBACActionsClient) DeleteOneID(id int) *RBACActionsDeleteOne {
	builder := c.Delete().Where(rbacactions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RBACActionsDeleteOne{builder}
}

// Query returns a query builder for RBACActions.
func (c *RBACActionsClient) Query() *RBACActionsQuery {
	return &RBACActionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRBACActions},
		inters: c.Interceptors(),
	}
}

// Get returns a RBACActions entity by its id.
func (c *RBACActionsClient) Get(ctx context.Context, id int) (*RBACActions, error) {
	return c.Query().Where(rbacactions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RBACActionsClient) GetX(ctx context.Context, id int) *RBACActions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RBACActionsClient) Hooks() []Hook {
	return c.hooks.RBACActions
}

// Interceptors returns the client interceptors.
func (c *RBACActionsClient) Interceptors() []Interceptor {
	return c.inters.RBACActions
}

func (c *RBACActionsClient) mutate(ctx context.Context, m *RBACActionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RBACActionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RBACActionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RBACActionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RBACActionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RBACActions mutation op: %q", m.Op())
	}
}

// RBACResourcesClient is a client for the RBACResources schema.
type RBACResourcesClient struct {
	config
}

// NewRBACResourcesClient returns a client for the RBACResources from the given config.
func NewRBACResourcesClient(c config) *RBACResourcesClient {
	return &RBACResourcesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rbacresources.Hooks(f(g(h())))`.
func (c *RBACResourcesClient) Use(hooks ...Hook) {
	c.hooks.RBACResources = append(c.hooks.RBACResources, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rbacresources.Intercept(f(g(h())))`.
func (c *RBACResourcesClient) Intercept(interceptors ...Interceptor) {
	c.inters.RBACResources = append(c.inters.RBACResources, interceptors...)
}

// Create returns a builder for creating a RBACResources entity.
func (c *RBACResourcesClient) Create() *RBACResourcesCreate {
	mutation := newRBACResourcesMutation(c.config, OpCreate)
	return &RBACResourcesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RBACResources entities.
func (c *RBACResourcesClient) CreateBulk(builders ...*RBACResourcesCreate) *RBACResourcesCreateBulk {
	return &RBACResourcesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RBACResourcesClient) MapCreateBulk(slice any, setFunc func(*RBACResourcesCreate, int)) *RBACResourcesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RBACResourcesCreateBulk{err: fmt.Errorf("calling to RBACResourcesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RBACResourcesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RBACResourcesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RBACResources.
func (c *RBACResourcesClient) Update() *RBACResourcesUpdate {
	mutation := newRBACResourcesMutation(c.config, OpUpdate)
	return &RBACResourcesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RBACResourcesClient) UpdateOne(rr *RBACResources) *RBACResourcesUpdateOne {
	mutation := newRBACResourcesMutation(c.config, OpUpdateOne, withRBACResources(rr))
	return &RBACResourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RBACResourcesClient) UpdateOneID(id int) *RBACResourcesUpdateOne {
	mutation := newRBACResourcesMutation(c.config, OpUpdateOne, withRBACResourcesID(id))
	return &RBACResourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RBACResources.
func (c *RBACResourcesClient) Delete() *RBACResourcesDelete {
	mutation := newRBACResourcesMutation(c.config, OpDelete)
	return &RBACResourcesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RBACResourcesClient) DeleteOne(rr *RBACResources) *RBACResourcesDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RBACResourcesClient) DeleteOneID(id int) *RBACResourcesDeleteOne {
	builder := c.Delete().Where(rbacresources.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RBACResourcesDeleteOne{builder}
}

// Query returns a query builder for RBACResources.
func (c *RBACResourcesClient) Query() *RBACResourcesQuery {
	return &RBACResourcesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRBACResources},
		inters: c.Interceptors(),
	}
}

// Get returns a RBACResources entity by its id.
func (c *RBACResourcesClient) Get(ctx context.Context, id int) (*RBACResources, error) {
	return c.Query().Where(rbacresources.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RBACResourcesClient) GetX(ctx context.Context, id int) *RBACResources {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RBACResourcesClient) Hooks() []Hook {
	return c.hooks.RBACResources
}

// Interceptors returns the client interceptors.
func (c *RBACResourcesClient) Interceptors() []Interceptor {
	return c.inters.RBACResources
}

func (c *RBACResourcesClient) mutate(ctx context.Context, m *RBACResourcesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RBACResourcesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RBACResourcesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RBACResourcesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RBACResourcesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RBACResources mutation op: %q", m.Op())
	}
}

// RBACRolesClient is a client for the RBACRoles schema.
type RBACRolesClient struct {
	config
}

// NewRBACRolesClient returns a client for the RBACRoles from the given config.
func NewRBACRolesClient(c config) *RBACRolesClient {
	return &RBACRolesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rbacroles.Hooks(f(g(h())))`.
func (c *RBACRolesClient) Use(hooks ...Hook) {
	c.hooks.RBACRoles = append(c.hooks.RBACRoles, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rbacroles.Intercept(f(g(h())))`.
func (c *RBACRolesClient) Intercept(interceptors ...Interceptor) {
	c.inters.RBACRoles = append(c.inters.RBACRoles, interceptors...)
}

// Create returns a builder for creating a RBACRoles entity.
func (c *RBACRolesClient) Create() *RBACRolesCreate {
	mutation := newRBACRolesMutation(c.config, OpCreate)
	return &RBACRolesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RBACRoles entities.
func (c *RBACRolesClient) CreateBulk(builders ...*RBACRolesCreate) *RBACRolesCreateBulk {
	return &RBACRolesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RBACRolesClient) MapCreateBulk(slice any, setFunc func(*RBACRolesCreate, int)) *RBACRolesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RBACRolesCreateBulk{err: fmt.Errorf("calling to RBACRolesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RBACRolesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RBACRolesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RBACRoles.
func (c *RBACRolesClient) Update() *RBACRolesUpdate {
	mutation := newRBACRolesMutation(c.config, OpUpdate)
	return &RBACRolesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RBACRolesClient) UpdateOne(rr *RBACRoles) *RBACRolesUpdateOne {
	mutation := newRBACRolesMutation(c.config, OpUpdateOne, withRBACRoles(rr))
	return &RBACRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RBACRolesClient) UpdateOneID(id int) *RBACRolesUpdateOne {
	mutation := newRBACRolesMutation(c.config, OpUpdateOne, withRBACRolesID(id))
	return &RBACRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RBACRoles.
func (c *RBACRolesClient) Delete() *RBACRolesDelete {
	mutation := newRBACRolesMutation(c.config, OpDelete)
	return &RBACRolesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RBACRolesClient) DeleteOne(rr *RBACRoles) *RBACRolesDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RBACRolesClient) DeleteOneID(id int) *RBACRolesDeleteOne {
	builder := c.Delete().Where(rbacroles.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RBACRolesDeleteOne{builder}
}

// Query returns a query builder for RBACRoles.
func (c *RBACRolesClient) Query() *RBACRolesQuery {
	return &RBACRolesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRBACRoles},
		inters: c.Interceptors(),
	}
}

// Get returns a RBACRoles entity by its id.
func (c *RBACRolesClient) Get(ctx context.Context, id int) (*RBACRoles, error) {
	return c.Query().Where(rbacroles.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RBACRolesClient) GetX(ctx context.Context, id int) *RBACRoles {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RBACRolesClient) Hooks() []Hook {
	return c.hooks.RBACRoles
}

// Interceptors returns the client interceptors.
func (c *RBACRolesClient) Interceptors() []Interceptor {
	return c.inters.RBACRoles
}

func (c *RBACRolesClient) mutate(ctx context.Context, m *RBACRolesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RBACRolesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RBACRolesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RBACRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RBACRolesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RBACRoles mutation op: %q", m.Op())
	}
}

// SalesTeamClient is a client for the SalesTeam schema.
type SalesTeamClient struct {
	config
}

// NewSalesTeamClient returns a client for the SalesTeam from the given config.
func NewSalesTeamClient(c config) *SalesTeamClient {
	return &SalesTeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `salesteam.Hooks(f(g(h())))`.
func (c *SalesTeamClient) Use(hooks ...Hook) {
	c.hooks.SalesTeam = append(c.hooks.SalesTeam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `salesteam.Intercept(f(g(h())))`.
func (c *SalesTeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.SalesTeam = append(c.inters.SalesTeam, interceptors...)
}

// Create returns a builder for creating a SalesTeam entity.
func (c *SalesTeamClient) Create() *SalesTeamCreate {
	mutation := newSalesTeamMutation(c.config, OpCreate)
	return &SalesTeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SalesTeam entities.
func (c *SalesTeamClient) CreateBulk(builders ...*SalesTeamCreate) *SalesTeamCreateBulk {
	return &SalesTeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SalesTeamClient) MapCreateBulk(slice any, setFunc func(*SalesTeamCreate, int)) *SalesTeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SalesTeamCreateBulk{err: fmt.Errorf("calling to SalesTeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SalesTeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SalesTeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SalesTeam.
func (c *SalesTeamClient) Update() *SalesTeamUpdate {
	mutation := newSalesTeamMutation(c.config, OpUpdate)
	return &SalesTeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SalesTeamClient) UpdateOne(st *SalesTeam) *SalesTeamUpdateOne {
	mutation := newSalesTeamMutation(c.config, OpUpdateOne, withSalesTeam(st))
	return &SalesTeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SalesTeamClient) UpdateOneID(id int) *SalesTeamUpdateOne {
	mutation := newSalesTeamMutation(c.config, OpUpdateOne, withSalesTeamID(id))
	return &SalesTeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SalesTeam.
func (c *SalesTeamClient) Delete() *SalesTeamDelete {
	mutation := newSalesTeamMutation(c.config, OpDelete)
	return &SalesTeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SalesTeamClient) DeleteOne(st *SalesTeam) *SalesTeamDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SalesTeamClient) DeleteOneID(id int) *SalesTeamDeleteOne {
	builder := c.Delete().Where(salesteam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SalesTeamDeleteOne{builder}
}

// Query returns a query builder for SalesTeam.
func (c *SalesTeamClient) Query() *SalesTeamQuery {
	return &SalesTeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSalesTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a SalesTeam entity by its id.
func (c *SalesTeamClient) Get(ctx context.Context, id int) (*SalesTeam, error) {
	return c.Query().Where(salesteam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SalesTeamClient) GetX(ctx context.Context, id int) *SalesTeam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubordinates queries the subordinates edge of a SalesTeam.
func (c *SalesTeamClient) QuerySubordinates(st *SalesTeam) *SalesTeamQuery {
	query := (&SalesTeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(salesteam.Table, salesteam.FieldID, id),
			sqlgraph.To(salesteam.Table, salesteam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, salesteam.SubordinatesTable, salesteam.SubordinatesColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySupervisor queries the supervisor edge of a SalesTeam.
func (c *SalesTeamClient) QuerySupervisor(st *SalesTeam) *SalesTeamQuery {
	query := (&SalesTeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(salesteam.Table, salesteam.FieldID, id),
			sqlgraph.To(salesteam.Table, salesteam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, salesteam.SupervisorTable, salesteam.SupervisorColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUser queries the internal_user edge of a SalesTeam.
func (c *SalesTeamClient) QueryInternalUser(st *SalesTeam) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(salesteam.Table, salesteam.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, salesteam.InternalUserTable, salesteam.InternalUserColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitle queries the title edge of a SalesTeam.
func (c *SalesTeamClient) QueryTitle(st *SalesTeam) *SalesTitleQuery {
	query := (&SalesTitleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(salesteam.Table, salesteam.FieldID, id),
			sqlgraph.To(salestitle.Table, salestitle.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, salesteam.TitleTable, salesteam.TitleColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SalesTeamClient) Hooks() []Hook {
	return c.hooks.SalesTeam
}

// Interceptors returns the client interceptors.
func (c *SalesTeamClient) Interceptors() []Interceptor {
	return c.inters.SalesTeam
}

func (c *SalesTeamClient) mutate(ctx context.Context, m *SalesTeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SalesTeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SalesTeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SalesTeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SalesTeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SalesTeam mutation op: %q", m.Op())
	}
}

// SalesTerritoryClient is a client for the SalesTerritory schema.
type SalesTerritoryClient struct {
	config
}

// NewSalesTerritoryClient returns a client for the SalesTerritory from the given config.
func NewSalesTerritoryClient(c config) *SalesTerritoryClient {
	return &SalesTerritoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `salesterritory.Hooks(f(g(h())))`.
func (c *SalesTerritoryClient) Use(hooks ...Hook) {
	c.hooks.SalesTerritory = append(c.hooks.SalesTerritory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `salesterritory.Intercept(f(g(h())))`.
func (c *SalesTerritoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SalesTerritory = append(c.inters.SalesTerritory, interceptors...)
}

// Create returns a builder for creating a SalesTerritory entity.
func (c *SalesTerritoryClient) Create() *SalesTerritoryCreate {
	mutation := newSalesTerritoryMutation(c.config, OpCreate)
	return &SalesTerritoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SalesTerritory entities.
func (c *SalesTerritoryClient) CreateBulk(builders ...*SalesTerritoryCreate) *SalesTerritoryCreateBulk {
	return &SalesTerritoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SalesTerritoryClient) MapCreateBulk(slice any, setFunc func(*SalesTerritoryCreate, int)) *SalesTerritoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SalesTerritoryCreateBulk{err: fmt.Errorf("calling to SalesTerritoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SalesTerritoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SalesTerritoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SalesTerritory.
func (c *SalesTerritoryClient) Update() *SalesTerritoryUpdate {
	mutation := newSalesTerritoryMutation(c.config, OpUpdate)
	return &SalesTerritoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SalesTerritoryClient) UpdateOne(st *SalesTerritory) *SalesTerritoryUpdateOne {
	mutation := newSalesTerritoryMutation(c.config, OpUpdateOne, withSalesTerritory(st))
	return &SalesTerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SalesTerritoryClient) UpdateOneID(id int) *SalesTerritoryUpdateOne {
	mutation := newSalesTerritoryMutation(c.config, OpUpdateOne, withSalesTerritoryID(id))
	return &SalesTerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SalesTerritory.
func (c *SalesTerritoryClient) Delete() *SalesTerritoryDelete {
	mutation := newSalesTerritoryMutation(c.config, OpDelete)
	return &SalesTerritoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SalesTerritoryClient) DeleteOne(st *SalesTerritory) *SalesTerritoryDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SalesTerritoryClient) DeleteOneID(id int) *SalesTerritoryDeleteOne {
	builder := c.Delete().Where(salesterritory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SalesTerritoryDeleteOne{builder}
}

// Query returns a query builder for SalesTerritory.
func (c *SalesTerritoryClient) Query() *SalesTerritoryQuery {
	return &SalesTerritoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSalesTerritory},
		inters: c.Interceptors(),
	}
}

// Get returns a SalesTerritory entity by its id.
func (c *SalesTerritoryClient) Get(ctx context.Context, id int) (*SalesTerritory, error) {
	return c.Query().Where(salesterritory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SalesTerritoryClient) GetX(ctx context.Context, id int) *SalesTerritory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SalesTerritoryClient) Hooks() []Hook {
	return c.hooks.SalesTerritory
}

// Interceptors returns the client interceptors.
func (c *SalesTerritoryClient) Interceptors() []Interceptor {
	return c.inters.SalesTerritory
}

func (c *SalesTerritoryClient) mutate(ctx context.Context, m *SalesTerritoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SalesTerritoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SalesTerritoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SalesTerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SalesTerritoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SalesTerritory mutation op: %q", m.Op())
	}
}

// SalesTitleClient is a client for the SalesTitle schema.
type SalesTitleClient struct {
	config
}

// NewSalesTitleClient returns a client for the SalesTitle from the given config.
func NewSalesTitleClient(c config) *SalesTitleClient {
	return &SalesTitleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `salestitle.Hooks(f(g(h())))`.
func (c *SalesTitleClient) Use(hooks ...Hook) {
	c.hooks.SalesTitle = append(c.hooks.SalesTitle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `salestitle.Intercept(f(g(h())))`.
func (c *SalesTitleClient) Intercept(interceptors ...Interceptor) {
	c.inters.SalesTitle = append(c.inters.SalesTitle, interceptors...)
}

// Create returns a builder for creating a SalesTitle entity.
func (c *SalesTitleClient) Create() *SalesTitleCreate {
	mutation := newSalesTitleMutation(c.config, OpCreate)
	return &SalesTitleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SalesTitle entities.
func (c *SalesTitleClient) CreateBulk(builders ...*SalesTitleCreate) *SalesTitleCreateBulk {
	return &SalesTitleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SalesTitleClient) MapCreateBulk(slice any, setFunc func(*SalesTitleCreate, int)) *SalesTitleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SalesTitleCreateBulk{err: fmt.Errorf("calling to SalesTitleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SalesTitleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SalesTitleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SalesTitle.
func (c *SalesTitleClient) Update() *SalesTitleUpdate {
	mutation := newSalesTitleMutation(c.config, OpUpdate)
	return &SalesTitleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SalesTitleClient) UpdateOne(st *SalesTitle) *SalesTitleUpdateOne {
	mutation := newSalesTitleMutation(c.config, OpUpdateOne, withSalesTitle(st))
	return &SalesTitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SalesTitleClient) UpdateOneID(id int) *SalesTitleUpdateOne {
	mutation := newSalesTitleMutation(c.config, OpUpdateOne, withSalesTitleID(id))
	return &SalesTitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SalesTitle.
func (c *SalesTitleClient) Delete() *SalesTitleDelete {
	mutation := newSalesTitleMutation(c.config, OpDelete)
	return &SalesTitleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SalesTitleClient) DeleteOne(st *SalesTitle) *SalesTitleDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SalesTitleClient) DeleteOneID(id int) *SalesTitleDeleteOne {
	builder := c.Delete().Where(salestitle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SalesTitleDeleteOne{builder}
}

// Query returns a query builder for SalesTitle.
func (c *SalesTitleClient) Query() *SalesTitleQuery {
	return &SalesTitleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSalesTitle},
		inters: c.Interceptors(),
	}
}

// Get returns a SalesTitle entity by its id.
func (c *SalesTitleClient) Get(ctx context.Context, id int) (*SalesTitle, error) {
	return c.Query().Where(salestitle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SalesTitleClient) GetX(ctx context.Context, id int) *SalesTitle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySales queries the sales edge of a SalesTitle.
func (c *SalesTitleClient) QuerySales(st *SalesTitle) *SalesTeamQuery {
	query := (&SalesTeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(salestitle.Table, salestitle.FieldID, id),
			sqlgraph.To(salesteam.Table, salesteam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, salestitle.SalesTable, salestitle.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SalesTitleClient) Hooks() []Hook {
	return c.hooks.SalesTitle
}

// Interceptors returns the client interceptors.
func (c *SalesTitleClient) Interceptors() []Interceptor {
	return c.inters.SalesTitle
}

func (c *SalesTitleClient) mutate(ctx context.Context, m *SalesTitleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SalesTitleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SalesTitleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SalesTitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SalesTitleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SalesTitle mutation op: %q", m.Op())
	}
}

// SampleClient is a client for the Sample schema.
type SampleClient struct {
	config
}

// NewSampleClient returns a client for the Sample from the given config.
func NewSampleClient(c config) *SampleClient {
	return &SampleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sample.Hooks(f(g(h())))`.
func (c *SampleClient) Use(hooks ...Hook) {
	c.hooks.Sample = append(c.hooks.Sample, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sample.Intercept(f(g(h())))`.
func (c *SampleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Sample = append(c.inters.Sample, interceptors...)
}

// Create returns a builder for creating a Sample entity.
func (c *SampleClient) Create() *SampleCreate {
	mutation := newSampleMutation(c.config, OpCreate)
	return &SampleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Sample entities.
func (c *SampleClient) CreateBulk(builders ...*SampleCreate) *SampleCreateBulk {
	return &SampleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SampleClient) MapCreateBulk(slice any, setFunc func(*SampleCreate, int)) *SampleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SampleCreateBulk{err: fmt.Errorf("calling to SampleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SampleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SampleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Sample.
func (c *SampleClient) Update() *SampleUpdate {
	mutation := newSampleMutation(c.config, OpUpdate)
	return &SampleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SampleClient) UpdateOne(s *Sample) *SampleUpdateOne {
	mutation := newSampleMutation(c.config, OpUpdateOne, withSample(s))
	return &SampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SampleClient) UpdateOneID(id int) *SampleUpdateOne {
	mutation := newSampleMutation(c.config, OpUpdateOne, withSampleID(id))
	return &SampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Sample.
func (c *SampleClient) Delete() *SampleDelete {
	mutation := newSampleMutation(c.config, OpDelete)
	return &SampleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SampleClient) DeleteOne(s *Sample) *SampleDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SampleClient) DeleteOneID(id int) *SampleDeleteOne {
	builder := c.Delete().Where(sample.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SampleDeleteOne{builder}
}

// Query returns a query builder for Sample.
func (c *SampleClient) Query() *SampleQuery {
	return &SampleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSample},
		inters: c.Interceptors(),
	}
}

// Get returns a Sample entity by its id.
func (c *SampleClient) Get(ctx context.Context, id int) (*Sample, error) {
	return c.Query().Where(sample.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SampleClient) GetX(ctx context.Context, id int) *Sample {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a Sample.
func (c *SampleClient) QueryOrder(s *Sample) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sample.OrderTable, sample.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTubes queries the tubes edge of a Sample.
func (c *SampleClient) QueryTubes(s *Sample) *TubeQuery {
	query := (&TubeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(tube.Table, tube.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sample.TubesTable, sample.TubesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySampleReceiveRecords queries the sample_receive_records edge of a Sample.
func (c *SampleClient) QuerySampleReceiveRecords(s *Sample) *TubeReceiveQuery {
	query := (&TubeReceiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(tubereceive.Table, tubereceive.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sample.SampleReceiveRecordsTable, sample.SampleReceiveRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySampleRequiredTubes queries the sample_required_tubes edge of a Sample.
func (c *SampleClient) QuerySampleRequiredTubes(s *Sample) *TubeRequirementQuery {
	query := (&TubeRequirementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(tuberequirement.Table, tuberequirement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sample.SampleRequiredTubesTable, sample.SampleRequiredTubesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatient queries the patient edge of a Sample.
func (c *SampleClient) QueryPatient(s *Sample) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sample.PatientTable, sample.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Sample.
func (c *SampleClient) QueryCustomer(s *Sample) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sample.Table, sample.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sample.CustomerTable, sample.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SampleClient) Hooks() []Hook {
	return c.hooks.Sample
}

// Interceptors returns the client interceptors.
func (c *SampleClient) Interceptors() []Interceptor {
	return c.inters.Sample
}

func (c *SampleClient) mutate(ctx context.Context, m *SampleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SampleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SampleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SampleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Sample mutation op: %q", m.Op())
	}
}

// SampleIDGenerateClient is a client for the SampleIDGenerate schema.
type SampleIDGenerateClient struct {
	config
}

// NewSampleIDGenerateClient returns a client for the SampleIDGenerate from the given config.
func NewSampleIDGenerateClient(c config) *SampleIDGenerateClient {
	return &SampleIDGenerateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sampleidgenerate.Hooks(f(g(h())))`.
func (c *SampleIDGenerateClient) Use(hooks ...Hook) {
	c.hooks.SampleIDGenerate = append(c.hooks.SampleIDGenerate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sampleidgenerate.Intercept(f(g(h())))`.
func (c *SampleIDGenerateClient) Intercept(interceptors ...Interceptor) {
	c.inters.SampleIDGenerate = append(c.inters.SampleIDGenerate, interceptors...)
}

// Create returns a builder for creating a SampleIDGenerate entity.
func (c *SampleIDGenerateClient) Create() *SampleIDGenerateCreate {
	mutation := newSampleIDGenerateMutation(c.config, OpCreate)
	return &SampleIDGenerateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SampleIDGenerate entities.
func (c *SampleIDGenerateClient) CreateBulk(builders ...*SampleIDGenerateCreate) *SampleIDGenerateCreateBulk {
	return &SampleIDGenerateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SampleIDGenerateClient) MapCreateBulk(slice any, setFunc func(*SampleIDGenerateCreate, int)) *SampleIDGenerateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SampleIDGenerateCreateBulk{err: fmt.Errorf("calling to SampleIDGenerateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SampleIDGenerateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SampleIDGenerateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SampleIDGenerate.
func (c *SampleIDGenerateClient) Update() *SampleIDGenerateUpdate {
	mutation := newSampleIDGenerateMutation(c.config, OpUpdate)
	return &SampleIDGenerateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SampleIDGenerateClient) UpdateOne(sig *SampleIDGenerate) *SampleIDGenerateUpdateOne {
	mutation := newSampleIDGenerateMutation(c.config, OpUpdateOne, withSampleIDGenerate(sig))
	return &SampleIDGenerateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SampleIDGenerateClient) UpdateOneID(id int) *SampleIDGenerateUpdateOne {
	mutation := newSampleIDGenerateMutation(c.config, OpUpdateOne, withSampleIDGenerateID(id))
	return &SampleIDGenerateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SampleIDGenerate.
func (c *SampleIDGenerateClient) Delete() *SampleIDGenerateDelete {
	mutation := newSampleIDGenerateMutation(c.config, OpDelete)
	return &SampleIDGenerateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SampleIDGenerateClient) DeleteOne(sig *SampleIDGenerate) *SampleIDGenerateDeleteOne {
	return c.DeleteOneID(sig.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SampleIDGenerateClient) DeleteOneID(id int) *SampleIDGenerateDeleteOne {
	builder := c.Delete().Where(sampleidgenerate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SampleIDGenerateDeleteOne{builder}
}

// Query returns a query builder for SampleIDGenerate.
func (c *SampleIDGenerateClient) Query() *SampleIDGenerateQuery {
	return &SampleIDGenerateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSampleIDGenerate},
		inters: c.Interceptors(),
	}
}

// Get returns a SampleIDGenerate entity by its id.
func (c *SampleIDGenerateClient) Get(ctx context.Context, id int) (*SampleIDGenerate, error) {
	return c.Query().Where(sampleidgenerate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SampleIDGenerateClient) GetX(ctx context.Context, id int) *SampleIDGenerate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SampleIDGenerateClient) Hooks() []Hook {
	return c.hooks.SampleIDGenerate
}

// Interceptors returns the client interceptors.
func (c *SampleIDGenerateClient) Interceptors() []Interceptor {
	return c.inters.SampleIDGenerate
}

func (c *SampleIDGenerateClient) mutate(ctx context.Context, m *SampleIDGenerateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SampleIDGenerateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SampleIDGenerateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SampleIDGenerateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SampleIDGenerateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SampleIDGenerate mutation op: %q", m.Op())
	}
}

// SampleTypeClient is a client for the SampleType schema.
type SampleTypeClient struct {
	config
}

// NewSampleTypeClient returns a client for the SampleType from the given config.
func NewSampleTypeClient(c config) *SampleTypeClient {
	return &SampleTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sampletype.Hooks(f(g(h())))`.
func (c *SampleTypeClient) Use(hooks ...Hook) {
	c.hooks.SampleType = append(c.hooks.SampleType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sampletype.Intercept(f(g(h())))`.
func (c *SampleTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.SampleType = append(c.inters.SampleType, interceptors...)
}

// Create returns a builder for creating a SampleType entity.
func (c *SampleTypeClient) Create() *SampleTypeCreate {
	mutation := newSampleTypeMutation(c.config, OpCreate)
	return &SampleTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SampleType entities.
func (c *SampleTypeClient) CreateBulk(builders ...*SampleTypeCreate) *SampleTypeCreateBulk {
	return &SampleTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SampleTypeClient) MapCreateBulk(slice any, setFunc func(*SampleTypeCreate, int)) *SampleTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SampleTypeCreateBulk{err: fmt.Errorf("calling to SampleTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SampleTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SampleTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SampleType.
func (c *SampleTypeClient) Update() *SampleTypeUpdate {
	mutation := newSampleTypeMutation(c.config, OpUpdate)
	return &SampleTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SampleTypeClient) UpdateOne(st *SampleType) *SampleTypeUpdateOne {
	mutation := newSampleTypeMutation(c.config, OpUpdateOne, withSampleType(st))
	return &SampleTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SampleTypeClient) UpdateOneID(id int) *SampleTypeUpdateOne {
	mutation := newSampleTypeMutation(c.config, OpUpdateOne, withSampleTypeID(id))
	return &SampleTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SampleType.
func (c *SampleTypeClient) Delete() *SampleTypeDelete {
	mutation := newSampleTypeMutation(c.config, OpDelete)
	return &SampleTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SampleTypeClient) DeleteOne(st *SampleType) *SampleTypeDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SampleTypeClient) DeleteOneID(id int) *SampleTypeDeleteOne {
	builder := c.Delete().Where(sampletype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SampleTypeDeleteOne{builder}
}

// Query returns a query builder for SampleType.
func (c *SampleTypeClient) Query() *SampleTypeQuery {
	return &SampleTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSampleType},
		inters: c.Interceptors(),
	}
}

// Get returns a SampleType entity by its id.
func (c *SampleTypeClient) Get(ctx context.Context, id int) (*SampleType, error) {
	return c.Query().Where(sampletype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SampleTypeClient) GetX(ctx context.Context, id int) *SampleType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTubeTypes queries the tube_types edge of a SampleType.
func (c *SampleTypeClient) QueryTubeTypes(st *SampleType) *TubeTypeQuery {
	query := (&TubeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sampletype.Table, sampletype.FieldID, id),
			sqlgraph.To(tubetype.Table, tubetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, sampletype.TubeTypesTable, sampletype.TubeTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a SampleType.
func (c *SampleTypeClient) QueryTests(st *SampleType) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sampletype.Table, sampletype.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, sampletype.TestsTable, sampletype.TestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SampleTypeClient) Hooks() []Hook {
	return c.hooks.SampleType
}

// Interceptors returns the client interceptors.
func (c *SampleTypeClient) Interceptors() []Interceptor {
	return c.inters.SampleType
}

func (c *SampleTypeClient) mutate(ctx context.Context, m *SampleTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SampleTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SampleTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SampleTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SampleTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SampleType mutation op: %q", m.Op())
	}
}

// ServiceshipClient is a client for the Serviceship schema.
type ServiceshipClient struct {
	config
}

// NewServiceshipClient returns a client for the Serviceship from the given config.
func NewServiceshipClient(c config) *ServiceshipClient {
	return &ServiceshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceship.Hooks(f(g(h())))`.
func (c *ServiceshipClient) Use(hooks ...Hook) {
	c.hooks.Serviceship = append(c.hooks.Serviceship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceship.Intercept(f(g(h())))`.
func (c *ServiceshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.Serviceship = append(c.inters.Serviceship, interceptors...)
}

// Create returns a builder for creating a Serviceship entity.
func (c *ServiceshipClient) Create() *ServiceshipCreate {
	mutation := newServiceshipMutation(c.config, OpCreate)
	return &ServiceshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Serviceship entities.
func (c *ServiceshipClient) CreateBulk(builders ...*ServiceshipCreate) *ServiceshipCreateBulk {
	return &ServiceshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceshipClient) MapCreateBulk(slice any, setFunc func(*ServiceshipCreate, int)) *ServiceshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceshipCreateBulk{err: fmt.Errorf("calling to ServiceshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Serviceship.
func (c *ServiceshipClient) Update() *ServiceshipUpdate {
	mutation := newServiceshipMutation(c.config, OpUpdate)
	return &ServiceshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceshipClient) UpdateOne(s *Serviceship) *ServiceshipUpdateOne {
	mutation := newServiceshipMutation(c.config, OpUpdateOne, withServiceship(s))
	return &ServiceshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceshipClient) UpdateOneID(id int) *ServiceshipUpdateOne {
	mutation := newServiceshipMutation(c.config, OpUpdateOne, withServiceshipID(id))
	return &ServiceshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Serviceship.
func (c *ServiceshipClient) Delete() *ServiceshipDelete {
	mutation := newServiceshipMutation(c.config, OpDelete)
	return &ServiceshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceshipClient) DeleteOne(s *Serviceship) *ServiceshipDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceshipClient) DeleteOneID(id int) *ServiceshipDeleteOne {
	builder := c.Delete().Where(serviceship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceshipDeleteOne{builder}
}

// Query returns a query builder for Serviceship.
func (c *ServiceshipClient) Query() *ServiceshipQuery {
	return &ServiceshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceship},
		inters: c.Interceptors(),
	}
}

// Get returns a Serviceship entity by its id.
func (c *ServiceshipClient) Get(ctx context.Context, id int) (*Serviceship, error) {
	return c.Query().Where(serviceship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceshipClient) GetX(ctx context.Context, id int) *Serviceship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServiceshipBillingPlan queries the serviceship_billing_plan edge of a Serviceship.
func (c *ServiceshipClient) QueryServiceshipBillingPlan(s *Serviceship) *ServiceshipBillingPlanQuery {
	query := (&ServiceshipBillingPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceship.Table, serviceship.FieldID, id),
			sqlgraph.To(serviceshipbillingplan.Table, serviceshipbillingplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceship.ServiceshipBillingPlanTable, serviceship.ServiceshipBillingPlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountSubscription queries the account_subscription edge of a Serviceship.
func (c *ServiceshipClient) QueryAccountSubscription(s *Serviceship) *AccountSubscriptionQuery {
	query := (&AccountSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceship.Table, serviceship.FieldID, id),
			sqlgraph.To(accountsubscription.Table, accountsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceship.AccountSubscriptionTable, serviceship.AccountSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceshipClient) Hooks() []Hook {
	return c.hooks.Serviceship
}

// Interceptors returns the client interceptors.
func (c *ServiceshipClient) Interceptors() []Interceptor {
	return c.inters.Serviceship
}

func (c *ServiceshipClient) mutate(ctx context.Context, m *ServiceshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Serviceship mutation op: %q", m.Op())
	}
}

// ServiceshipBillingPlanClient is a client for the ServiceshipBillingPlan schema.
type ServiceshipBillingPlanClient struct {
	config
}

// NewServiceshipBillingPlanClient returns a client for the ServiceshipBillingPlan from the given config.
func NewServiceshipBillingPlanClient(c config) *ServiceshipBillingPlanClient {
	return &ServiceshipBillingPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceshipbillingplan.Hooks(f(g(h())))`.
func (c *ServiceshipBillingPlanClient) Use(hooks ...Hook) {
	c.hooks.ServiceshipBillingPlan = append(c.hooks.ServiceshipBillingPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceshipbillingplan.Intercept(f(g(h())))`.
func (c *ServiceshipBillingPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceshipBillingPlan = append(c.inters.ServiceshipBillingPlan, interceptors...)
}

// Create returns a builder for creating a ServiceshipBillingPlan entity.
func (c *ServiceshipBillingPlanClient) Create() *ServiceshipBillingPlanCreate {
	mutation := newServiceshipBillingPlanMutation(c.config, OpCreate)
	return &ServiceshipBillingPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceshipBillingPlan entities.
func (c *ServiceshipBillingPlanClient) CreateBulk(builders ...*ServiceshipBillingPlanCreate) *ServiceshipBillingPlanCreateBulk {
	return &ServiceshipBillingPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceshipBillingPlanClient) MapCreateBulk(slice any, setFunc func(*ServiceshipBillingPlanCreate, int)) *ServiceshipBillingPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceshipBillingPlanCreateBulk{err: fmt.Errorf("calling to ServiceshipBillingPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceshipBillingPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceshipBillingPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceshipBillingPlan.
func (c *ServiceshipBillingPlanClient) Update() *ServiceshipBillingPlanUpdate {
	mutation := newServiceshipBillingPlanMutation(c.config, OpUpdate)
	return &ServiceshipBillingPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceshipBillingPlanClient) UpdateOne(sbp *ServiceshipBillingPlan) *ServiceshipBillingPlanUpdateOne {
	mutation := newServiceshipBillingPlanMutation(c.config, OpUpdateOne, withServiceshipBillingPlan(sbp))
	return &ServiceshipBillingPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceshipBillingPlanClient) UpdateOneID(id int) *ServiceshipBillingPlanUpdateOne {
	mutation := newServiceshipBillingPlanMutation(c.config, OpUpdateOne, withServiceshipBillingPlanID(id))
	return &ServiceshipBillingPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceshipBillingPlan.
func (c *ServiceshipBillingPlanClient) Delete() *ServiceshipBillingPlanDelete {
	mutation := newServiceshipBillingPlanMutation(c.config, OpDelete)
	return &ServiceshipBillingPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceshipBillingPlanClient) DeleteOne(sbp *ServiceshipBillingPlan) *ServiceshipBillingPlanDeleteOne {
	return c.DeleteOneID(sbp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceshipBillingPlanClient) DeleteOneID(id int) *ServiceshipBillingPlanDeleteOne {
	builder := c.Delete().Where(serviceshipbillingplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceshipBillingPlanDeleteOne{builder}
}

// Query returns a query builder for ServiceshipBillingPlan.
func (c *ServiceshipBillingPlanClient) Query() *ServiceshipBillingPlanQuery {
	return &ServiceshipBillingPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceshipBillingPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceshipBillingPlan entity by its id.
func (c *ServiceshipBillingPlanClient) Get(ctx context.Context, id int) (*ServiceshipBillingPlan, error) {
	return c.Query().Where(serviceshipbillingplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceshipBillingPlanClient) GetX(ctx context.Context, id int) *ServiceshipBillingPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccountSubscription queries the account_subscription edge of a ServiceshipBillingPlan.
func (c *ServiceshipBillingPlanClient) QueryAccountSubscription(sbp *ServiceshipBillingPlan) *AccountSubscriptionQuery {
	query := (&AccountSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sbp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceshipbillingplan.Table, serviceshipbillingplan.FieldID, id),
			sqlgraph.To(accountsubscription.Table, accountsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceshipbillingplan.AccountSubscriptionTable, serviceshipbillingplan.AccountSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(sbp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceship queries the serviceship edge of a ServiceshipBillingPlan.
func (c *ServiceshipBillingPlanClient) QueryServiceship(sbp *ServiceshipBillingPlan) *ServiceshipQuery {
	query := (&ServiceshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sbp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceshipbillingplan.Table, serviceshipbillingplan.FieldID, id),
			sqlgraph.To(serviceship.Table, serviceship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, serviceshipbillingplan.ServiceshipTable, serviceshipbillingplan.ServiceshipColumn),
		)
		fromV = sqlgraph.Neighbors(sbp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceshipBillingPlanClient) Hooks() []Hook {
	return c.hooks.ServiceshipBillingPlan
}

// Interceptors returns the client interceptors.
func (c *ServiceshipBillingPlanClient) Interceptors() []Interceptor {
	return c.inters.ServiceshipBillingPlan
}

func (c *ServiceshipBillingPlanClient) mutate(ctx context.Context, m *ServiceshipBillingPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceshipBillingPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceshipBillingPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceshipBillingPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceshipBillingPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceshipBillingPlan mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id int) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id int) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id int) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id int) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClinics queries the clinics edge of a Setting.
func (c *SettingClient) QueryClinics(s *Setting) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setting.Table, setting.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, setting.ClinicsTable, setting.ClinicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUsers queries the internal_users edge of a Setting.
func (c *SettingClient) QueryInternalUsers(s *Setting) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setting.Table, setting.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, setting.InternalUsersTable, setting.InternalUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatients queries the patients edge of a Setting.
func (c *SettingClient) QueryPatients(s *Setting) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setting.Table, setting.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, setting.PatientsTable, setting.PatientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClinicCustomers queries the clinic_customers edge of a Setting.
func (c *SettingClient) QueryClinicCustomers(s *Setting) *CustomerSettingOnClinicsQuery {
	query := (&CustomerSettingOnClinicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setting.Table, setting.FieldID, id),
			sqlgraph.To(customersettingonclinics.Table, customersettingonclinics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, setting.ClinicCustomersTable, setting.ClinicCustomersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// TestClient is a client for the Test schema.
type TestClient struct {
	config
}

// NewTestClient returns a client for the Test from the given config.
func NewTestClient(c config) *TestClient {
	return &TestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `test.Hooks(f(g(h())))`.
func (c *TestClient) Use(hooks ...Hook) {
	c.hooks.Test = append(c.hooks.Test, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `test.Intercept(f(g(h())))`.
func (c *TestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Test = append(c.inters.Test, interceptors...)
}

// Create returns a builder for creating a Test entity.
func (c *TestClient) Create() *TestCreate {
	mutation := newTestMutation(c.config, OpCreate)
	return &TestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Test entities.
func (c *TestClient) CreateBulk(builders ...*TestCreate) *TestCreateBulk {
	return &TestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestClient) MapCreateBulk(slice any, setFunc func(*TestCreate, int)) *TestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestCreateBulk{err: fmt.Errorf("calling to TestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Test.
func (c *TestClient) Update() *TestUpdate {
	mutation := newTestMutation(c.config, OpUpdate)
	return &TestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestClient) UpdateOne(t *Test) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTest(t))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestClient) UpdateOneID(id int) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTestID(id))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Test.
func (c *TestClient) Delete() *TestDelete {
	mutation := newTestMutation(c.config, OpDelete)
	return &TestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestClient) DeleteOne(t *Test) *TestDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestClient) DeleteOneID(id int) *TestDeleteOne {
	builder := c.Delete().Where(test.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDeleteOne{builder}
}

// Query returns a query builder for Test.
func (c *TestClient) Query() *TestQuery {
	return &TestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTest},
		inters: c.Interceptors(),
	}
}

// Get returns a Test entity by its id.
func (c *TestClient) Get(ctx context.Context, id int) (*Test, error) {
	return c.Query().Where(test.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestClient) GetX(ctx context.Context, id int) *Test {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTestDetails queries the test_details edge of a Test.
func (c *TestClient) QueryTestDetails(t *Test) *TestDetailQuery {
	query := (&TestDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testdetail.Table, testdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, test.TestDetailsTable, test.TestDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderInfo queries the order_info edge of a Test.
func (c *TestClient) QueryOrderInfo(t *Test) *OrderInfoQuery {
	query := (&OrderInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(orderinfo.Table, orderinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, test.OrderInfoTable, test.OrderInfoPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySampleTypes queries the sample_types edge of a Test.
func (c *TestClient) QuerySampleTypes(t *Test) *SampleTypeQuery {
	query := (&SampleTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(sampletype.Table, sampletype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, test.SampleTypesTable, test.SampleTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTubeTypes queries the tube_types edge of a Test.
func (c *TestClient) QueryTubeTypes(t *Test) *TubeTypeQuery {
	query := (&TubeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(tubetype.Table, tubetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, test.TubeTypesTable, test.TubeTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestClient) Hooks() []Hook {
	return c.hooks.Test
}

// Interceptors returns the client interceptors.
func (c *TestClient) Interceptors() []Interceptor {
	return c.inters.Test
}

func (c *TestClient) mutate(ctx context.Context, m *TestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Test mutation op: %q", m.Op())
	}
}

// TestDetailClient is a client for the TestDetail schema.
type TestDetailClient struct {
	config
}

// NewTestDetailClient returns a client for the TestDetail from the given config.
func NewTestDetailClient(c config) *TestDetailClient {
	return &TestDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testdetail.Hooks(f(g(h())))`.
func (c *TestDetailClient) Use(hooks ...Hook) {
	c.hooks.TestDetail = append(c.hooks.TestDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testdetail.Intercept(f(g(h())))`.
func (c *TestDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestDetail = append(c.inters.TestDetail, interceptors...)
}

// Create returns a builder for creating a TestDetail entity.
func (c *TestDetailClient) Create() *TestDetailCreate {
	mutation := newTestDetailMutation(c.config, OpCreate)
	return &TestDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestDetail entities.
func (c *TestDetailClient) CreateBulk(builders ...*TestDetailCreate) *TestDetailCreateBulk {
	return &TestDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestDetailClient) MapCreateBulk(slice any, setFunc func(*TestDetailCreate, int)) *TestDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestDetailCreateBulk{err: fmt.Errorf("calling to TestDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestDetail.
func (c *TestDetailClient) Update() *TestDetailUpdate {
	mutation := newTestDetailMutation(c.config, OpUpdate)
	return &TestDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestDetailClient) UpdateOne(td *TestDetail) *TestDetailUpdateOne {
	mutation := newTestDetailMutation(c.config, OpUpdateOne, withTestDetail(td))
	return &TestDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestDetailClient) UpdateOneID(id int) *TestDetailUpdateOne {
	mutation := newTestDetailMutation(c.config, OpUpdateOne, withTestDetailID(id))
	return &TestDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestDetail.
func (c *TestDetailClient) Delete() *TestDetailDelete {
	mutation := newTestDetailMutation(c.config, OpDelete)
	return &TestDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestDetailClient) DeleteOne(td *TestDetail) *TestDetailDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestDetailClient) DeleteOneID(id int) *TestDetailDeleteOne {
	builder := c.Delete().Where(testdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDetailDeleteOne{builder}
}

// Query returns a query builder for TestDetail.
func (c *TestDetailClient) Query() *TestDetailQuery {
	return &TestDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a TestDetail entity by its id.
func (c *TestDetailClient) Get(ctx context.Context, id int) (*TestDetail, error) {
	return c.Query().Where(testdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestDetailClient) GetX(ctx context.Context, id int) *TestDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestDetail.
func (c *TestDetailClient) QueryTest(td *TestDetail) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testdetail.Table, testdetail.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testdetail.TestTable, testdetail.TestColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestDetailClient) Hooks() []Hook {
	return c.hooks.TestDetail
}

// Interceptors returns the client interceptors.
func (c *TestDetailClient) Interceptors() []Interceptor {
	return c.inters.TestDetail
}

func (c *TestDetailClient) mutate(ctx context.Context, m *TestDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestDetail mutation op: %q", m.Op())
	}
}

// TestListClient is a client for the TestList schema.
type TestListClient struct {
	config
}

// NewTestListClient returns a client for the TestList from the given config.
func NewTestListClient(c config) *TestListClient {
	return &TestListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testlist.Hooks(f(g(h())))`.
func (c *TestListClient) Use(hooks ...Hook) {
	c.hooks.TestList = append(c.hooks.TestList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testlist.Intercept(f(g(h())))`.
func (c *TestListClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestList = append(c.inters.TestList, interceptors...)
}

// Create returns a builder for creating a TestList entity.
func (c *TestListClient) Create() *TestListCreate {
	mutation := newTestListMutation(c.config, OpCreate)
	return &TestListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestList entities.
func (c *TestListClient) CreateBulk(builders ...*TestListCreate) *TestListCreateBulk {
	return &TestListCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestListClient) MapCreateBulk(slice any, setFunc func(*TestListCreate, int)) *TestListCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestListCreateBulk{err: fmt.Errorf("calling to TestListClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestListCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestList.
func (c *TestListClient) Update() *TestListUpdate {
	mutation := newTestListMutation(c.config, OpUpdate)
	return &TestListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestListClient) UpdateOne(tl *TestList) *TestListUpdateOne {
	mutation := newTestListMutation(c.config, OpUpdateOne, withTestList(tl))
	return &TestListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestListClient) UpdateOneID(id int) *TestListUpdateOne {
	mutation := newTestListMutation(c.config, OpUpdateOne, withTestListID(id))
	return &TestListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestList.
func (c *TestListClient) Delete() *TestListDelete {
	mutation := newTestListMutation(c.config, OpDelete)
	return &TestListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestListClient) DeleteOne(tl *TestList) *TestListDeleteOne {
	return c.DeleteOneID(tl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestListClient) DeleteOneID(id int) *TestListDeleteOne {
	builder := c.Delete().Where(testlist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestListDeleteOne{builder}
}

// Query returns a query builder for TestList.
func (c *TestListClient) Query() *TestListQuery {
	return &TestListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestList},
		inters: c.Interceptors(),
	}
}

// Get returns a TestList entity by its id.
func (c *TestListClient) Get(ctx context.Context, id int) (*TestList, error) {
	return c.Query().Where(testlist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestListClient) GetX(ctx context.Context, id int) *TestList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TestListClient) Hooks() []Hook {
	return c.hooks.TestList
}

// Interceptors returns the client interceptors.
func (c *TestListClient) Interceptors() []Interceptor {
	return c.inters.TestList
}

func (c *TestListClient) mutate(ctx context.Context, m *TestListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestList mutation op: %q", m.Op())
	}
}

// TubeClient is a client for the Tube schema.
type TubeClient struct {
	config
}

// NewTubeClient returns a client for the Tube from the given config.
func NewTubeClient(c config) *TubeClient {
	return &TubeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tube.Hooks(f(g(h())))`.
func (c *TubeClient) Use(hooks ...Hook) {
	c.hooks.Tube = append(c.hooks.Tube, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tube.Intercept(f(g(h())))`.
func (c *TubeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tube = append(c.inters.Tube, interceptors...)
}

// Create returns a builder for creating a Tube entity.
func (c *TubeClient) Create() *TubeCreate {
	mutation := newTubeMutation(c.config, OpCreate)
	return &TubeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tube entities.
func (c *TubeClient) CreateBulk(builders ...*TubeCreate) *TubeCreateBulk {
	return &TubeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TubeClient) MapCreateBulk(slice any, setFunc func(*TubeCreate, int)) *TubeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TubeCreateBulk{err: fmt.Errorf("calling to TubeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TubeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TubeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tube.
func (c *TubeClient) Update() *TubeUpdate {
	mutation := newTubeMutation(c.config, OpUpdate)
	return &TubeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TubeClient) UpdateOne(t *Tube) *TubeUpdateOne {
	mutation := newTubeMutation(c.config, OpUpdateOne, withTube(t))
	return &TubeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TubeClient) UpdateOneID(id int) *TubeUpdateOne {
	mutation := newTubeMutation(c.config, OpUpdateOne, withTubeID(id))
	return &TubeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tube.
func (c *TubeClient) Delete() *TubeDelete {
	mutation := newTubeMutation(c.config, OpDelete)
	return &TubeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TubeClient) DeleteOne(t *Tube) *TubeDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TubeClient) DeleteOneID(id int) *TubeDeleteOne {
	builder := c.Delete().Where(tube.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TubeDeleteOne{builder}
}

// Query returns a query builder for Tube.
func (c *TubeClient) Query() *TubeQuery {
	return &TubeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTube},
		inters: c.Interceptors(),
	}
}

// Get returns a Tube entity by its id.
func (c *TubeClient) Get(ctx context.Context, id int) (*Tube, error) {
	return c.Query().Where(tube.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TubeClient) GetX(ctx context.Context, id int) *Tube {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTubeType queries the tube_type edge of a Tube.
func (c *TubeClient) QueryTubeType(t *Tube) *TubeTypeQuery {
	query := (&TubeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tube.Table, tube.FieldID, id),
			sqlgraph.To(tubetype.Table, tubetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tube.TubeTypeTable, tube.TubeTypePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySample queries the sample edge of a Tube.
func (c *TubeClient) QuerySample(t *Tube) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tube.Table, tube.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tube.SampleTable, tube.SampleColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TubeClient) Hooks() []Hook {
	return c.hooks.Tube
}

// Interceptors returns the client interceptors.
func (c *TubeClient) Interceptors() []Interceptor {
	return c.inters.Tube
}

func (c *TubeClient) mutate(ctx context.Context, m *TubeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TubeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TubeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TubeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TubeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tube mutation op: %q", m.Op())
	}
}

// TubeInstructionsClient is a client for the TubeInstructions schema.
type TubeInstructionsClient struct {
	config
}

// NewTubeInstructionsClient returns a client for the TubeInstructions from the given config.
func NewTubeInstructionsClient(c config) *TubeInstructionsClient {
	return &TubeInstructionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tubeinstructions.Hooks(f(g(h())))`.
func (c *TubeInstructionsClient) Use(hooks ...Hook) {
	c.hooks.TubeInstructions = append(c.hooks.TubeInstructions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tubeinstructions.Intercept(f(g(h())))`.
func (c *TubeInstructionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TubeInstructions = append(c.inters.TubeInstructions, interceptors...)
}

// Create returns a builder for creating a TubeInstructions entity.
func (c *TubeInstructionsClient) Create() *TubeInstructionsCreate {
	mutation := newTubeInstructionsMutation(c.config, OpCreate)
	return &TubeInstructionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TubeInstructions entities.
func (c *TubeInstructionsClient) CreateBulk(builders ...*TubeInstructionsCreate) *TubeInstructionsCreateBulk {
	return &TubeInstructionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TubeInstructionsClient) MapCreateBulk(slice any, setFunc func(*TubeInstructionsCreate, int)) *TubeInstructionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TubeInstructionsCreateBulk{err: fmt.Errorf("calling to TubeInstructionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TubeInstructionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TubeInstructionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TubeInstructions.
func (c *TubeInstructionsClient) Update() *TubeInstructionsUpdate {
	mutation := newTubeInstructionsMutation(c.config, OpUpdate)
	return &TubeInstructionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TubeInstructionsClient) UpdateOne(ti *TubeInstructions) *TubeInstructionsUpdateOne {
	mutation := newTubeInstructionsMutation(c.config, OpUpdateOne, withTubeInstructions(ti))
	return &TubeInstructionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TubeInstructionsClient) UpdateOneID(id int) *TubeInstructionsUpdateOne {
	mutation := newTubeInstructionsMutation(c.config, OpUpdateOne, withTubeInstructionsID(id))
	return &TubeInstructionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TubeInstructions.
func (c *TubeInstructionsClient) Delete() *TubeInstructionsDelete {
	mutation := newTubeInstructionsMutation(c.config, OpDelete)
	return &TubeInstructionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TubeInstructionsClient) DeleteOne(ti *TubeInstructions) *TubeInstructionsDeleteOne {
	return c.DeleteOneID(ti.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TubeInstructionsClient) DeleteOneID(id int) *TubeInstructionsDeleteOne {
	builder := c.Delete().Where(tubeinstructions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TubeInstructionsDeleteOne{builder}
}

// Query returns a query builder for TubeInstructions.
func (c *TubeInstructionsClient) Query() *TubeInstructionsQuery {
	return &TubeInstructionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTubeInstructions},
		inters: c.Interceptors(),
	}
}

// Get returns a TubeInstructions entity by its id.
func (c *TubeInstructionsClient) Get(ctx context.Context, id int) (*TubeInstructions, error) {
	return c.Query().Where(tubeinstructions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TubeInstructionsClient) GetX(ctx context.Context, id int) *TubeInstructions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TubeInstructionsClient) Hooks() []Hook {
	return c.hooks.TubeInstructions
}

// Interceptors returns the client interceptors.
func (c *TubeInstructionsClient) Interceptors() []Interceptor {
	return c.inters.TubeInstructions
}

func (c *TubeInstructionsClient) mutate(ctx context.Context, m *TubeInstructionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TubeInstructionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TubeInstructionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TubeInstructionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TubeInstructionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TubeInstructions mutation op: %q", m.Op())
	}
}

// TubeReceiveClient is a client for the TubeReceive schema.
type TubeReceiveClient struct {
	config
}

// NewTubeReceiveClient returns a client for the TubeReceive from the given config.
func NewTubeReceiveClient(c config) *TubeReceiveClient {
	return &TubeReceiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tubereceive.Hooks(f(g(h())))`.
func (c *TubeReceiveClient) Use(hooks ...Hook) {
	c.hooks.TubeReceive = append(c.hooks.TubeReceive, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tubereceive.Intercept(f(g(h())))`.
func (c *TubeReceiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.TubeReceive = append(c.inters.TubeReceive, interceptors...)
}

// Create returns a builder for creating a TubeReceive entity.
func (c *TubeReceiveClient) Create() *TubeReceiveCreate {
	mutation := newTubeReceiveMutation(c.config, OpCreate)
	return &TubeReceiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TubeReceive entities.
func (c *TubeReceiveClient) CreateBulk(builders ...*TubeReceiveCreate) *TubeReceiveCreateBulk {
	return &TubeReceiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TubeReceiveClient) MapCreateBulk(slice any, setFunc func(*TubeReceiveCreate, int)) *TubeReceiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TubeReceiveCreateBulk{err: fmt.Errorf("calling to TubeReceiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TubeReceiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TubeReceiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TubeReceive.
func (c *TubeReceiveClient) Update() *TubeReceiveUpdate {
	mutation := newTubeReceiveMutation(c.config, OpUpdate)
	return &TubeReceiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TubeReceiveClient) UpdateOne(tr *TubeReceive) *TubeReceiveUpdateOne {
	mutation := newTubeReceiveMutation(c.config, OpUpdateOne, withTubeReceive(tr))
	return &TubeReceiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TubeReceiveClient) UpdateOneID(id int) *TubeReceiveUpdateOne {
	mutation := newTubeReceiveMutation(c.config, OpUpdateOne, withTubeReceiveID(id))
	return &TubeReceiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TubeReceive.
func (c *TubeReceiveClient) Delete() *TubeReceiveDelete {
	mutation := newTubeReceiveMutation(c.config, OpDelete)
	return &TubeReceiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TubeReceiveClient) DeleteOne(tr *TubeReceive) *TubeReceiveDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TubeReceiveClient) DeleteOneID(id int) *TubeReceiveDeleteOne {
	builder := c.Delete().Where(tubereceive.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TubeReceiveDeleteOne{builder}
}

// Query returns a query builder for TubeReceive.
func (c *TubeReceiveClient) Query() *TubeReceiveQuery {
	return &TubeReceiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTubeReceive},
		inters: c.Interceptors(),
	}
}

// Get returns a TubeReceive entity by its id.
func (c *TubeReceiveClient) Get(ctx context.Context, id int) (*TubeReceive, error) {
	return c.Query().Where(tubereceive.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TubeReceiveClient) GetX(ctx context.Context, id int) *TubeReceive {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySample queries the sample edge of a TubeReceive.
func (c *TubeReceiveClient) QuerySample(tr *TubeReceive) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tubereceive.Table, tubereceive.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tubereceive.SampleTable, tubereceive.SampleColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TubeReceiveClient) Hooks() []Hook {
	return c.hooks.TubeReceive
}

// Interceptors returns the client interceptors.
func (c *TubeReceiveClient) Interceptors() []Interceptor {
	return c.inters.TubeReceive
}

func (c *TubeReceiveClient) mutate(ctx context.Context, m *TubeReceiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TubeReceiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TubeReceiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TubeReceiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TubeReceiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TubeReceive mutation op: %q", m.Op())
	}
}

// TubeRequirementClient is a client for the TubeRequirement schema.
type TubeRequirementClient struct {
	config
}

// NewTubeRequirementClient returns a client for the TubeRequirement from the given config.
func NewTubeRequirementClient(c config) *TubeRequirementClient {
	return &TubeRequirementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tuberequirement.Hooks(f(g(h())))`.
func (c *TubeRequirementClient) Use(hooks ...Hook) {
	c.hooks.TubeRequirement = append(c.hooks.TubeRequirement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tuberequirement.Intercept(f(g(h())))`.
func (c *TubeRequirementClient) Intercept(interceptors ...Interceptor) {
	c.inters.TubeRequirement = append(c.inters.TubeRequirement, interceptors...)
}

// Create returns a builder for creating a TubeRequirement entity.
func (c *TubeRequirementClient) Create() *TubeRequirementCreate {
	mutation := newTubeRequirementMutation(c.config, OpCreate)
	return &TubeRequirementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TubeRequirement entities.
func (c *TubeRequirementClient) CreateBulk(builders ...*TubeRequirementCreate) *TubeRequirementCreateBulk {
	return &TubeRequirementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TubeRequirementClient) MapCreateBulk(slice any, setFunc func(*TubeRequirementCreate, int)) *TubeRequirementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TubeRequirementCreateBulk{err: fmt.Errorf("calling to TubeRequirementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TubeRequirementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TubeRequirementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TubeRequirement.
func (c *TubeRequirementClient) Update() *TubeRequirementUpdate {
	mutation := newTubeRequirementMutation(c.config, OpUpdate)
	return &TubeRequirementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TubeRequirementClient) UpdateOne(tr *TubeRequirement) *TubeRequirementUpdateOne {
	mutation := newTubeRequirementMutation(c.config, OpUpdateOne, withTubeRequirement(tr))
	return &TubeRequirementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TubeRequirementClient) UpdateOneID(id int) *TubeRequirementUpdateOne {
	mutation := newTubeRequirementMutation(c.config, OpUpdateOne, withTubeRequirementID(id))
	return &TubeRequirementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TubeRequirement.
func (c *TubeRequirementClient) Delete() *TubeRequirementDelete {
	mutation := newTubeRequirementMutation(c.config, OpDelete)
	return &TubeRequirementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TubeRequirementClient) DeleteOne(tr *TubeRequirement) *TubeRequirementDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TubeRequirementClient) DeleteOneID(id int) *TubeRequirementDeleteOne {
	builder := c.Delete().Where(tuberequirement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TubeRequirementDeleteOne{builder}
}

// Query returns a query builder for TubeRequirement.
func (c *TubeRequirementClient) Query() *TubeRequirementQuery {
	return &TubeRequirementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTubeRequirement},
		inters: c.Interceptors(),
	}
}

// Get returns a TubeRequirement entity by its id.
func (c *TubeRequirementClient) Get(ctx context.Context, id int) (*TubeRequirement, error) {
	return c.Query().Where(tuberequirement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TubeRequirementClient) GetX(ctx context.Context, id int) *TubeRequirement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySample queries the sample edge of a TubeRequirement.
func (c *TubeRequirementClient) QuerySample(tr *TubeRequirement) *SampleQuery {
	query := (&SampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tuberequirement.Table, tuberequirement.FieldID, id),
			sqlgraph.To(sample.Table, sample.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tuberequirement.SampleTable, tuberequirement.SampleColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TubeRequirementClient) Hooks() []Hook {
	return c.hooks.TubeRequirement
}

// Interceptors returns the client interceptors.
func (c *TubeRequirementClient) Interceptors() []Interceptor {
	return c.inters.TubeRequirement
}

func (c *TubeRequirementClient) mutate(ctx context.Context, m *TubeRequirementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TubeRequirementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TubeRequirementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TubeRequirementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TubeRequirementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TubeRequirement mutation op: %q", m.Op())
	}
}

// TubeTypeClient is a client for the TubeType schema.
type TubeTypeClient struct {
	config
}

// NewTubeTypeClient returns a client for the TubeType from the given config.
func NewTubeTypeClient(c config) *TubeTypeClient {
	return &TubeTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tubetype.Hooks(f(g(h())))`.
func (c *TubeTypeClient) Use(hooks ...Hook) {
	c.hooks.TubeType = append(c.hooks.TubeType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tubetype.Intercept(f(g(h())))`.
func (c *TubeTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.TubeType = append(c.inters.TubeType, interceptors...)
}

// Create returns a builder for creating a TubeType entity.
func (c *TubeTypeClient) Create() *TubeTypeCreate {
	mutation := newTubeTypeMutation(c.config, OpCreate)
	return &TubeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TubeType entities.
func (c *TubeTypeClient) CreateBulk(builders ...*TubeTypeCreate) *TubeTypeCreateBulk {
	return &TubeTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TubeTypeClient) MapCreateBulk(slice any, setFunc func(*TubeTypeCreate, int)) *TubeTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TubeTypeCreateBulk{err: fmt.Errorf("calling to TubeTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TubeTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TubeTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TubeType.
func (c *TubeTypeClient) Update() *TubeTypeUpdate {
	mutation := newTubeTypeMutation(c.config, OpUpdate)
	return &TubeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TubeTypeClient) UpdateOne(tt *TubeType) *TubeTypeUpdateOne {
	mutation := newTubeTypeMutation(c.config, OpUpdateOne, withTubeType(tt))
	return &TubeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TubeTypeClient) UpdateOneID(id int) *TubeTypeUpdateOne {
	mutation := newTubeTypeMutation(c.config, OpUpdateOne, withTubeTypeID(id))
	return &TubeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TubeType.
func (c *TubeTypeClient) Delete() *TubeTypeDelete {
	mutation := newTubeTypeMutation(c.config, OpDelete)
	return &TubeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TubeTypeClient) DeleteOne(tt *TubeType) *TubeTypeDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TubeTypeClient) DeleteOneID(id int) *TubeTypeDeleteOne {
	builder := c.Delete().Where(tubetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TubeTypeDeleteOne{builder}
}

// Query returns a query builder for TubeType.
func (c *TubeTypeClient) Query() *TubeTypeQuery {
	return &TubeTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTubeType},
		inters: c.Interceptors(),
	}
}

// Get returns a TubeType entity by its id.
func (c *TubeTypeClient) Get(ctx context.Context, id int) (*TubeType, error) {
	return c.Query().Where(tubetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TubeTypeClient) GetX(ctx context.Context, id int) *TubeType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTube queries the tube edge of a TubeType.
func (c *TubeTypeClient) QueryTube(tt *TubeType) *TubeQuery {
	query := (&TubeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tubetype.Table, tubetype.FieldID, id),
			sqlgraph.To(tube.Table, tube.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tubetype.TubeTable, tubetype.TubePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySampleTypes queries the sample_types edge of a TubeType.
func (c *TubeTypeClient) QuerySampleTypes(tt *TubeType) *SampleTypeQuery {
	query := (&SampleTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tubetype.Table, tubetype.FieldID, id),
			sqlgraph.To(sampletype.Table, sampletype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tubetype.SampleTypesTable, tubetype.SampleTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a TubeType.
func (c *TubeTypeClient) QueryTests(tt *TubeType) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tubetype.Table, tubetype.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tubetype.TestsTable, tubetype.TestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TubeTypeClient) Hooks() []Hook {
	return c.hooks.TubeType
}

// Interceptors returns the client interceptors.
func (c *TubeTypeClient) Interceptors() []Interceptor {
	return c.inters.TubeType
}

func (c *TubeTypeClient) mutate(ctx context.Context, m *TubeTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TubeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TubeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TubeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TubeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TubeType mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClinic queries the clinic edge of a User.
func (c *UserClient) QueryClinic(u *User) *ClinicQuery {
	query := (&ClinicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(clinic.Table, clinic.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ClinicTable, user.ClinicColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a User.
func (c *UserClient) QueryCustomer(u *User) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CustomerTable, user.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatient queries the patient edge of a User.
func (c *UserClient) QueryPatient(u *User) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PatientTable, user.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalUser queries the internal_user edge of a User.
func (c *UserClient) QueryInternalUser(u *User) *InternalUserQuery {
	query := (&InternalUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(internaluser.Table, internaluser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InternalUserTable, user.InternalUserColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserInvitationRecordClient is a client for the UserInvitationRecord schema.
type UserInvitationRecordClient struct {
	config
}

// NewUserInvitationRecordClient returns a client for the UserInvitationRecord from the given config.
func NewUserInvitationRecordClient(c config) *UserInvitationRecordClient {
	return &UserInvitationRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userinvitationrecord.Hooks(f(g(h())))`.
func (c *UserInvitationRecordClient) Use(hooks ...Hook) {
	c.hooks.UserInvitationRecord = append(c.hooks.UserInvitationRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userinvitationrecord.Intercept(f(g(h())))`.
func (c *UserInvitationRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserInvitationRecord = append(c.inters.UserInvitationRecord, interceptors...)
}

// Create returns a builder for creating a UserInvitationRecord entity.
func (c *UserInvitationRecordClient) Create() *UserInvitationRecordCreate {
	mutation := newUserInvitationRecordMutation(c.config, OpCreate)
	return &UserInvitationRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserInvitationRecord entities.
func (c *UserInvitationRecordClient) CreateBulk(builders ...*UserInvitationRecordCreate) *UserInvitationRecordCreateBulk {
	return &UserInvitationRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserInvitationRecordClient) MapCreateBulk(slice any, setFunc func(*UserInvitationRecordCreate, int)) *UserInvitationRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserInvitationRecordCreateBulk{err: fmt.Errorf("calling to UserInvitationRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserInvitationRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserInvitationRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserInvitationRecord.
func (c *UserInvitationRecordClient) Update() *UserInvitationRecordUpdate {
	mutation := newUserInvitationRecordMutation(c.config, OpUpdate)
	return &UserInvitationRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserInvitationRecordClient) UpdateOne(uir *UserInvitationRecord) *UserInvitationRecordUpdateOne {
	mutation := newUserInvitationRecordMutation(c.config, OpUpdateOne, withUserInvitationRecord(uir))
	return &UserInvitationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserInvitationRecordClient) UpdateOneID(id int) *UserInvitationRecordUpdateOne {
	mutation := newUserInvitationRecordMutation(c.config, OpUpdateOne, withUserInvitationRecordID(id))
	return &UserInvitationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserInvitationRecord.
func (c *UserInvitationRecordClient) Delete() *UserInvitationRecordDelete {
	mutation := newUserInvitationRecordMutation(c.config, OpDelete)
	return &UserInvitationRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserInvitationRecordClient) DeleteOne(uir *UserInvitationRecord) *UserInvitationRecordDeleteOne {
	return c.DeleteOneID(uir.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserInvitationRecordClient) DeleteOneID(id int) *UserInvitationRecordDeleteOne {
	builder := c.Delete().Where(userinvitationrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserInvitationRecordDeleteOne{builder}
}

// Query returns a query builder for UserInvitationRecord.
func (c *UserInvitationRecordClient) Query() *UserInvitationRecordQuery {
	return &UserInvitationRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserInvitationRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a UserInvitationRecord entity by its id.
func (c *UserInvitationRecordClient) Get(ctx context.Context, id int) (*UserInvitationRecord, error) {
	return c.Query().Where(userinvitationrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserInvitationRecordClient) GetX(ctx context.Context, id int) *UserInvitationRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserInvitationRecordClient) Hooks() []Hook {
	return c.hooks.UserInvitationRecord
}

// Interceptors returns the client interceptors.
func (c *UserInvitationRecordClient) Interceptors() []Interceptor {
	return c.inters.UserInvitationRecord
}

func (c *UserInvitationRecordClient) mutate(ctx context.Context, m *UserInvitationRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserInvitationRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserInvitationRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserInvitationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserInvitationRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserInvitationRecord mutation op: %q", m.Op())
	}
}

// ZipcodeClient is a client for the Zipcode schema.
type ZipcodeClient struct {
	config
}

// NewZipcodeClient returns a client for the Zipcode from the given config.
func NewZipcodeClient(c config) *ZipcodeClient {
	return &ZipcodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `zipcode.Hooks(f(g(h())))`.
func (c *ZipcodeClient) Use(hooks ...Hook) {
	c.hooks.Zipcode = append(c.hooks.Zipcode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `zipcode.Intercept(f(g(h())))`.
func (c *ZipcodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Zipcode = append(c.inters.Zipcode, interceptors...)
}

// Create returns a builder for creating a Zipcode entity.
func (c *ZipcodeClient) Create() *ZipcodeCreate {
	mutation := newZipcodeMutation(c.config, OpCreate)
	return &ZipcodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Zipcode entities.
func (c *ZipcodeClient) CreateBulk(builders ...*ZipcodeCreate) *ZipcodeCreateBulk {
	return &ZipcodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ZipcodeClient) MapCreateBulk(slice any, setFunc func(*ZipcodeCreate, int)) *ZipcodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ZipcodeCreateBulk{err: fmt.Errorf("calling to ZipcodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ZipcodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ZipcodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Zipcode.
func (c *ZipcodeClient) Update() *ZipcodeUpdate {
	mutation := newZipcodeMutation(c.config, OpUpdate)
	return &ZipcodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ZipcodeClient) UpdateOne(z *Zipcode) *ZipcodeUpdateOne {
	mutation := newZipcodeMutation(c.config, OpUpdateOne, withZipcode(z))
	return &ZipcodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ZipcodeClient) UpdateOneID(id int) *ZipcodeUpdateOne {
	mutation := newZipcodeMutation(c.config, OpUpdateOne, withZipcodeID(id))
	return &ZipcodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Zipcode.
func (c *ZipcodeClient) Delete() *ZipcodeDelete {
	mutation := newZipcodeMutation(c.config, OpDelete)
	return &ZipcodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ZipcodeClient) DeleteOne(z *Zipcode) *ZipcodeDeleteOne {
	return c.DeleteOneID(z.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ZipcodeClient) DeleteOneID(id int) *ZipcodeDeleteOne {
	builder := c.Delete().Where(zipcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ZipcodeDeleteOne{builder}
}

// Query returns a query builder for Zipcode.
func (c *ZipcodeClient) Query() *ZipcodeQuery {
	return &ZipcodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeZipcode},
		inters: c.Interceptors(),
	}
}

// Get returns a Zipcode entity by its id.
func (c *ZipcodeClient) Get(ctx context.Context, id int) (*Zipcode, error) {
	return c.Query().Where(zipcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ZipcodeClient) GetX(ctx context.Context, id int) *Zipcode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ZipcodeClient) Hooks() []Hook {
	return c.hooks.Zipcode
}

// Interceptors returns the client interceptors.
func (c *ZipcodeClient) Interceptors() []Interceptor {
	return c.inters.Zipcode
}

func (c *ZipcodeClient) mutate(ctx context.Context, m *ZipcodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ZipcodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ZipcodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ZipcodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ZipcodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Zipcode mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccountSubscription, Address, BetaProgram, BetaProgramParticipation, Clinic,
		Contact, CountryList, Customer, CustomerAddressOnClinics,
		CustomerContactOnClinics, CustomerSettingOnClinics, InternalUser,
		LabOrderSendHistory, LoginHistory, OrderFlag, OrderInfo, Patient, PatientFlag,
		PatientWeightHeight, PendingOrderCredits, RBACActions, RBACResources,
		RBACRoles, SalesTeam, SalesTerritory, SalesTitle, Sample, SampleIDGenerate,
		SampleType, Serviceship, ServiceshipBillingPlan, Setting, Test, TestDetail,
		TestList, Tube, TubeInstructions, TubeReceive, TubeRequirement, TubeType, User,
		UserInvitationRecord, Zipcode []ent.Hook
	}
	inters struct {
		AccountSubscription, Address, BetaProgram, BetaProgramParticipation, Clinic,
		Contact, CountryList, Customer, CustomerAddressOnClinics,
		CustomerContactOnClinics, CustomerSettingOnClinics, InternalUser,
		LabOrderSendHistory, LoginHistory, OrderFlag, OrderInfo, Patient, PatientFlag,
		PatientWeightHeight, PendingOrderCredits, RBACActions, RBACResources,
		RBACRoles, SalesTeam, SalesTerritory, SalesTitle, Sample, SampleIDGenerate,
		SampleType, Serviceship, ServiceshipBillingPlan, Setting, Test, TestDetail,
		TestList, Tube, TubeInstructions, TubeReceive, TubeRequirement, TubeType, User,
		UserInvitationRecord, Zipcode []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
