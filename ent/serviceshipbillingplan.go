// Code generated by ent, DO NOT EDIT.

package ent

import (
	"coresamples/ent/serviceship"
	"coresamples/ent/serviceshipbillingplan"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// ServiceshipBillingPlan is the model entity for the ServiceshipBillingPlan schema.
type ServiceshipBillingPlan struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Fee holds the value of the "fee" field.
	Fee float32 `json:"fee,omitempty"`
	// BillingCycle holds the value of the "billing_cycle" field.
	BillingCycle int32 `json:"billing_cycle,omitempty"`
	// Interval holds the value of the "interval" field.
	Interval serviceshipbillingplan.Interval `json:"interval,omitempty"`
	// EffectiveTime holds the value of the "effective_time" field.
	EffectiveTime time.Time `json:"effective_time,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ServiceshipBillingPlanQuery when eager-loading is set.
	Edges                                ServiceshipBillingPlanEdges `json:"edges"`
	serviceship_serviceship_billing_plan *int
	selectValues                         sql.SelectValues
}

// ServiceshipBillingPlanEdges holds the relations/edges for other nodes in the graph.
type ServiceshipBillingPlanEdges struct {
	// AccountSubscription holds the value of the account_subscription edge.
	AccountSubscription []*AccountSubscription `json:"account_subscription,omitempty"`
	// Serviceship holds the value of the serviceship edge.
	Serviceship *Serviceship `json:"serviceship,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// AccountSubscriptionOrErr returns the AccountSubscription value or an error if the edge
// was not loaded in eager-loading.
func (e ServiceshipBillingPlanEdges) AccountSubscriptionOrErr() ([]*AccountSubscription, error) {
	if e.loadedTypes[0] {
		return e.AccountSubscription, nil
	}
	return nil, &NotLoadedError{edge: "account_subscription"}
}

// ServiceshipOrErr returns the Serviceship value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ServiceshipBillingPlanEdges) ServiceshipOrErr() (*Serviceship, error) {
	if e.loadedTypes[1] {
		if e.Serviceship == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: serviceship.Label}
		}
		return e.Serviceship, nil
	}
	return nil, &NotLoadedError{edge: "serviceship"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ServiceshipBillingPlan) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case serviceshipbillingplan.FieldFee:
			values[i] = new(sql.NullFloat64)
		case serviceshipbillingplan.FieldID, serviceshipbillingplan.FieldBillingCycle:
			values[i] = new(sql.NullInt64)
		case serviceshipbillingplan.FieldInterval:
			values[i] = new(sql.NullString)
		case serviceshipbillingplan.FieldEffectiveTime:
			values[i] = new(sql.NullTime)
		case serviceshipbillingplan.ForeignKeys[0]: // serviceship_serviceship_billing_plan
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ServiceshipBillingPlan fields.
func (sbp *ServiceshipBillingPlan) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case serviceshipbillingplan.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			sbp.ID = int(value.Int64)
		case serviceshipbillingplan.FieldFee:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field fee", values[i])
			} else if value.Valid {
				sbp.Fee = float32(value.Float64)
			}
		case serviceshipbillingplan.FieldBillingCycle:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field billing_cycle", values[i])
			} else if value.Valid {
				sbp.BillingCycle = int32(value.Int64)
			}
		case serviceshipbillingplan.FieldInterval:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field interval", values[i])
			} else if value.Valid {
				sbp.Interval = serviceshipbillingplan.Interval(value.String)
			}
		case serviceshipbillingplan.FieldEffectiveTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field effective_time", values[i])
			} else if value.Valid {
				sbp.EffectiveTime = value.Time
			}
		case serviceshipbillingplan.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field serviceship_serviceship_billing_plan", value)
			} else if value.Valid {
				sbp.serviceship_serviceship_billing_plan = new(int)
				*sbp.serviceship_serviceship_billing_plan = int(value.Int64)
			}
		default:
			sbp.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the ServiceshipBillingPlan.
// This includes values selected through modifiers, order, etc.
func (sbp *ServiceshipBillingPlan) Value(name string) (ent.Value, error) {
	return sbp.selectValues.Get(name)
}

// QueryAccountSubscription queries the "account_subscription" edge of the ServiceshipBillingPlan entity.
func (sbp *ServiceshipBillingPlan) QueryAccountSubscription() *AccountSubscriptionQuery {
	return NewServiceshipBillingPlanClient(sbp.config).QueryAccountSubscription(sbp)
}

// QueryServiceship queries the "serviceship" edge of the ServiceshipBillingPlan entity.
func (sbp *ServiceshipBillingPlan) QueryServiceship() *ServiceshipQuery {
	return NewServiceshipBillingPlanClient(sbp.config).QueryServiceship(sbp)
}

// Update returns a builder for updating this ServiceshipBillingPlan.
// Note that you need to call ServiceshipBillingPlan.Unwrap() before calling this method if this ServiceshipBillingPlan
// was returned from a transaction, and the transaction was committed or rolled back.
func (sbp *ServiceshipBillingPlan) Update() *ServiceshipBillingPlanUpdateOne {
	return NewServiceshipBillingPlanClient(sbp.config).UpdateOne(sbp)
}

// Unwrap unwraps the ServiceshipBillingPlan entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sbp *ServiceshipBillingPlan) Unwrap() *ServiceshipBillingPlan {
	_tx, ok := sbp.config.driver.(*txDriver)
	if !ok {
		panic("ent: ServiceshipBillingPlan is not a transactional entity")
	}
	sbp.config.driver = _tx.drv
	return sbp
}

// String implements the fmt.Stringer.
func (sbp *ServiceshipBillingPlan) String() string {
	var builder strings.Builder
	builder.WriteString("ServiceshipBillingPlan(")
	builder.WriteString(fmt.Sprintf("id=%v, ", sbp.ID))
	builder.WriteString("fee=")
	builder.WriteString(fmt.Sprintf("%v", sbp.Fee))
	builder.WriteString(", ")
	builder.WriteString("billing_cycle=")
	builder.WriteString(fmt.Sprintf("%v", sbp.BillingCycle))
	builder.WriteString(", ")
	builder.WriteString("interval=")
	builder.WriteString(fmt.Sprintf("%v", sbp.Interval))
	builder.WriteString(", ")
	builder.WriteString("effective_time=")
	builder.WriteString(sbp.EffectiveTime.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// ServiceshipBillingPlans is a parsable slice of ServiceshipBillingPlan.
type ServiceshipBillingPlans []*ServiceshipBillingPlan
