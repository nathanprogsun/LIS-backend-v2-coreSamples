// Code generated by ent, DO NOT EDIT.

package ent

import (
	"coresamples/ent/countrylist"
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// CountryList is the model entity for the CountryList schema.
type CountryList struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"vibrant_country_id"`
	// CountryName holds the value of the "country_name" field.
	CountryName string `json:"country_name,omitempty"`
	// Alpha2Code holds the value of the "alpha_2_code" field.
	Alpha2Code string `json:"alpha_2_code,omitempty"`
	// Alpha3Code holds the value of the "alpha_3_code" field.
	Alpha3Code string `json:"alpha_3_code,omitempty"`
	// CountryCodeEnum holds the value of the "country_code_enum" field.
	CountryCodeEnum string `json:"country_code_enum,omitempty"`
	// Iso holds the value of the "iso" field.
	Iso string `json:"iso,omitempty"`
	// CountryRegion holds the value of the "country_region" field.
	CountryRegion string `json:"country_region,omitempty"`
	// CountrySubregion holds the value of the "country_subregion" field.
	CountrySubregion string `json:"country_subregion,omitempty"`
	// CountryRegionCode holds the value of the "country_region_code" field.
	CountryRegionCode string `json:"country_region_code,omitempty"`
	// CountrySubRegionCode holds the value of the "country_sub_region_code" field.
	CountrySubRegionCode string `json:"country_sub_region_code,omitempty"`
	selectValues         sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*CountryList) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case countrylist.FieldID:
			values[i] = new(sql.NullInt64)
		case countrylist.FieldCountryName, countrylist.FieldAlpha2Code, countrylist.FieldAlpha3Code, countrylist.FieldCountryCodeEnum, countrylist.FieldIso, countrylist.FieldCountryRegion, countrylist.FieldCountrySubregion, countrylist.FieldCountryRegionCode, countrylist.FieldCountrySubRegionCode:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the CountryList fields.
func (cl *CountryList) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case countrylist.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			cl.ID = int(value.Int64)
		case countrylist.FieldCountryName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_name", values[i])
			} else if value.Valid {
				cl.CountryName = value.String
			}
		case countrylist.FieldAlpha2Code:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field alpha_2_code", values[i])
			} else if value.Valid {
				cl.Alpha2Code = value.String
			}
		case countrylist.FieldAlpha3Code:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field alpha_3_code", values[i])
			} else if value.Valid {
				cl.Alpha3Code = value.String
			}
		case countrylist.FieldCountryCodeEnum:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_code_enum", values[i])
			} else if value.Valid {
				cl.CountryCodeEnum = value.String
			}
		case countrylist.FieldIso:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field iso", values[i])
			} else if value.Valid {
				cl.Iso = value.String
			}
		case countrylist.FieldCountryRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_region", values[i])
			} else if value.Valid {
				cl.CountryRegion = value.String
			}
		case countrylist.FieldCountrySubregion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_subregion", values[i])
			} else if value.Valid {
				cl.CountrySubregion = value.String
			}
		case countrylist.FieldCountryRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_region_code", values[i])
			} else if value.Valid {
				cl.CountryRegionCode = value.String
			}
		case countrylist.FieldCountrySubRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_sub_region_code", values[i])
			} else if value.Valid {
				cl.CountrySubRegionCode = value.String
			}
		default:
			cl.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the CountryList.
// This includes values selected through modifiers, order, etc.
func (cl *CountryList) Value(name string) (ent.Value, error) {
	return cl.selectValues.Get(name)
}

// Update returns a builder for updating this CountryList.
// Note that you need to call CountryList.Unwrap() before calling this method if this CountryList
// was returned from a transaction, and the transaction was committed or rolled back.
func (cl *CountryList) Update() *CountryListUpdateOne {
	return NewCountryListClient(cl.config).UpdateOne(cl)
}

// Unwrap unwraps the CountryList entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (cl *CountryList) Unwrap() *CountryList {
	_tx, ok := cl.config.driver.(*txDriver)
	if !ok {
		panic("ent: CountryList is not a transactional entity")
	}
	cl.config.driver = _tx.drv
	return cl
}

// String implements the fmt.Stringer.
func (cl *CountryList) String() string {
	var builder strings.Builder
	builder.WriteString("CountryList(")
	builder.WriteString(fmt.Sprintf("id=%v, ", cl.ID))
	builder.WriteString("country_name=")
	builder.WriteString(cl.CountryName)
	builder.WriteString(", ")
	builder.WriteString("alpha_2_code=")
	builder.WriteString(cl.Alpha2Code)
	builder.WriteString(", ")
	builder.WriteString("alpha_3_code=")
	builder.WriteString(cl.Alpha3Code)
	builder.WriteString(", ")
	builder.WriteString("country_code_enum=")
	builder.WriteString(cl.CountryCodeEnum)
	builder.WriteString(", ")
	builder.WriteString("iso=")
	builder.WriteString(cl.Iso)
	builder.WriteString(", ")
	builder.WriteString("country_region=")
	builder.WriteString(cl.CountryRegion)
	builder.WriteString(", ")
	builder.WriteString("country_subregion=")
	builder.WriteString(cl.CountrySubregion)
	builder.WriteString(", ")
	builder.WriteString("country_region_code=")
	builder.WriteString(cl.CountryRegionCode)
	builder.WriteString(", ")
	builder.WriteString("country_sub_region_code=")
	builder.WriteString(cl.CountrySubRegionCode)
	builder.WriteByte(')')
	return builder.String()
}

// CountryLists is a parsable slice of CountryList.
type CountryLists []*CountryList
