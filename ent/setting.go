// Code generated by ent, DO NOT EDIT.

package ent

import (
	"coresamples/ent/setting"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Setting is the model entity for the Setting schema.
type Setting struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"setting_id"`
	// SettingName holds the value of the "setting_name" field.
	SettingName string `json:"setting_name,omitempty"`
	// SettingGroup holds the value of the "setting_group" field.
	SettingGroup string `json:"setting_group,omitempty"`
	// SettingDescription holds the value of the "setting_description" field.
	SettingDescription string `json:"setting_description,omitempty"`
	// SettingValue holds the value of the "setting_value" field.
	SettingValue string `json:"setting_value,omitempty"`
	// SettingType holds the value of the "setting_type" field.
	SettingType string `json:"setting_type,omitempty"`
	// SettingValueUpdatedTime holds the value of the "setting_value_updated_time" field.
	SettingValueUpdatedTime time.Time `json:"setting_value_updated_time,omitempty"`
	// IsActive holds the value of the "is_active" field.
	IsActive bool `json:"isActive"`
	// ApplyToAllGroupMember holds the value of the "apply_to_all_group_member" field.
	ApplyToAllGroupMember bool `json:"applyToAllGroupMember"`
	// IsOfficial holds the value of the "is_official" field.
	IsOfficial bool `json:"isOfficial"`
	// SettingLevel holds the value of the "setting_level" field.
	SettingLevel int `json:"setting_level,omitempty"`
	// SettingLevelName holds the value of the "setting_level_name" field.
	SettingLevelName string `json:"setting_level_name,omitempty"`
	// UseGroupSetting holds the value of the "use_group_setting" field.
	UseGroupSetting bool `json:"useGroupSetting"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SettingQuery when eager-loading is set.
	Edges        SettingEdges `json:"edges"`
	selectValues sql.SelectValues
}

// SettingEdges holds the relations/edges for other nodes in the graph.
type SettingEdges struct {
	// Clinics holds the value of the clinics edge.
	Clinics []*Clinic `json:"clinics,omitempty"`
	// InternalUsers holds the value of the internal_users edge.
	InternalUsers []*InternalUser `json:"internal_users,omitempty"`
	// Patients holds the value of the patients edge.
	Patients []*Patient `json:"patients,omitempty"`
	// ClinicCustomers holds the value of the clinic_customers edge.
	ClinicCustomers []*CustomerSettingOnClinics `json:"clinic_customers,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
}

// ClinicsOrErr returns the Clinics value or an error if the edge
// was not loaded in eager-loading.
func (e SettingEdges) ClinicsOrErr() ([]*Clinic, error) {
	if e.loadedTypes[0] {
		return e.Clinics, nil
	}
	return nil, &NotLoadedError{edge: "clinics"}
}

// InternalUsersOrErr returns the InternalUsers value or an error if the edge
// was not loaded in eager-loading.
func (e SettingEdges) InternalUsersOrErr() ([]*InternalUser, error) {
	if e.loadedTypes[1] {
		return e.InternalUsers, nil
	}
	return nil, &NotLoadedError{edge: "internal_users"}
}

// PatientsOrErr returns the Patients value or an error if the edge
// was not loaded in eager-loading.
func (e SettingEdges) PatientsOrErr() ([]*Patient, error) {
	if e.loadedTypes[2] {
		return e.Patients, nil
	}
	return nil, &NotLoadedError{edge: "patients"}
}

// ClinicCustomersOrErr returns the ClinicCustomers value or an error if the edge
// was not loaded in eager-loading.
func (e SettingEdges) ClinicCustomersOrErr() ([]*CustomerSettingOnClinics, error) {
	if e.loadedTypes[3] {
		return e.ClinicCustomers, nil
	}
	return nil, &NotLoadedError{edge: "clinic_customers"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Setting) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case setting.FieldIsActive, setting.FieldApplyToAllGroupMember, setting.FieldIsOfficial, setting.FieldUseGroupSetting:
			values[i] = new(sql.NullBool)
		case setting.FieldID, setting.FieldSettingLevel:
			values[i] = new(sql.NullInt64)
		case setting.FieldSettingName, setting.FieldSettingGroup, setting.FieldSettingDescription, setting.FieldSettingValue, setting.FieldSettingType, setting.FieldSettingLevelName:
			values[i] = new(sql.NullString)
		case setting.FieldSettingValueUpdatedTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Setting fields.
func (s *Setting) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case setting.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			s.ID = int(value.Int64)
		case setting.FieldSettingName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_name", values[i])
			} else if value.Valid {
				s.SettingName = value.String
			}
		case setting.FieldSettingGroup:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_group", values[i])
			} else if value.Valid {
				s.SettingGroup = value.String
			}
		case setting.FieldSettingDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_description", values[i])
			} else if value.Valid {
				s.SettingDescription = value.String
			}
		case setting.FieldSettingValue:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_value", values[i])
			} else if value.Valid {
				s.SettingValue = value.String
			}
		case setting.FieldSettingType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_type", values[i])
			} else if value.Valid {
				s.SettingType = value.String
			}
		case setting.FieldSettingValueUpdatedTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field setting_value_updated_time", values[i])
			} else if value.Valid {
				s.SettingValueUpdatedTime = value.Time
			}
		case setting.FieldIsActive:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_active", values[i])
			} else if value.Valid {
				s.IsActive = value.Bool
			}
		case setting.FieldApplyToAllGroupMember:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field apply_to_all_group_member", values[i])
			} else if value.Valid {
				s.ApplyToAllGroupMember = value.Bool
			}
		case setting.FieldIsOfficial:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_official", values[i])
			} else if value.Valid {
				s.IsOfficial = value.Bool
			}
		case setting.FieldSettingLevel:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field setting_level", values[i])
			} else if value.Valid {
				s.SettingLevel = int(value.Int64)
			}
		case setting.FieldSettingLevelName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field setting_level_name", values[i])
			} else if value.Valid {
				s.SettingLevelName = value.String
			}
		case setting.FieldUseGroupSetting:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field use_group_setting", values[i])
			} else if value.Valid {
				s.UseGroupSetting = value.Bool
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Setting.
// This includes values selected through modifiers, order, etc.
func (s *Setting) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// QueryClinics queries the "clinics" edge of the Setting entity.
func (s *Setting) QueryClinics() *ClinicQuery {
	return NewSettingClient(s.config).QueryClinics(s)
}

// QueryInternalUsers queries the "internal_users" edge of the Setting entity.
func (s *Setting) QueryInternalUsers() *InternalUserQuery {
	return NewSettingClient(s.config).QueryInternalUsers(s)
}

// QueryPatients queries the "patients" edge of the Setting entity.
func (s *Setting) QueryPatients() *PatientQuery {
	return NewSettingClient(s.config).QueryPatients(s)
}

// QueryClinicCustomers queries the "clinic_customers" edge of the Setting entity.
func (s *Setting) QueryClinicCustomers() *CustomerSettingOnClinicsQuery {
	return NewSettingClient(s.config).QueryClinicCustomers(s)
}

// Update returns a builder for updating this Setting.
// Note that you need to call Setting.Unwrap() before calling this method if this Setting
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Setting) Update() *SettingUpdateOne {
	return NewSettingClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Setting entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Setting) Unwrap() *Setting {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Setting is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Setting) String() string {
	var builder strings.Builder
	builder.WriteString("Setting(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("setting_name=")
	builder.WriteString(s.SettingName)
	builder.WriteString(", ")
	builder.WriteString("setting_group=")
	builder.WriteString(s.SettingGroup)
	builder.WriteString(", ")
	builder.WriteString("setting_description=")
	builder.WriteString(s.SettingDescription)
	builder.WriteString(", ")
	builder.WriteString("setting_value=")
	builder.WriteString(s.SettingValue)
	builder.WriteString(", ")
	builder.WriteString("setting_type=")
	builder.WriteString(s.SettingType)
	builder.WriteString(", ")
	builder.WriteString("setting_value_updated_time=")
	builder.WriteString(s.SettingValueUpdatedTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("is_active=")
	builder.WriteString(fmt.Sprintf("%v", s.IsActive))
	builder.WriteString(", ")
	builder.WriteString("apply_to_all_group_member=")
	builder.WriteString(fmt.Sprintf("%v", s.ApplyToAllGroupMember))
	builder.WriteString(", ")
	builder.WriteString("is_official=")
	builder.WriteString(fmt.Sprintf("%v", s.IsOfficial))
	builder.WriteString(", ")
	builder.WriteString("setting_level=")
	builder.WriteString(fmt.Sprintf("%v", s.SettingLevel))
	builder.WriteString(", ")
	builder.WriteString("setting_level_name=")
	builder.WriteString(s.SettingLevelName)
	builder.WriteString(", ")
	builder.WriteString("use_group_setting=")
	builder.WriteString(fmt.Sprintf("%v", s.UseGroupSetting))
	builder.WriteByte(')')
	return builder.String()
}

// Settings is a parsable slice of Setting.
type Settings []*Setting
